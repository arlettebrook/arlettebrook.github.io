<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="Git常用的一些命令，需要Git基础，方便查阅。"><title>Git常用命令</title>
<link rel=canonical href=https://arlettebrook.github.io/p/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/><link rel=stylesheet href=/scss/style.min.59d76563977ef6a76d0c7df16aa86c7ac37ed8942ba1442046cb6cf3b07439d7.css><meta property='og:title' content="Git常用命令"><meta property='og:description' content="Git常用的一些命令，需要Git基础，方便查阅。"><meta property='og:url' content='https://arlettebrook.github.io/p/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/'><meta property='og:site_name' content="Arlettebrook's blog"><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='Github'><meta property='article:published_time' content='2024-04-22T22:18:17+08:00'><meta property='article:modified_time' content='2024-04-26T17:41:17+08:00'><meta name=twitter:site content="@arlettebrook"><meta name=twitter:creator content="@arlettebrook"><meta name=twitter:title content="Git常用命令"><meta name=twitter:description content="Git常用的一些命令，需要Git基础，方便查阅。"><link rel="shortcut icon" href=/img/favicon.ico></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><div id=article-toolbar style=position:sticky;top:5px;z-index:1000><a href=/ class=back-home><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg>
<span>返回</span></a></div><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#git简单命令>git简单命令</a><ol><li><a href=#git-init>git init</a></li><li><a href=#git-clone>git clone</a></li><li><a href=#git-add>git add</a></li><li><a href=#git-commit>git commit</a></li><li><a href=#git-status>git status</a></li><li><a href=#git-reflog>git reflog</a></li><li><a href=#git-rm>git rm</a></li><li><a href=#git-switch>git switch</a></li><li><a href=#git-branch>git branch</a></li><li><a href=#git-merge>git merge</a></li></ol></li><li><a href=#git一般命令>git一般命令</a><ol><li><a href=#git-revert>git revert</a></li><li><a href=#git-reset>git reset</a></li><li><a href=#git-restore>git restore</a></li><li><a href=#git-checkout>git checkout</a></li><li><a href=#git-remote>git remote</a></li><li><a href=#gjit-push>gjit push</a></li><li><a href=#git-pull>git pull</a></li><li><a href=#git-fetch>git fetch</a></li><li><a href=#git-stash>git stash</a></li><li><a href=#git-tag>git tag</a></li></ol></li><li><a href=#git复杂命令>git复杂命令</a><ol><li><a href=#git-log>git log</a></li><li><a href=#git-diff>git diff</a></li><li><a href=#git-config>git config</a></li><li><a href=#git-submodule>git submodule</a></li><li><a href=#git-subtree>git subtree</a></li><li><a href=#git-rebase>git rebase</a></li></ol></li><li><a href=#扩展>扩展</a><ol><li><a href=#gitignore文件>.gitignore文件</a></li><li><a href=#git账户认证>git账户认证</a><ol><li><a href=#ssh-keygen>ssh-keygen</a></li></ol></li></ol></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/git/ style=background-color:#2a9d8f;color:#fff>Git
</a><a href=/categories/%E6%8A%80%E6%9C%AF/ style=background-color:#2a9d8f;color:#fff>技术</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/>Git常用命令</a></h2><h3 class=article-subtitle>Git常用的一些命令，需要Git基础，方便查阅。</h3></div><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Apr 22, 2024</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>阅读时长: 20 分钟</time></div></footer><footer class=article-translations><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-language" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 5h7"/><path d="M9 3v2c0 4.418-2.239 8-5 8"/><path d="M5 9c-.003 2.144 2.952 3.908 6.7 4"/><path d="M12 20l4-9 4 9"/><path d="M19.1 18h-6.2"/></svg><div><a href=https://arlettebrook.github.io/en/p/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/ class=link>English</a></div></footer></div></header><section class=article-content><blockquote><p>注意：要学会使用-h &ndash;help选项，查看命令，看不懂在查阅。<code>git help &lt;command></code>可进入官方文档。<strong>Git</strong><a class=link href=https://www.liaoxuefeng.com/wiki/896043488029600 target=_blank rel=noopener>入门参考</a>。以下常用命令个人收集总结。</p></blockquote><hr><h2 id=git简单命令><a href=#git%e7%ae%80%e5%8d%95%e5%91%bd%e4%bb%a4 class=header-anchor>#</a>
git简单命令</h2><h3 id=git-init><a href=#git-init class=header-anchor>#</a>
git init</h3><ul><li><code>git init &lt;directory></code>在指定的⽬录下创建⼀个空的git repo。不带参数将在当前⽬录下创建⼀个git repo。</li></ul><h3 id=git-clone><a href=#git-clone class=header-anchor>#</a>
git clone</h3><ul><li><code>git clone &lt;repo></code>克隆⼀个指定repo到本地。指定的repo可以是本地⽂件系统或者由HTTP或SSH指定的远程路径。</li><li><code>git clone -b &lt;branch> &lt;repo></code>克隆指定仓库的分支</li><li><code>git clone --recursive &lt;repo></code>递归地克隆，克隆带有子模块的仓库<ul><li><code>git clone --recurse-submodules &lt;repository_url></code>同理</li></ul></li><li>可组合使用</li></ul><h3 id=git-add><a href=#git-add class=header-anchor>#</a>
git add</h3><ul><li><code>git add &lt;directory></code>将指定⽬录的所有修改加⼊到下⼀次 commit中。把<code>&lt;directory></code>替换成<code>&lt;file></code>将添加指定⽂件的修改。</li><li><code>git add *</code>、<code>git add .</code>、<code>git add -A</code>三条命令但是一样的，将所以修改提交到暂存区。</li></ul><h3 id=git-commit><a href=#git-commit class=header-anchor>#</a>
git commit</h3><ul><li>这个命令通常带<code>-m</code>选项<code>git commit -m "&lt;message>"</code>提交暂存区的修改，使⽤指定的 <code>&lt;message></code>作为提交信息，⽽不是打开⽂本编辑器输⼊提交信息。</li><li><code>git commit -m &lt;message> --amend</code>将当前staged修改合并到最近⼀次的commit中。</li></ul><h3 id=git-status><a href=#git-status class=header-anchor>#</a>
git status</h3><ul><li><code>git status</code>显示哪些⽂件已被staged、以及未跟踪(untracked)。</li></ul><h3 id=git-reflog><a href=#git-reflog class=header-anchor>#</a>
git reflog</h3><ul><li><code>git reflog</code>显示本地repo的所有commit⽇志。</li><li>与<code>git log</code>的区别<ol><li><code>log</code>项目的提交历史，<code>reflog</code>本地仓库的<strong>引用</strong>提交日志。</li><li>引用会保留所以的提交历史，如何重置的历史。主要目的是提供一个安全网，以便在误操作（如错误的 <code>git reset</code>）后可以恢复丢失的提交或分支。</li><li><code>git log</code> 的输出是永久性的，而 <code>reflog</code> 会在一段时间后自动过期（默认是 30 天），以节省空间。</li></ol></li></ul><h3 id=git-rm><a href=#git-rm class=header-anchor>#</a>
git rm</h3><ul><li><code>git rm fileName</code>删除指定的文件。<ul><li>与<code>rm fileName</code>的区别。<ol><li><code>git rm</code>不能删除未跟踪的文件，</li><li><code>git rm</code>删除之后直接到暂存区，而<code>rm</code>是到工作区</li></ol></li></ul></li><li>注意删除之后都需要提交操作。</li><li>撤销操作不用记，git都会有提示</li></ul><h3 id=git-switch><a href=#git-switch class=header-anchor>#</a>
git switch</h3><ul><li><p>该命令适用于特定git版本。</p></li><li><p><code>git switch &lt;branch></code>切换到指定分支，</p><ul><li><code>git checkout &lt;branch></code>同理，但这个都适用。</li></ul></li><li><p><code>git switch -c &lt;branch></code>创建并切换指定分支</p></li></ul><h3 id=git-branch><a href=#git-branch class=header-anchor>#</a>
git branch</h3><ul><li><p><code>git branch</code>显示本地repo的所有分⽀。</p><ul><li><code>-v</code>显示详细信息</li><li>带<code>*</code>的为当前分支</li></ul></li><li><p><code>git branch -r</code>显示远程仓库的所以分支。</p><ul><li>可以使用<code>git checkout &lt;branch></code>检出远程分支，可以省略<code>origin/</code>。</li></ul></li><li><p><code>git branch -a</code>显示本地和远程的所有分支</p></li><li><p><code>git branch -m &lt;old_branch_name> &lt;new_branch_name></code>重命名分支</p><ul><li>新分支名已经存在， <code>-M</code> 强制重命名。</li></ul></li><li><p><code>git branch &lt;name></code>创建指定分支</p></li><li><p><code>git branch -D &lt;branch></code>强制删除指定分支，无论是否合并到当前分支。</p></li><li><p><code>git branch -d &lt;branch></code>删除指定的分支，如果没有合并到当前分支，git会阻止操作。</p></li></ul><h3 id=git-merge><a href=#git-merge class=header-anchor>#</a>
git merge</h3><ul><li><code>git merge &lt;branch></code>合并指定分支。将指定<code>&lt;branch></code>分⽀合并到当前分⽀。<ul><li>是在当前分支合并指定分支。</li><li>合并分支可能会出现冲突。要解决冲突之后才能合并。</li></ul></li><li><code>git merge --abort</code>放弃本次合并</li></ul><hr><h2 id=git一般命令><a href=#git%e4%b8%80%e8%88%ac%e5%91%bd%e4%bb%a4 class=header-anchor>#</a>
git一般命令</h2><h3 id=git-revert><a href=#git-revert class=header-anchor>#</a>
git revert</h3><ul><li><code>git revert &lt;commit> </code>对指定<code>&lt;commit></code>创建⼀个undo的commit，并应⽤到当前分⽀。就是撤销指定的提交并保留记录<ul><li>效果：撤销指定的提交，回到了撤销提交的是上个版本，<strong>保留了撤销历史</strong>。<strong>会打开编辑器显示具体效果</strong></li><li>一般不用</li></ul></li></ul><h3 id=git-reset><a href=#git-reset class=header-anchor>#</a>
git reset</h3><ul><li><p><code>git reset &lt;commit></code><strong>重置</strong>到指定的提交，不会保留commit历史。工作区和暂存区会变成未跟踪。<code>--hard</code>选项完全重置到指定提交。未跟踪的重置不了。重置历史可以通过<code>git reflog</code>查看，利用这个可以重置已经重置的版本库。</p><ul><li><code>&lt;commit></code>可以是：<ul><li><code>HEAD</code>表示最新的提交或者这个<strong>版本库</strong>，HEAD^、HEAD~1上上次提交或者上个版本</li><li>或者使用<code>commit_hash</code>，提交的哈希值可以使用<code>git log</code>查看，只需要前几位就行。</li></ul></li></ul></li><li><p><code>git reset</code>（重置到最新的提交）移除所有暂存区、工作区的修改，到未跟踪。这些命令其实省略了<code>HEAD</code></p><ul><li><p><code>git reset --hard</code> 重置到最新的提交，删除工作区和暂存区</p></li><li><p><code>git reset &lt;file></code>将<code>&lt;file></code>从暂存区移除，但保持⼯作区不变。此操作不会修改⼯作区的任何⽂件。</p></li></ul></li></ul><h3 id=git-restore><a href=#git-restore class=header-anchor>#</a>
git restore</h3><ul><li><code>git restore &lt;file>...</code>撤销对工作区的修改，是对以跟踪的文件当未添加到暂存区的文件。多个文件用空格分开。<ul><li><code>git checkout -- &lt;file>...</code>同理，<code>--</code>可以省略</li></ul></li><li><code>git restore --staged &lt;file>...</code>撤销对暂存区的修改到未跟踪。针对添加到暂存区的文件。<ul><li><code>git reset HEAD &lt;file>...</code>同理，<code>HEAD</code>可以省略。</li></ul></li><li>具体用哪一个，git都会有提示，不用记。</li></ul><h3 id=git-checkout><a href=#git-checkout class=header-anchor>#</a>
git checkout</h3><ul><li><p><code>git checkout &lt;branch></code>切换到指定的分支</p><ul><li>如果分支为远程分支，则检出远程分支</li></ul></li><li><p><code>git checkout -b &lt;new-branch></code>切换并创建指定的分支</p></li><li><p><code>git checkout &lt;file></code>撤销工作区的修改</p><ul><li><code>git restore &lt;file></code>同理</li></ul></li><li><p><code>git checkout &lt;commit></code>根据指定的提交创建一个分支,处于游离态。一般不用。</p></li><li><p><code>git checkout -b &lt;local_branch_name> origin/&lt;remote_branch_name></code>切换到远程分支</p><ul><li><code>git checkout &lt;branch></code>差不多，可以使用<code>git fetch origin</code>获取仓库所以信息，在检出分支。</li></ul></li><li><p><code>git checkout -</code>切换到前一个分支。</p></li></ul><h3 id=git-remote><a href=#git-remote class=header-anchor>#</a>
git remote</h3><ul><li><p>用来管理远程仓库列表，<code>origin</code>为远程仓库的默认别名。这些远端仓库的信息都被保存在<code>./git/config</code> 文件中。</p></li><li><p><code>git remote</code>列出所有已配置的远程仓库的信息。</p><ul><li><code>-v</code>显示详细信息</li></ul></li><li><p><code>git remote add &lt;remote_name> &lt;remote_url></code>添加远程仓库</p><ul><li>添加⼀个新的远程连接。添加后可使⽤ <code>&lt;name></code>作为指定<code>&lt;url></code>远程连接的名称。</li><li>只有配置了这个才能推送到远程仓库。</li><li><code>git remote rename &lt;old_name> &lt;new_name></code>重命名远程仓库。</li><li><code>git remote set-url &lt;remote_name> &lt;new_url></code>修改远程仓库的url。</li><li><code>git remote remove &lt;remote_name></code>或<code>git remote rm &lt;remote_name></code>删除远程仓库。</li></ul></li><li><p><code>git remote show &lt;remote_name></code>显示远程仓库的详细信息，包括 URL、跟踪的分支等。</p></li><li><p>补充如何创建远程仓库</p><ol><li><p>创建远程仓库可以先在github上创建好，然后在本地pull下来，在进行修改后push上去。</p></li><li><p>可以建一个<strong>空白仓库</strong>，在本地push上去，但需要进行绑定。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>git remote add origin https://github.com/username/null-project.git
</span></span><span class=line><span class=cl>git branch -M main
</span></span><span class=line><span class=cl>git push -u origin main
</span></span></code></pre></td></tr></table></div></div></li></ol></li></ul><h3 id=gjit-push><a href=#gjit-push class=header-anchor>#</a>
gjit push</h3><ul><li><p>将本地仓库推送到远程仓库</p></li><li><p><code>git push &lt;remote_repository> &lt;本地分支名>:&lt;远程分支名></code>推送本地分支到指定的远程分支。如果远程分支不存在，会自动创建。<code>:</code>前后不能有空格。</p><ul><li>当分支同名，可以简写成<code>git push &lt;remote_repository> &lt;本地分支名></code></li><li>果无法提交的话执行，<code>-f</code>、<code>--force</code>选项强制推送，一般不用。</li></ul></li><li><p><code>git push -u &lt;remote_repository> &lt;本地分支名></code>设置默认推送分支。</p><ul><li>作用：这样设置以后，推送到远程仓库可以简写成<code>git push</code><ul><li><code>git push</code> 代替 <code>git push origin master</code></li></ul></li><li><code>-u</code>是<code>--set-upstream</code>的短形式。</li></ul></li><li><p><code>git push &lt;remote_repository> -d &lt;远程分支名></code>删除远程分支 。</p><ul><li><code>--delete</code>长选项。</li><li><code>git push origin :test</code>同理，没有写本地分支，就是删除远程分支。</li></ul></li><li><p><code>git push &lt;remote> &lt;tagname></code>推送指定标签到指定远程仓库，一般为`origin``</p></li><li><p>``git push <remote>&ndash;tags`推送所用标签到远程</p></li></ul><h3 id=git-pull><a href=#git-pull class=header-anchor>#</a>
git pull</h3><ul><li><code>git pull &lt;remote_repository> &lt;远程分支名>:&lt;本地分支名></code>从远程仓库拉取最新代码到本地仓库。<ul><li><code>git pull</code>会拉取并合并，出现冲突要解决之后才能合并。</li><li><code>git fetch</code>获取当前远程仓库的最新信息，不会合并。</li><li>通常可以简写成<code>git pull</code>,远程仓库默认是<code>origin</code>，分支默认是当前分支。</li></ul></li><li><code>git pull --rebase&lt;remote></code> 抓取远程分⽀，并以rebase模式并⼊本地repo⽽不是merge。</li></ul><h3 id=git-fetch><a href=#git-fetch class=header-anchor>#</a>
git fetch</h3><ul><li><code>git fetch origin</code>获取远程仓库最新的更改。不会合并。默认仓库是<code>origin</code>，分支是当前分支，这里可以省略<code>origin</code><ul><li><code>git fetch origin &lt;branch></code>获取特定分支的更改.</li></ul></li><li><code>git fetch --all</code>获取所用仓库远程仓库的最新更改。</li><li>与<code>git pull</code>的区别<ol><li>都会获取远程仓库最新的更改。</li><li>但是fetch不会合并，而pull会合并。可以理解为<code>git pull</code> 是 <code>git fetch</code> 和 <code>git merge</code> 的组合</li></ol></li><li>获取最新更改之后可以：<ol><li><code>git checkout &lt;branch></code>检出指定分支，如果加<code>origin</code>要这样<code>git checkout -b &lt;branch> origin/&lt;branch></code></li><li><code>git merge origin/master</code>合并远程 master 分支的更改到当前的分支</li><li><code>git rebase origin/master</code>使用 rebase 来整合更改（这可能会改变提交历史）</li></ol></li></ul><h3 id=git-stash><a href=#git-stash class=header-anchor>#</a>
git stash</h3><ul><li><code>git stash</code>保存工作区、暂存区，可以切换分支去完成别的任务。不保存修改，未提交的修改会错乱到别的分支。并且只能保存已追踪的文件。</li><li><code>git stash list</code>查看保存的工作区以及暂存区。</li><li><code>git stash apply</code>恢复保存的工作区以及暂存区。<ul><li>这个命令执行之后不会删除存储的工作区以及暂存区。</li><li>要用<code>git stash drop</code>才能删除。</li></ul></li><li><code>git stash pop</code>恢复并删除保存的工作区以及暂存区。</li><li>默认都是保存、恢复第一个stash即<code>stash@{0}</code>。若要指定第几个在后面加<code>stash@{num}</code>。<ul><li>如恢复第二个stash：<code>git stash pop stash@{1}</code></li></ul></li><li>每个分支共用一个stash。</li></ul><h3 id=git-tag><a href=#git-tag class=header-anchor>#</a>
git tag</h3><ul><li>作用：用于标记项目的版本发布或重要的里程碑。</li><li>分类<ol><li><code>git tag &lt;tagname> &lt;commit ID></code>轻量标签<ul><li><code>git tag vn.n.n</code>打标签，<code>n.n.n</code>表示对应的版本号，版本号前面一般加<code>v</code>，遵循一定的命名规范，如<code>v1.0.1</code>。<ul><li>默认是打在最新的一次提交。</li><li>后面跟提交的哈希值可以指定给那次提交打标签。如<code>git tag v0.9.0 f52c633</code>。<ul><li>哈希值可以通过<code>git log</code>查看</li></ul></li></ul></li></ul></li><li><code>git tag -a &lt;tagname> -m "&lt;tag message>" &lt;commit ID></code>附注标签<ol><li>如<code>git tag -a v0.1 -m "version 0.1 released" 1094adb</code></li><li>推荐id省略默认最新提交。</li></ol></li></ol></li><li>查看标签<ol><li><code>git tag</code>显示所有的本地tag列表，按照字母顺序排序。如果tag数量较多，可能会显示不全。省略选项<code>-l</code>、<code>--list</code></li><li><code>git show &lt;tagname></code>显示指定tag的详细信息，包括提交的作者、提交时间、提交信息等。</li><li><code>git tag -n</code>：显示tag列表，并同时显示每个tag对应的提交信息。</li><li><code>git ls-remote --tags origin</code>：显示远程仓库中的所有tag信息。更推荐这种。<ol><li>或者先<code>git fetch</code>获取最新的更改，然后<code>git tag</code>检出所有标签。</li></ol></li></ol></li><li>删除标签<ol><li><code>git tag -d &lt;tagname></code>删除本地标签</li><li>删除远程标签：首先需要在本地删除标签，然后推送到远程仓库 <code>git push origin :refs/tags/&lt;tagname></code><ol><li>远程标签是<code>refs/tags/v0.0.1</code>这样存在的，跟删除远程分支差不多。</li></ol></li></ol></li><li>标签一旦创建，就不能直接修改,如果需要修改标签，通常需要删除原标签，并重新创建一个新标签。</li><li>推送标签<ol><li>打的标签不会自动推送到远程仓库，需要手动推送。</li><li><code>git push &lt;remote> &lt;tagname></code>推送指定标签到指定远程仓库，一般为<code>origin</code></li><li><code>git push &lt;remote> --tags</code>推送所用标签到远程</li></ol></li></ul><hr><h2 id=git复杂命令><a href=#git%e5%a4%8d%e6%9d%82%e5%91%bd%e4%bb%a4 class=header-anchor>#</a>
git复杂命令</h2><h3 id=git-log><a href=#git-log class=header-anchor>#</a>
git log</h3><ul><li><code>git log</code>以缺省格式显示全部commit历史。更多⾃定义参数请参考后续部分。<code>q</code>退出，<code>空格</code>下一页，<code>h</code>查看帮助<ul><li><code>git log --stat</code>：显示详细的commit历史。</li><li><code>git log -&lt;limit></code>限制log的显示数量。例如：”git log -5”仅显示最新5条commit。</li><li><code>git log --oneline</code>每⾏显示⼀条commit，简化信息。与<code>--pretty=oneline</code>等效</li><li><code>git log --author= "&lt;pattern>"</code>按提交者名字搜索并显示commit。</li><li><code>git log --grep= "&lt;pattern>"</code>按指定内容搜索并显示commit。</li><li><code>git log &lt;since>..&lt;until></code>显示指定范围的commit。范围参数可以是commit ID、分⽀名称、HEAD或任意相对位置。</li><li><code>git log -- &lt;file></code>仅显示包含指定⽂件修改的commit。</li><li><code>git log --graph</code>使⽤&ndash;graph参数显示图形化的branch信息。</li></ul></li></ul><h3 id=git-diff><a href=#git-diff class=header-anchor>#</a>
git diff</h3><ul><li><code>git diff</code>⽐较⼯作区和暂存区的修改。</li><li><code>git diff HEAD</code>⽐较⼯作区和上⼀次commit后的修改。<ul><li>HEAD指向当前分支最新的commit版本库</li></ul></li><li><code>git diff --cached</code>⽐较暂存区和上⼀次commit后的修改。</li><li><code>git diff --stashed</code>查看暂存区与最新提交的差异，与上面一样</li><li><code>git diff &lt;commit1> &lt;commit2></code>查看两个提交之间的差异。</li><li><code>git diff &lt;filename></code>后面指定文件，只查看该文件的修改情况，没有参数查询全部</li><li>用<code>git diff HEAD -- readme.txt</code>命令可以查看版本库和工作区里面最新版本的区别</li></ul><h3 id=git-config><a href=#git-config class=header-anchor>#</a>
git config</h3><ul><li><p>作用：通过<code>git config</code>命令配置git的配置文件</p></li><li><p>git配置文件级别分为：</p><ol><li>仓库级别 <code>--local</code> 【优先级最高】。文件所在位置仓库下的<code>.git/config</code></li><li>当前用户级别 <code>--global</code>【优先级次之】<strong>一般配置它</strong>。文件所在位置用户家目录下的<code>.gitconfig</code></li><li>系统所有用户级别 <code>--system</code>【优先级最低】。文件所在位置git安装目录下的<code> ./etc/gitconfig</code></li></ol></li><li><p><code>-l</code>、<code>--list</code>查看配置。<strong>常用</strong></p><ol><li><code>git config -l</code>查看所有的配置信息，依次是系统级别、用户级别、仓库级别</li><li><code>git config --local -l</code> 查看仓库级别配置。必须要进入到具体的目录下。</li><li><code>git config --global -l</code> 查看当前用户配置</li><li><code>git config --system -l</code> 查看系统所有用户配置</li><li>可以与<code>--show-origin</code> 显示文件位置，<code>--show-scope</code>显示文件级别<strong>组合使用</strong></li></ol></li><li><p><code>-e</code>、<code>--edit</code>打开编辑器编辑<strong>指定级别</strong>的配置文件，没有指定默认仓库级别，会使用默认编辑器打开编辑。安装的时候设置的。</p></li><li><p>添加配置、修改配置：直接配置对应的配置参数就行。一般配置用户级别就行。省略了<code>--add</code>选项。没有指定级别，默认仓库基本。常用的添加配置命令:</p><ol><li><p>用户邮箱和用户名。安装git之后<strong>必设置的配置</strong></p><p><code>git config --global user.email "Your mail"</code></p><p><code>git config --global user.name "Your name"</code></p><p>如果我们没有配置，在提交代码时会有如下错误：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>xxx@DESKTOP-MD21325 MINGW64 /d/test/test <span class=o>(</span>master<span class=o>)</span>
</span></span><span class=line><span class=cl>$ git commit -m <span class=s2>&#34;feature: add readme&#34;</span>
</span></span><span class=line><span class=cl>Author identity unknown
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>*** Please tell me who you are.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Run
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  git config --global user.email <span class=s2>&#34;you@example.com&#34;</span>
</span></span><span class=line><span class=cl>  git config --global user.name <span class=s2>&#34;Your Name&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>to <span class=nb>set</span> your account<span class=s1>&#39;s default identity.
</span></span></span><span class=line><span class=cl><span class=s1>Omit --global to set the identity only in this repository.
</span></span></span><span class=line><span class=cl><span class=s1>
</span></span></span><span class=line><span class=cl><span class=s1>fatal: unable to auto-detect email address (got &#39;</span>xxx@DESKTOP-MD21325.<span class=o>(</span>none<span class=o>)</span><span class=err>&#39;</span><span class=o>)</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>设置自己的代理。网速慢<strong>必设置的配置</strong></p><p><code>git config --global http.proxy "http://proxy_ip:port"</code></p><p><code>git config --global https.proxy "https://proxy_ip:port"</code></p></li></ol></li><li><p><code>--unset</code>取消配置，注意要指定取消的配置级别。常用取消配置命令：</p><ol><li><p>取消代理配置</p><p><code>git config --global --unset http.proxy</code></p><p><code>git config --global --unset https.proxy</code></p></li></ol></li><li><p><code>--get</code>查看指定级别、指定配置项的配置，默认仓库级别。如：</p><ol><li><p>查看代理配置</p><p><code>git config --global --get http.proxy</code></p><p><code>git config --global --get https.proxy</code></p></li></ol></li><li><p><code>git config --global alias.&lt;alias-name> &lt;git-command></code>配置⼀个git命令的快捷⽅式。例如：配置”alias.glog log &ndash;graph &ndash;oneline”使”git glog”相当于”git log &ndash;graph &ndash;oneline”.</p></li><li><p><code>git config --global core.editor &lt;editor></code>配置⽂本编辑器，例如vi，在必要时⾃动打开此⽂本编辑器。安装的时候也可以指定默认编辑器。</p></li></ul><h3 id=git-submodule><a href=#git-submodule class=header-anchor>#</a>
git submodule</h3><ul><li><p><code>git submodule init</code>初始化子模块，将子模块的配置信息存储在父仓库中。</p><ul><li>通常执行之后再执行更新子模块使用，如克隆带有子模块的仓库，没有加<code>--recursive</code>，是不会克隆子模块的</li><li>初始化子模块之后，执行更新子模块就会根据配置信息下载子模块</li></ul></li><li><p><code>git submodule update</code>根据父仓库子模块的配置信息更新子模块，如果没有初始化子模块可以加参数<code>--init</code>，会下载与父项目绑定版本的子模块，若要更新加<code>--remote</code></p><ul><li><code>--init</code>初识化子模块</li><li><code>--recursive</code>会递归下载子模块的子模块</li><li><code>--remote</code>根据子模块远程仓库的配置信息更新子模块，会下载最新版本的子模块<ul><li>注意更新之后要提交更新的版本，否则当在执行更新命令没有加<code>--remote</code>时会退回与父仓库绑定的版本</li></ul></li></ul></li><li><p><code>git submodule add &lt;repository> &lt;path></code>添加子模块。其中，<code>&lt;repository></code>是子模块的远程仓库地址，<code>&lt;path></code>是子模块在主项目中的路径。</p><ul><li>子模块可以当正常仓库使用。创建时<code>&lt;path></code>路径不能存在文件，更克隆差不多。</li></ul></li></ul><h3 id=git-subtree><a href=#git-subtree class=header-anchor>#</a>
git subtree</h3><ul><li>作用：将一个仓库中的目录作为另一个仓库，可以指定分支</li><li>用途：搭建项目网站时，将项目网站资源推送到gh-pages分支上<ul><li><code>git subtree push --prefix=dist origin gh-pages</code>将目录添加到<code>gh-pages</code>分支上，<code>dist</code>为项目网站的目录</li></ul></li><li><code>git subtree push --prefix=&lt;prefix> &lt;repository> &lt;branch></code>将子目录的内容推送到远程仓库。它会将当前仓库中子目录的修改推送到指定的远程仓库和分支中。<ul><li>注意：以这种推送的方式添加的<code>subtree</code>不能执行<code>subtree pull</code>命令，只有通过<code>subtree add</code>添加的<strong>才能都执行</strong>，但能够执行<code>subtree push</code>命令</li></ul></li><li><code>git subtree pull --prefix=&lt;prefix> &lt;repository> &lt;branch></code>这个命令用于从远程仓库更新子目录的内容。它会拉取远程仓库的最新代码，并更新到当前仓库的子目录中。</li><li><code>git subtree add --prefix=&lt;prefix> &lt;repository> &lt;branch></code>这个命令用于将远程仓库的内容作为子目录添加到当前仓库中。<code>&lt;prefix></code>是子目录的名称，<code>&lt;repository></code>是远程仓库的地址，<code>&lt;branch></code>是要合并的分支。</li></ul><h3 id=git-rebase><a href=#git-rebase class=header-anchor>#</a>
git rebase</h3><ul><li><p>作用：rebase翻译成变基，顾名思义：改变基准点。可以使提交历史更加清晰和线性。</p></li><li><p>原因：通过合并两个不同的分支，提交历史会很错乱。而通过变基，会使得提交历史更加整洁和可读。</p></li><li><p>如何实现：就是修改创建分支的起点（基准点），到最新的提交。起点变了，提交历史就简化了。</p></li><li><p>命令：</p><ul><li><code>git rebase &lt;base></code>基于<code>&lt;base></code>对当前分⽀进⾏rebase<code>。&lt;base></code>可以是commit、分⽀名称、tag或相对于HEAD的commit。</li><li><code>git rebase -i &lt;base></code>以交互模式对当前分⽀做rebase。</li><li>rebase的过程中可能会出现冲突，解决冲突之后需要使用<code>git add</code>命令将解决冲突后的文件标记为已解决，然后，使用<code>git rebase --continue</code>命令继续rebase过程。Git会尝试继续应用剩余的提交。如果再次出现冲突，你需要重复上述解决冲突和继续rebase的步骤。</li><li>如果在rebase过程中出现了问题，或者你决定放弃rebase操作，你可以使用<code>git rebase --abort</code>命令来撤销整个rebase操作。</li></ul></li><li><p>git rebase的注意事项</p><ul><li><strong>避免对已经推送到远程仓库的提交执行rebase操作</strong>：这可能会导致提交历史的不一致，给其他协作者带来困扰。</li><li><strong>保持工作目录干净</strong>：在执行rebase之前，确保你的工作目录中没有未提交的更改。</li><li><strong>谨慎使用</strong>：由于rebase会改变提交历史，因此在与他人共享分支时要特别小心。通常，在公共分支上应该使用merge而不是rebase。</li></ul><p>通过掌握git rebase的用法和注意事项，你可以更有效地管理你的Git仓库，保持代码的清晰和整洁。</p></li></ul><p>​</p><hr><h2 id=扩展><a href=#%e6%89%a9%e5%b1%95 class=header-anchor>#</a>
扩展</h2><h3 id=gitignore文件><a href=#gitignore%e6%96%87%e4%bb%b6 class=header-anchor>#</a>
.gitignore文件</h3><p>Git提供了<code>.gitignore</code>文件，用于指定哪些文件或目录应该被Git忽略，不纳入版本控制系统中。<code>.gitignore</code>文件是一个文本文件，可以包含一些简单的规则，指定应该忽略哪些文件或目录。以下是一些.gitignore文件的示例规则：</p><ol><li><p>忽略所有以.tmp结尾的文件：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>*.tmp
</span></span></code></pre></td></tr></table></div></div></li><li><p>忽略所有的log文件：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>*.log
</span></span></code></pre></td></tr></table></div></div></li><li><p>忽略所有的.idea目录：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>.idea/
</span></span></code></pre></td></tr></table></div></div></li><li><p>忽略所有的build目录及其内容：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>build/
</span></span></code></pre></td></tr></table></div></div></li><li><p>忽略根目录下的config.json文件，但不忽略子目录中的config.json文件：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>/config.json
</span></span></code></pre></td></tr></table></div></div></li><li><p>忽略所有的node_modules目录及其内容：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>node_modules/
</span></span></code></pre></td></tr></table></div></div></li><li><p>忽略所有的DS_Store文件（Mac OS X系统中的文件）：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>.DS_Store
</span></span></code></pre></td></tr></table></div></div></li></ol><p>可以将这些规则写入.gitignore文件中，并将该文件添加到Git仓库中，以使Git忽略这些文件或目录。需要注意的是，即使某些文件或目录已经被添加到Git仓库中，也可以通过修改.gitignore文件来让Git忽略它们，但需要执行以下命令才能使.gitignore文件生效：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>git rm -r --cached .
</span></span><span class=line><span class=cl>git add .
</span></span><span class=line><span class=cl>git commit -m <span class=s2>&#34;update .gitignore&#34;</span>
</span></span><span class=line><span class=cl>git push
</span></span></code></pre></td></tr></table></div></div><p>这些命令会删除Git缓存中已经添加的文件，然后重新添加文件并提交更改，以使.gitignore文件生效。</p><p><strong>总结：</strong></p><p>当Git执行提交操作时，它会检查.gitignore文件中列出的文件和目录，并将它们从提交中排除。这是非常有用的，因为有些文件或目录不应该被纳入版本控制系统中，例如编译生成的文件、日志文件、临时文件等。</p><p>.gitignore文件的语法是基于模式匹配的，其中的特殊字符有：</p><ul><li>*：匹配任意字符，但不包括路径分隔符（/）。</li><li>?：匹配任意单个字符，但不包括路径分隔符（/）。</li><li>/：路径分隔符，用于指定目录。</li><li>!：用于否定模式，即不忽略指定的文件或目录。</li></ul><p>可以在.gitignore文件中使用通配符、路径、注释等语法，以更精确地指定需要忽略的文件或目录。同时，可以在仓库的根目录下创建一个.gitignore文件，也可以在子目录中创建独立的.gitignore文件。</p><hr><h3 id=git账户认证><a href=#git%e8%b4%a6%e6%88%b7%e8%ae%a4%e8%af%81 class=header-anchor>#</a>
git账户认证</h3><ul><li>当我们对远程仓库就行修改时，需要对应的权限，不是什么人都能够修改仓库。只有通过了git账户认证，才能修改对应的仓库。</li><li>常见git账户认证的方式：<ul><li><strong>SSH秘钥认证</strong><ul><li>这是Git中最常见的认证方式之一。用户首先生成一对公钥和私钥，然后将<strong>公钥</strong>添加到Git服务器上的用户帐户中。当用户尝试与Git服务器进行通信时，Git将使用私钥进行身份验证。这种方式相对安全，因为私钥是保存在用户本地机器上的，不会被传输到Git服务器。</li><li>秘钥生成命令：bash中运行<code>ssh-keygen</code>,一直回车就行，秘钥位置：主目录下的<code>.ssh</code>目录</li><li>公钥设置位置：github账户<code>Settings</code>-><code>SSH and GPG keys</code>-><code>New SSH key</code>将公钥复制粘贴保存就行。</li></ul></li><li><strong>HTTPS认证</strong><ul><li>在这种方式中，用户需要提供<strong>用户名</strong>和<strong>密码</strong>进行身份验证。用户需要在Git服务器上创建一个用户帐户，并将其关联到本地的Git仓库中。当用户执行需要身份验证的操作时，Git会要求输入用户名和密码。这种方式相对简单，适用于个人项目或小型团队。</li><li>设置位置：在使用Git进行操作时，如push或pull，系统会提示你输入用户名和密码进行身份验证。</li></ul></li><li><strong>访问令牌（Personal Access Token）认证</strong>：不常用<ul><li>访问令牌提供了一种更安全、更灵活的身份验证方式，因为它可以限制令牌的使用权限，并且可以随时撤销或重新生成令牌。</li><li>设置位置：github账户<code>Settings</code>-><code>Developer Settings</code>-><code>Personal access tokens</code>-><code>Tokens (classic)</code>-><code>Generate new token</code>，然后根据自己的需求设置token的权限。</li></ul></li></ul></li></ul><h4 id=ssh-keygen><a href=#ssh-keygen class=header-anchor>#</a>
ssh-keygen</h4><p><code>ssh-keygen</code>命令是一个用于生成、管理和转换SSH认证密钥的工具。它支持RSA和DSA两种认证密钥类型，并且提供了多种选项和参数，以满足不同的需求。</p><p>使用<code>ssh-keygen</code>命令，你可以生成新的密钥对，指定密钥的长度、类型以及保存的文件名。生成的私钥将保存在本地，而公钥则用于在SSH服务器上进行身份验证。</p><p>以下是一些常用的<code>ssh-keygen</code>命令选项：</p><ul><li><code>-t</code>：指定要创建的密钥类型，默认为RSA。</li><li><code>-b</code>：指定密钥长度（以位为单位）。对于RSA密钥，最小要求是768位，默认是2048位。对于DSA密钥，长度必须是1024位（根据FIPS 1862标准规定）。</li><li><code>-f</code>：指定用于保存密钥的文件名。如果不指定，将使用默认值<code>id_rsa</code>（对于私钥）和<code>id_rsa.pub</code>（对于公钥）。</li><li><code>-C</code>：提供一个新注释，通常用于标识密钥的用途或所有者。</li><li><code>-P</code> 和 <code>-N</code>：分别用于提供旧密码和新密码，以保护私钥文件。如果留空，则表示不需要密码。</li></ul><p>在生成密钥对后，你可以将公钥复制到需要访问的SSH服务器上，通常是将公钥内容追加到服务器的<code>~/.ssh/authorized_keys</code>文件中。这样，当你使用SSH客户端连接到服务器时，客户端将使用私钥进行身份验证，如果验证成功，你将能够无需输入密码即可登录到服务器。</p><p>请注意，私钥的安全性至关重要。私钥应该妥善保管，并且不应该与其他人共享。同时，定期更换密钥对也是保持安全性的好习惯。</p><p>除了生成和管理密钥对，<code>ssh-keygen</code>还提供了其他功能，如转换密钥格式、读取密钥文件等。你可以通过查看<code>ssh-keygen</code>的帮助文档或手册页（通过运行<code>man ssh-keygen</code>命令）来获取更详细的信息和用法示例。</p></section><footer class=article-footer><section class=article-tags><a href=/tags/github/>Github</a></section><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section><section class=article-lastmod><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>最后更新于 Apr 26, 2024 17:41 +0800</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>相关文章</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/p/go-modules%E8%AF%A6%E8%A7%A3/><div class=article-details><h2 class=article-title>Go modules详解</h2></div></a></article><article class=has-image><a href=/p/%E5%9F%BA%E4%BA%8Ehugo%E5%92%8Cgh-pages%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99/><div class=article-image><img src=/p/%E5%9F%BA%E4%BA%8Ehugo%E5%92%8Cgh-pages%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99/hugo.46f61e8ea6a2df8fc5bf1d24a17c44a6_hu45a5e3ad5e058da6a00650ed8fd40bea_15530_250x150_fill_q75_box_smart1.jpg width=250 height=150 loading=lazy alt="Featured image of post 基于Hugo和gh-pages快速搭建静态网站" data-hash="md5-RvYejqai34/Fvx0koXxEpg=="></div><div class=article-details><h2 class=article-title>基于Hugo和gh-pages快速搭建静态网站</h2></div></a></article></div></div></aside><script src=//unpkg.com/@waline/client@v2/dist/waline.js></script><link href=//unpkg.com/@waline/client@v2/dist/waline.css rel=stylesheet><div id=waline class=waline-container></div><style>.waline-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding);--waline-font-size:var(--article-font-size)}.waline-container .wl-count{color:var(--card-text-color-main)}</style><script>Waline.init({copyright:!1,dark:'html[data-scheme="dark"]',el:"#waline",emoji:["https://unpkg.com/@waline/emojis@1.0.1/weibo"],lang:"zh-cn",locale:{admin:"👻Hi!",placeholder:"🎉留下你的脚印..."},pageview:!0,requiredMeta:["name","email"],serverURL:"https://waline.trojan123.top/"})</script><footer class=site-footer><section class=copyright>&copy;
2020 -
2024 Arlettebrook</section><section class=powerby>使用 <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> 构建<br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.25.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>