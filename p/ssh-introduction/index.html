<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="SSH相关知识详细介绍。"><title>SSH Introduction</title>
<link rel=canonical href=https://arlettebrook.github.io/p/ssh-introduction/><link rel=stylesheet href=/scss/style.min.505938c6c688784167a9f82747dd1fc8c9c6c9e2137f29599d0e43e8740344b5.css><meta property='og:title' content="SSH Introduction"><meta property='og:description' content="SSH相关知识详细介绍。"><meta property='og:url' content='https://arlettebrook.github.io/p/ssh-introduction/'><meta property='og:site_name' content="Arlettebrook's blog"><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='SSH'><meta property='article:published_time' content='2024-08-03T23:59:44+08:00'><meta property='article:modified_time' content='2024-08-03T23:59:44+08:00'><meta name=twitter:site content="@arlettebrook"><meta name=twitter:creator content="@arlettebrook"><meta name=twitter:title content="SSH Introduction"><meta name=twitter:description content="SSH相关知识详细介绍。"><link rel="shortcut icon" href=/img/favicon.ico><script async src="https://www.googletagmanager.com/gtag/js?id=G-9MKLLVPEER"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-9MKLLVPEER")}</script></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><div id=article-toolbar style=position:sticky;top:5px;z-index:1000><a href=/ class=back-home><svg class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg>
<span>返回</span></a></div><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#ssh-介绍>SSH 介绍</a><ol><li><a href=#ssh-是什么>SSH 是什么</a></li><li><a href=#历史>历史</a></li><li><a href=#ssh-架构>SSH 架构</a></li></ol></li><li><a href=#ssh-客户端>SSH 客户端</a><ol><li><a href=#简介>简介</a></li><li><a href=#基本用法>基本用法</a></li><li><a href=#连接流程>连接流程</a></li><li><a href=#加密参数>加密参数</a></li><li><a href=#服务器密钥变更>服务器密钥变更</a></li><li><a href=#ssh-命令行配置项>ssh 命令行配置项</a></li><li><a href=#执行远程命令>执行远程命令</a></li><li><a href=#客户端配置文件>客户端配置文件</a><ol><li><a href=#位置>位置</a></li><li><a href=#主机设置>主机设置</a></li><li><a href=#配置命令的语法>配置命令的语法</a></li><li><a href=#主要配置命令>主要配置命令</a></li></ol></li></ol></li><li><a href=#ssh-密钥登录>SSH 密钥登录</a><ol><li><a href=#密钥是什么>密钥是什么</a></li><li><a href=#密钥登录的过程>密钥登录的过程</a></li><li><a href=#ssh-keygen命令生成密钥><code>ssh-keygen</code>命令：生成密钥</a><ol><li><a href=#基本用法-1>基本用法</a></li><li><a href=#配置项>配置项</a></li></ol></li><li><a href=#手动上传公钥>手动上传公钥</a></li><li><a href=#ssh-copy-id-命令自动上传公钥>ssh-copy-id 命令：自动上传公钥</a></li><li><a href=#ssh-agent-命令ssh-add-命令>ssh-agent 命令，ssh-add 命令</a><ol><li><a href=#基本用法-2>基本用法</a></li></ol></li><li><a href=#ssh-add命令><code>ssh-add</code>命令</a></li><li><a href=#关闭密码登录>关闭密码登录</a></li></ol></li><li><a href=#ssh-证书登录>SSH 证书登录</a><ol><li><a href=#非证书登录的缺点>非证书登录的缺点</a></li><li><a href=#证书登录是什么>证书登录是什么？</a></li><li><a href=#证书登录的流程>证书登录的流程</a></li><li><a href=#生成-ca-的密钥>生成 CA 的密钥</a></li><li><a href=#ca-签发服务器证书>CA 签发服务器证书</a></li><li><a href=#ca-签发用户证书>CA 签发用户证书</a></li><li><a href=#服务器安装证书>服务器安装证书</a></li><li><a href=#服务器安装-ca-公钥>服务器安装 CA 公钥</a></li><li><a href=#客户端安装证书>客户端安装证书</a></li><li><a href=#客户端安装-ca-公钥>客户端安装 CA 公钥</a></li><li><a href=#废除证书>废除证书</a></li><li><a href=#参考链接>参考链接</a></li></ol></li><li><a href=#scp-命令>scp 命令</a><ol><li><a href=#简介-1>简介</a></li><li><a href=#基本语法>基本语法</a></li><li><a href=#用法示例>用法示例</a></li><li><a href=#配置项-1>配置项</a></li></ol></li><li><a href=#sftp-命令>sftp 命令</a></li><li><a href=#rsync-命令>rsync 命令</a><ol><li><a href=#简介-2>简介</a></li><li><a href=#安装>安装</a></li><li><a href=#基本用法-3>基本用法</a></li><li><a href=#排除文件>排除文件</a></li><li><a href=#远程同步>远程同步</a><ol><li><a href=#ssh-协议>SSH 协议</a></li><li><a href=#rsync-协议>rsync 协议</a></li></ol></li><li><a href=#增量备份>增量备份</a></li><li><a href=#配置项-2>配置项</a></li><li><a href=#参考链接-1>参考链接</a></li></ol></li><li><a href=#ssh-服务器>SSH 服务器</a><ol><li><a href=#简介-3>简介</a></li><li><a href=#sshd-配置文件>sshd 配置文件</a></li><li><a href=#sshd-密钥>sshd 密钥</a></li><li><a href=#sshd-配置项>sshd 配置项</a></li><li><a href=#sshd-的命令行配置项>sshd 的命令行配置项</a></li></ol></li><li><a href=#ssh-日志>SSH 日志</a><ol><li><a href=#journalctl-命令>journalctl 命令</a></li><li><a href=#其他命令>其他命令</a></li><li><a href=#日志设置>日志设置</a></li></ol></li><li><a href=#fail2ban-教程>Fail2Ban 教程</a><ol><li><a href=#简介-4>简介</a></li><li><a href=#fail2ban-client>fail2ban-client</a></li><li><a href=#配置>配置</a><ol><li><a href=#主配置文件>主配置文件</a></li><li><a href=#封禁配置>封禁配置</a></li><li><a href=#配置项-3>配置项</a></li></ol></li><li><a href=#ssh-配置>ssh 配置</a></li></ol></li><li><a href=#ssh-端口转发->SSH 端口转发: ?</a><ol><li><a href=#简介-5>简介</a></li><li><a href=#动态转发>动态转发</a></li><li><a href=#本地转发>本地转发</a></li><li><a href=#远程转发>远程转发</a></li><li><a href=#实例>实例</a><ol><li><a href=#简易-vpn>简易 VPN</a></li><li><a href=#两级跳板>两级跳板</a></li></ol></li><li><a href=#参考链接-2>参考链接</a></li></ol></li><li><a href=#参考>参考</a></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/linux/ style=background-color:#4636fc;color:#fff>Linux
</a><a href=/categories/%E6%8A%80%E6%9C%AF/ style=background-color:#c73659;color:#fff>技术</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/ssh-introduction/>SSH Introduction</a></h2><h3 class=article-subtitle>SSH相关知识详细介绍。</h3></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Aug 03, 2024</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>阅读时长: 70 分钟</time></div></footer></div></header><section class=article-content><hr><h2 id=ssh-介绍>SSH 介绍</h2><p>SSH（Secure Shell 的缩写）是一种网络协议，用于加密两台计算机之间的通信，并且支持各种身份验证机制。</p><p>实际中，它主要用于保证远程登录和远程通信的安全，任何网络服务都可以用这个协议来加密。</p><h3 id=ssh-是什么>SSH 是什么</h3><p>历史上，网络主机之间的通信是不加密的，属于明文通信。这使得通信很不安全，一个典型的例子就是服务器登录。登录远程服务器的时候，需要将用户输入的密码传给服务器，如果这个过程是明文通信，就意味着传递过程中，线路经过的中间计算机都能看到密码，这是很可怕的。</p><p>SSH 就是为了解决这个问题而诞生的，它能够加密计算机之间的通信，保证不被窃听或篡改。它还能对操作者进行认证（authentication）和授权（authorization）。明文的网络协议可以套用在它里面，从而实现加密。</p><h3 id=历史>历史</h3><p>1995年，芬兰赫尔辛基工业大学的研究员 Tatu Ylönen 设计了 SSH 协议的第一个版本（现称为 SSH 1），同时写出了第一个实现（称为 SSH1）。</p><p>当时，他所在的大学网络一直发生密码嗅探攻击，他不得不为服务器设计一个更安全的登录方式。写完以后，他就把这个工具公开了，允许其他人免费使用。</p><p>SSH 可以替换 rlogin、TELNET、FTP 和 rsh 这些不安全的协议，所以大受欢迎，用户快速增长，1995年底已经发展到五十个国家的20,000个用户。SSH 1 协议也变成 IETF 的标准文档。</p><p>1995年12月，由于客服需求越来越大，Tatu Ylönen 就成立了一家公司 SCS，专门销售和开发 SSH。这个软件的后续版本，逐渐从免费软件变成了专有的商业软件。</p><p>SSH 1 协议存在一些安全漏洞，所以1996年又提出了 SSH 2 协议（或者称为 SSH 2.0）。这个协议与1.0版不兼容，在1997年进行了标准化，1998年推出了软件实现 SSH2。但是，官方的 SSH2 软件是一个专有软件，不能免费使用，而且 SSH1 的有些功能也没有提供。</p><p>1999年，OpenBSD 的开发人员决定写一个 SSH 2 协议的开源实现，这就是 OpenSSH 项目。该项目最初是基于 SSH 1.2.12 版本，那是当时 SSH1 最后一个开源版本。但是，OpenSSH 很快就完全摆脱了原始的官方代码，在许多开发者的参与下，按照自己的路线发展。OpenSSH 随 OpenBSD 2.6 版本一起提供，以后又移植到其他操作系统，成为最流行的 SSH 实现。目前，Linux 的所有发行版几乎都自带 OpenSSH。</p><p>现在，SSH-2 有多种实现，既有免费的，也有收费的。本书的内容主要是针对 OpenSSH。</p><h3 id=ssh-架构>SSH 架构</h3><p>SSH 的软件架构是服务器-客户端模式（Server - Client）。在这个架构中，SSH 软件分成两个部分：向服务器发出请求的部分，称为客户端（client），OpenSSH 的实现为 <strong>ssh</strong>；接收客户端发出的请求的部分，称为服务器（server），OpenSSH 的实现为 <strong>sshd</strong>。</p><p>本教程约定，大写的 SSH 表示协议，小写的 ssh 表示客户端软件。</p><p>另外，OpenSSH 还提供一些辅助工具软件（比如 ssh-keygen 、ssh-agent）和专门的客户端工具（比如 scp 和 sftp），这个教程也会予以介绍。</p><hr><h2 id=ssh-客户端>SSH 客户端</h2><h3 id=简介>简介</h3><p>OpenSSH 的<strong>客户端</strong>是<strong>二进制程序 ssh</strong>。它在 Linux/Unix 系统的位置是<code>/usr/local/bin/ssh</code>。</p><ul><li><p>在Linux上安装SSH客户端:</p><p>在大多数Linux发行版中，OpenSSH客户端通常<strong>默认已安装</strong>。如果没有安装，可以通过包管理器来安装。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1># Ubuntu 和 Debian</span>
</span></span><span class=line><span class=cl>$ sudo apt install openssh-client
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># CentOS 和 RHEL</span>
</span></span><span class=line><span class=cl>$ sudo yum install openssh-clients
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Fedora</span>
</span></span><span class=line><span class=cl>$ sudo dnf install openssh-clients
</span></span></code></pre></td></tr></table></div></div></li><li><p>在macOS上安装SSH客户端:</p><p>macOS预装了OpenSSH客户端，因此不需要额外安装。可以直接在终端使用<code>ssh</code>命令。</p></li><li><p>在Windows上安装SSH客户端:</p><ul><li><p>从Windows 10版本1709开始，系统已经内置了OpenSSH客户端。可以通过以下步骤启用：</p><ol><li><strong>打开设置</strong> > <strong>应用</strong> > <strong>可选功能</strong>(没有：搜索添加可选可能）。</li><li>向下滚动并找到“OpenSSH Client”，如果未安装，点击<strong>添加功能</strong>按钮。</li><li>在列表中找到“OpenSSH Client”，然后点击<strong>安装</strong>。</li></ol><p>之后，可以在命令提示符（cmd）或PowerShell中使用<code>ssh</code>命令。</p></li></ul></li><li><p>或者使用封装了ssh客户端的工具：</p><ul><li>如Termius、FinalShell、WindTerm等。</li></ul></li></ul><p>安装以后，可以使用<code>-V</code>参数输出版本号，查看一下是否安装成功。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ ssh -V
</span></span></code></pre></td></tr></table></div></div><h3 id=基本用法>基本用法</h3><p>ssh 最常见的用途就是<strong>登录服务器</strong>，这要求服务器安装并<strong>正在运行 SSH 服务器软件</strong>(sshd)。</p><p>ssh 登录服务器的命令如下:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ ssh hostname
</span></span></code></pre></td></tr></table></div></div><p>上面命令中，<code>hostname</code>是主机名，它可以是域名，也可能是 IP 地址或局域网内部的主机名。不指定用户名的情况下，将使用客户端的当前用户名，作为远程服务器的登录用户名。如果要指定用户名，可以采用下面的语法:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ ssh username@hostname
</span></span></code></pre></td></tr></table></div></div><p>上面的命令中，用户名和主机名写在一起了，之间使用<code>@</code>分隔。</p><p>用户名也可以使用<code>ssh</code>的<code>-l</code>参数指定，这样的话，用户名和主机名就不用写在一起了:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ ssh -l username hostname
</span></span></code></pre></td></tr></table></div></div><p>ssh 默认连接服务器的22端口，<code>-p</code>参数可以指定其他端口:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ ssh -p <span class=m>8821</span> foo.com
</span></span></code></pre></td></tr></table></div></div><p>上面命令连接服务器<code>foo.com</code>的8821端口，用户名为当前客户端主机登录的用户名。</p><h3 id=连接流程>连接流程</h3><p>ssh 连接远程服务器后，首先有一个<strong>验证过程</strong>，<strong>验证远程服务器是否为陌生地址</strong>。</p><p>如果是第一次连接某一台服务器，命令行会显示一段文字，表示不认识这台机器，提醒用户确认是否需要连接。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>The authenticity of host <span class=s1>&#39;foo.com (192.168.121.111)&#39;</span> can<span class=err>&#39;</span>t be established.
</span></span><span class=line><span class=cl>ECDSA key fingerprint is SHA256:Vybt22mVXuNuB5unE++yowF7lgA/9/2bLSiO3qmYWBY.
</span></span><span class=line><span class=cl>Are you sure you want to <span class=k>continue</span> connecting <span class=o>(</span>yes/no<span class=o>)</span>?
</span></span></code></pre></td></tr></table></div></div><p>上面这段文字告诉用户，<code>foo.com</code>这台服务器的指纹是陌生的，让用户选择是否要继续连接（输入 yes 或 no）。</p><p>所谓“服务器指纹”，指的是 SSH 服务器公钥的哈希值。每台 SSH 服务器都有唯一一对密钥，用于跟客户端通信，其中公钥的哈希值就可以用来识别服务器。</p><p>在上面这段文字后面，输入<code>yes</code>，就可以将当前服务器的指纹也储存在本机<code>~/.ssh/known_hosts</code>文件中，并显示下面的提示。以后再连接的时候，就不会再出现警告了。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>Warning: Permanently added <span class=s1>&#39;foo.com (192.168.121.111)&#39;</span> <span class=o>(</span>RSA<span class=o>)</span> to the list of known hosts
</span></span></code></pre></td></tr></table></div></div><p>然后，客户端就会跟服务器建立连接。接着，ssh 就会要求用户输入所要登录账户的密码。用户输入并验证密码正确以后，就能登录远程服务器的 Shell 了。</p><p>下面的命令可以查看某个公钥的指纹。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ ssh-keygen -l -f /etc/ssh/ssh_host_ecdsa_key.pub
</span></span><span class=line><span class=cl><span class=m>256</span> da:24:43:0b:2e:c1:3f:a1:84:13:92:01:52:b4:84:ff   <span class=o>(</span>ECDSA<span class=o>)</span>
</span></span></code></pre></td></tr></table></div></div><p>上面的例子中，<code>ssh-keygen -l -f</code>命令会输出公钥<code>/etc/ssh/ssh_host_ecdsa_key.pub</code>的指纹。</p><p>ssh 会将本机连接过的所有服务器公钥的指纹，都储存在本机的<code>~/.ssh/known_hosts</code>文件中。每次连接服务器时，通过该文件判断是否为陌生主机（陌生公钥）。</p><h3 id=加密参数>加密参数</h3><p>SSH 连接的握手阶段，客户端必须跟服务端约定加密参数集（cipher suite）。</p><p>加密参数集包含了若干不同的加密参数，它们之间使用下划线连接在一起，下面是一个例子：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>TLS_RSA_WITH_AES_128_CBC_SHA
</span></span></code></pre></td></tr></table></div></div><p>它的含义如下：</p><ul><li>TLS：加密通信协议</li><li>RSA：密钥交换算法</li><li>AES：加密算法</li><li>128：加密算法的强度</li><li>CBC：加密算法的模式</li><li>SHA：数字签名的 Hash 函数</li></ul><p>下面是一个例子，客户端向服务器发出的握手信息：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=line><span class=cl><span class=err>Handshake protocol: ClientHello
</span></span></span><span class=line><span class=cl><span class=err>    Version: TLS 1.2
</span></span></span><span class=line><span class=cl><span class=err>    Random
</span></span></span><span class=line><span class=cl><span class=err>        Client time: May 22, 2030 02:43:46 GMT
</span></span></span><span class=line><span class=cl><span class=err>        Random bytes: b76b0e61829557eb4c611adfd2d36eb232dc1332fe29802e321ee871
</span></span></span><span class=line><span class=cl><span class=err>    Session ID: (empty)
</span></span></span><span class=line><span class=cl><span class=err>    Cipher Suites
</span></span></span><span class=line><span class=cl><span class=err>        Suite: TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256”
</span></span></span><span class=line><span class=cl><span class=err>        Suite: TLS_DHE_RSA_WITH_AES_128_GCM_SHA256
</span></span></span><span class=line><span class=cl><span class=err>        Suite: TLS_RSA_WITH_AES_128_GCM_SHA256
</span></span></span><span class=line><span class=cl><span class=err>        Suite: TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA
</span></span></span><span class=line><span class=cl><span class=err>        Suite: TLS_DHE_RSA_WITH_AES_128_CBC_SHA
</span></span></span><span class=line><span class=cl><span class=err>        Suite: TLS_RSA_WITH_AES_128_CBC_SHA
</span></span></span><span class=line><span class=cl><span class=err>        Suite: TLS_RSA_WITH_3DES_EDE_CBC_SHA
</span></span></span><span class=line><span class=cl><span class=err>        Suite: TLS_RSA_WITH_RC4_128_SHA
</span></span></span><span class=line><span class=cl><span class=err>    Compression methods
</span></span></span><span class=line><span class=cl><span class=err>        Method: null
</span></span></span><span class=line><span class=cl><span class=err>    Extensions
</span></span></span><span class=line><span class=cl><span class=err>        Extension: server_name
</span></span></span><span class=line><span class=cl><span class=err>            Hostname: www.feistyduck.com
</span></span></span><span class=line><span class=cl><span class=err>        Extension: renegotiation_info
</span></span></span><span class=line><span class=cl><span class=err>        Extension: elliptic_curves
</span></span></span><span class=line><span class=cl><span class=err>            Named curve: secp256r1
</span></span></span><span class=line><span class=cl><span class=err>            Named curve: secp384r1
</span></span></span><span class=line><span class=cl><span class=err>        Extension: signature_algorithms
</span></span></span><span class=line><span class=cl><span class=err>            Algorithm: sha1/rsa
</span></span></span><span class=line><span class=cl><span class=err>            Algorithm: sha256/rsa
</span></span></span><span class=line><span class=cl><span class=err>            Algorithm: sha1/ecdsa
</span></span></span><span class=line><span class=cl><span class=err>            Algorithm: sha256/ecdsa”
</span></span></span></code></pre></td></tr></table></div></div><p>上面的握手信息（ClientHello）之中，<code>Cipher Suites</code>字段就是客户端列出可选的加密参数集，服务器在其中选择一个自己支持的<strong>参数集</strong>。</p><p>服务器选择完毕之后，向客户端发出回应：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=line><span class=cl><span class=err>Handshake protocol: ServerHello
</span></span></span><span class=line><span class=cl><span class=err>    Version: TLS 1.2
</span></span></span><span class=line><span class=cl><span class=err>    Random
</span></span></span><span class=line><span class=cl><span class=err>        Server time: Mar 10, 2059 02:35:57 GMT”
</span></span></span><span class=line><span class=cl><span class=err>        Random bytes: 8469b09b480c1978182ce1b59290487609f41132312ca22aacaf5012
</span></span></span><span class=line><span class=cl><span class=err>    Session ID: 4cae75c91cf5adf55f93c9fb5dd36d19903b1182029af3d527b7a42ef1c32c80
</span></span></span><span class=line><span class=cl><span class=err>    Cipher Suite: TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
</span></span></span><span class=line><span class=cl><span class=err>    Compression method: null
</span></span></span><span class=line><span class=cl><span class=err>    Extensions
</span></span></span><span class=line><span class=cl><span class=err>        Extension: server_name
</span></span></span><span class=line><span class=cl><span class=err>        Extension: renegotiation_info”
</span></span></span></code></pre></td></tr></table></div></div><p>上面的回应信息（ServerHello）中，<code>Cipher Suite</code>字段就是服务器最终选定的加密参数。</p><h3 id=服务器密钥变更>服务器密钥变更</h3><p>服务器指纹可以防止有人恶意冒充远程主机。如果服务器的密钥发生变更（比如重装了 SSH 服务器），客户端再次连接时，就会发生公钥指纹不吻合的情况。这时，客户端就会中断连接，并显示一段警告信息。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
</span></span><span class=line><span class=cl>@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
</span></span><span class=line><span class=cl>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
</span></span><span class=line><span class=cl>IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
</span></span><span class=line><span class=cl>Someone could be eavesdropping on you right now <span class=o>(</span>man-in-the-middle attack<span class=o>)</span>!
</span></span><span class=line><span class=cl>It is also possible that the RSA host key has just been changed.
</span></span><span class=line><span class=cl>The fingerprint <span class=k>for</span> the RSA key sent by the remote host is
</span></span><span class=line><span class=cl>77:a5:69:81:9b:eb:40:76:7b:13:04:a9:6c:f4:9c:5d.
</span></span><span class=line><span class=cl>Please contact your system administrator.
</span></span><span class=line><span class=cl>Add correct host key in /home/me/.ssh/known_hosts to get rid of this message.
</span></span><span class=line><span class=cl>Offending key in /home/me/.ssh/known_hosts:36
</span></span></code></pre></td></tr></table></div></div><p>上面这段文字的意思是，该主机的公钥指纹跟<code>~/.ssh/known_hosts</code>文件储存的不一样，必须处理以后才能连接。这时，你需要确认是什么原因，使得公钥指纹发生变更，到底是恶意劫持，还是管理员变更了 SSH 服务器公钥。</p><p>如果新的公钥确认可以信任，需要继续执行连接，你可以执行下面的命令，将原来的公钥指纹从<code>~/.ssh/known_hosts</code>文件删除。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ ssh-keygen -R hostname
</span></span></code></pre></td></tr></table></div></div><p>上面命令中，<code>hostname</code>是发生公钥变更的主机名。</p><p>除了使用上面的命令，你也可以手工修改<code>known_hosts</code>文件，将公钥指纹删除。</p><p>删除了原来的公钥指纹以后，重新执行 ssh 命令连接远程服务器，将新的指纹加入<code>known_hosts</code>文件，就可以顺利连接了。</p><h3 id=ssh-命令行配置项>ssh 命令行配置项</h3><p><strong>-c</strong></p><p><code>-c</code>参数指定加密算法。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ ssh -c blowfish,3des server.example.com
</span></span><span class=line><span class=cl><span class=c1># 或者</span>
</span></span><span class=line><span class=cl>$ ssh -c blowfish -c 3des server.example.com
</span></span></code></pre></td></tr></table></div></div><p>上面命令指定使用加密算法<code>blowfish</code>或<code>3des</code>。</p><p><strong>-C</strong></p><p><code>-C</code>参数表示压缩数据传输。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ ssh -C server.example.com
</span></span></code></pre></td></tr></table></div></div><p><strong>-D</strong></p><p><code>-D</code>参数指定本机的 Socks 监听端口，该端口收到的请求，都将转发到远程的 SSH 主机，又称动态端口转发，详见《端口转发》一章。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ ssh -D <span class=m>1080</span> server
</span></span></code></pre></td></tr></table></div></div><p>上面命令将本机 1080 端口收到的请求，都转发到服务器<code>server</code>。</p><p><strong>-f</strong></p><p><code>-f</code>参数表示 SSH 连接在后台运行。</p><p><strong>-F</strong></p><p><code>-F</code>参数指定配置文件。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ ssh -F /usr/local/ssh/other_config
</span></span></code></pre></td></tr></table></div></div><p>上面命令指定使用配置文件<code>other_config</code>。</p><p><strong>-i</strong></p><p><code>-i</code>参数用于指定私钥，意为“identity_file”，默认值为<code>~/.ssh/id_dsa</code>（DSA 算法）和<code>~/.ssh/id_rsa</code>（RSA 算法）。注意，对应的公钥必须存放到服务器，详见《密钥登录》一章。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ ssh -i my-key server.example.com
</span></span></code></pre></td></tr></table></div></div><p><strong>-l</strong></p><p><code>-l</code>参数指定远程登录的账户名。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ ssh -l sally server.example.com
</span></span><span class=line><span class=cl><span class=c1># 等同于</span>
</span></span><span class=line><span class=cl>$ ssh sally@server.example.com
</span></span></code></pre></td></tr></table></div></div><p><strong>-L</strong></p><p><code>-L</code>参数设置本地端口转发，详见《端口转发》一章。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ ssh  -L 9999:targetServer:80 user@remoteserver
</span></span></code></pre></td></tr></table></div></div><p>上面命令中，所有发向本地<code>9999</code>端口的请求，都会经过<code>remoteserver</code>发往 targetServer 的 80 端口，这就相当于直接连上了 targetServer 的 80 端口。</p><p><strong>-m</strong></p><p><code>-m</code>参数指定校验数据完整性的算法（message authentication code，简称 MAC）。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ ssh -m hmac-sha1,hmac-md5 server.example.com
</span></span></code></pre></td></tr></table></div></div><p>上面命令指定数据校验算法为<code>hmac-sha1</code>或<code>hmac-md5</code>。</p><p><strong>-N</strong></p><p><code>-N</code>参数用于端口转发，表示建立的 SSH 只用于端口转发，不能执行远程命令，这样可以提供安全性，详见《端口转发》一章。</p><p><strong>-o</strong></p><p><code>-o</code>参数用来指定一个配置命令。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ ssh -o <span class=s2>&#34;Keyword Value&#34;</span>
</span></span></code></pre></td></tr></table></div></div><p>举例来说，配置文件里面有如下内容。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>User sally
</span></span><span class=line><span class=cl>Port <span class=m>220</span>
</span></span></code></pre></td></tr></table></div></div><p>通过<code>-o</code>参数，可以把上面两个配置命令从命令行传入。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ ssh -o <span class=s2>&#34;User sally&#34;</span> -o <span class=s2>&#34;Port 220&#34;</span> server.example.com
</span></span></code></pre></td></tr></table></div></div><p>使用等号时，配置命令可以不用写在引号里面，但是等号前后不能有空格。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ ssh -o <span class=nv>User</span><span class=o>=</span>sally -o <span class=nv>Port</span><span class=o>=</span><span class=m>220</span> server.example.com
</span></span></code></pre></td></tr></table></div></div><p><strong>-p</strong></p><p><code>-p</code>参数指定 SSH 客户端连接的服务器端口。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ ssh -p <span class=m>2035</span> server.example.com
</span></span></code></pre></td></tr></table></div></div><p>上面命令连接服务器的2035端口。</p><p><strong>-q</strong></p><p><code>-q</code>参数表示安静模式（quiet），不向用户输出任何警告信息。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ ssh –q foo.com
</span></span><span class=line><span class=cl>root’s password:
</span></span></code></pre></td></tr></table></div></div><p>上面命令使用<code>-q</code>参数，只输出要求用户输入密码的提示。</p><p><strong>-R</strong></p><p><code>-R</code>参数指定远程端口转发，详见《端口转发》一章。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ ssh -R 9999:targetServer:902 <span class=nb>local</span>
</span></span></code></pre></td></tr></table></div></div><p>上面命令需在跳板服务器执行，指定本地计算机<code>local</code>监听自己的 9999 端口，所有发向这个端口的请求，都会转向 targetServer 的 902 端口。</p><p><strong>-t</strong></p><p><code>-t</code>参数在 ssh 直接运行远端命令时，提供一个互动式 Shell。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ ssh -t server.example.com emacs
</span></span></code></pre></td></tr></table></div></div><p><strong>-v</strong></p><p><code>-v</code>参数显示详细信息。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ ssh -v server.example.com
</span></span></code></pre></td></tr></table></div></div><p><code>-v</code>可以重复多次，表示信息的详细程度，比如<code>-vv</code>和<code>-vvv</code>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ ssh -vvv server.example.com
</span></span><span class=line><span class=cl><span class=c1># 或者</span>
</span></span><span class=line><span class=cl>$ ssh -v -v -v server.example.com
</span></span></code></pre></td></tr></table></div></div><p>上面命令会输出最详细的连接信息。</p><p><strong>-V</strong></p><p><code>-V</code>参数输出 ssh 客户端的版本。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ ssh –V
</span></span><span class=line><span class=cl>ssh: SSH Secure Shell 3.2.3 <span class=o>(</span>non-commercial version<span class=o>)</span> on i686-pc-linux-gnu
</span></span></code></pre></td></tr></table></div></div><p>上面命令输出本机 ssh 客户端版本是<code>SSH Secure Shell 3.2.3</code>。</p><p><strong>-X</strong></p><p><code>-X</code>参数表示打开 X 窗口转发。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ ssh -X server.example.com
</span></span></code></pre></td></tr></table></div></div><p><strong>-1，-2</strong></p><p><code>-1</code>参数指定使用 SSH 1 协议。</p><p><code>-2</code>参数指定使用 SSH 2 协议。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ ssh -2 server.example.com
</span></span></code></pre></td></tr></table></div></div><p><strong>-4，-6</strong></p><p><code>-4</code>指定使用 IPv4 协议，这是默认值。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ ssh -4 server.example.com
</span></span></code></pre></td></tr></table></div></div><p><code>-6</code>指定使用 IPv6 协议。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ ssh -6 server.example.com
</span></span></code></pre></td></tr></table></div></div><h3 id=执行远程命令>执行远程命令</h3><p>SSH 登录成功后，用户就进入了远程主机的命令行环境，所看到的提示符，就是远程主机的提示符。这时，你就可以输入想要在远程主机执行的命令。</p><p>另一种<strong>执行远程命令的方法</strong>，是将命令直接写在<code>ssh</code>命令的后面。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ ssh username@hostname <span class=nb>command</span>
</span></span></code></pre></td></tr></table></div></div><p>上面的命令会使得 SSH 在<strong>登录成功后</strong>，立刻在远程主机上执行命令<code>command</code>。命令执行完成之后会自动退出连接。</p><p><strong>多行命令用引号或双引号括起来</strong>。</p><p>下面是一个例子。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ ssh foo@server.example.com cat /etc/hosts
</span></span></code></pre></td></tr></table></div></div><p>上面的命令会在登录成功后，立即远程执行命令<code>cat /etc/hosts</code>。</p><p>采用这种语法执行命令时，ssh 客户端不会提供互动式的 Shell 环境，而是直接将远程命令的执行结果输出在命令行。但是，有些命令需要互动式的 Shell 环境，这时就要使用<code>-t</code>参数。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1># 报错</span>
</span></span><span class=line><span class=cl>$ ssh remote.server.com emacs
</span></span><span class=line><span class=cl>emacs: standard input is not a tty
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 不报错</span>
</span></span><span class=line><span class=cl>$ ssh -t server.example.com emacs
</span></span></code></pre></td></tr></table></div></div><p>上面代码中，<code>emacs</code>命令需要一个互动式 Shell，所以报错。只有加上<code>-t</code>参数，ssh 才会分配一个互动式 Shell。</p><p>不是交互式命令，使用<code>-t</code>参数之后，<strong>也会立即退出连接</strong>。交互命令需要主动退出。</p><h3 id=客户端配置文件>客户端配置文件</h3><h4 id=位置>位置</h4><p>SSH 客户端的全局配置文件是<code>/etc/ssh/ssh_config</code>，用户个人的配置文件在<code>~/.ssh/config</code>，优先级高于全局配置文件。</p><p>除了配置文件，<code>~/.ssh</code>目录还有一些用户个人的密钥文件和其他文件。下面是其中一些常见的文件：</p><ul><li><code>~/.ssh/id_ecdsa</code>：用户的 ECDSA 私钥。</li><li><code>~/.ssh/id_ecdsa.pub</code>：用户的 ECDSA 公钥。</li><li><code>~/.ssh/id_rsa</code>：用于 SSH 协议版本2 的 RSA 私钥。</li><li><code>~/.ssh/id_rsa.pub</code>：用于SSH 协议版本2 的 RSA 公钥。</li><li><code>~/.ssh/identity</code>：用于 SSH 协议版本1 的 RSA 私钥。</li><li><code>~/.ssh/identity.pub</code>：用于 SSH 协议版本1 的 RSA 公钥。</li><li><code>~/.ssh/known_hosts</code>：包含 SSH 服务器的公钥指纹。</li></ul><h4 id=主机设置>主机设置</h4><p>用户个人的配置文件<code>~/.ssh/config</code>，可以按照不同服务器，列出各自的连接参数，从而不必每一次登录都输入重复的参数。</p><p>下面是一个例子：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>Host *
</span></span><span class=line><span class=cl>     Port <span class=m>2222</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Host remoteserver
</span></span><span class=line><span class=cl>     HostName remote.example.com
</span></span><span class=line><span class=cl>     User neo
</span></span><span class=line><span class=cl>     Port <span class=m>2112</span>
</span></span></code></pre></td></tr></table></div></div><p>上面代码中，<code>Host *</code>表示对所有主机生效，后面的<code>Port 2222</code>表示所有主机的默认连接端口都是2222，这样就不用在登录时特别指定端口了。这里的缩进并不是必需的，只是为了视觉上，易于识别针对不同主机的设置。</p><p>后面的<code>Host remoteserver</code>表示，下面的设置只对主机<code>remoteserver</code>生效。<code>remoteserver</code>只是一个别名，具体的主机由<code>HostName</code>命令指定，<code>User</code>和<code>Port</code>这两项分别表示用户名和端口。这里的<code>Port</code>会覆盖上面<code>Host *</code>部分的<code>Port</code>设置。</p><p>以后，登录<code>remote.example.com</code>时，只要执行<code>ssh remoteserver</code>命令，就会自动套用 config 文件里面指定的参数。
单个主机的配置格式如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ ssh remoteserver
</span></span><span class=line><span class=cl><span class=c1># 等同于</span>
</span></span><span class=line><span class=cl>$ ssh -p <span class=m>2112</span> neo@remote.example.com
</span></span></code></pre></td></tr></table></div></div><p><code>Host</code>命令的值可以使用通配符，比如<code>Host *</code>表示对所有主机都有效的设置，<code>Host *.edu</code>表示只对一级域名为<code>.edu</code>的主机有效的设置。它们的设置都可以被单个主机的设置覆盖。</p><h4 id=配置命令的语法>配置命令的语法</h4><p>ssh 客户端配置文件的每一行，就是一个配置命令。配置命令与对应的值之间，可以使用空格，也可以使用等号。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>Compression yes
</span></span><span class=line><span class=cl><span class=c1># 等同于</span>
</span></span><span class=line><span class=cl><span class=nv>Compression</span> <span class=o>=</span> yes
</span></span></code></pre></td></tr></table></div></div><p><code>#</code>开头的行表示注释，会被忽略。空行等同于注释。</p><h4 id=主要配置命令>主要配置命令</h4><p>下面是 ssh 客户端的一些主要配置命令，以及它们的范例值。</p><ul><li><code>AddressFamily inet</code>：表示只使用 IPv4 协议。如果设为<code>inet6</code>，表示只使用 IPv6 协议。</li><li><code>BindAddress 192.168.10.235</code>：指定本机的 IP 地址（如果本机有多个 IP 地址）。</li><li><code>CheckHostIP yes</code>：检查 SSH 服务器的 IP 地址是否跟公钥数据库吻合。</li><li><code>Ciphers blowfish,3des</code>：指定加密算法。</li><li><code>Compression yes</code>：是否压缩传输信号。</li><li><code>ConnectionAttempts 10</code>：客户端进行连接时，最大的尝试次数。</li><li><code>ConnectTimeout 60</code>：客户端进行连接时，服务器在指定秒数内没有回复，则中断连接尝试。</li><li><code>DynamicForward 1080</code>：指定动态转发端口。</li><li><code>GlobalKnownHostsFile /users/smith/.ssh/my_global_hosts_file</code>：指定全局的公钥数据库文件的位置。</li><li><code>Host server.example.com</code>：指定连接的域名或 IP 地址，也可以是别名，支持通配符。<code>Host</code>命令后面的所有配置，都是针对该主机的，直到下一个<code>Host</code>命令为止。</li><li><code>HostKeyAlgorithms ssh-dss,ssh-rsa</code>：指定密钥算法，优先级从高到低排列。</li><li><code>HostName myserver.example.com</code>：在<code>Host</code>命令使用别名的情况下，<code>HostName</code>指定域名或 IP 地址。</li><li><code>IdentityFile keyfile</code>：指定私钥文件。</li><li><code>LocalForward 2001 localhost:143</code>：指定本地端口转发。</li><li><code>LogLevel QUIET</code>：指定日志详细程度。如果设为<code>QUIET</code>，将不输出大部分的警告和提示。</li><li><code>MACs hmac-sha1,hmac-md5</code>：指定数据校验算法。</li><li><code>NumberOfPasswordPrompts 2</code>：密码登录时，用户输错密码的最大尝试次数。</li><li><code>PasswordAuthentication no</code>：指定是否支持密码登录。不过，这里只是客户端禁止，真正的禁止需要在 SSH 服务器设置。</li><li><code>Port 2035</code>：指定客户端连接的 SSH 服务器端口。</li><li><code>PreferredAuthentications publickey,hostbased,password</code>：指定各种登录方法的优先级。</li><li><code>Protocol 2</code>：支持的 SSH 协议版本，多个版本之间使用逗号分隔。</li><li><code>PubKeyAuthentication yes</code>：是否支持密钥登录。这里只是客户端设置，还需要在 SSH 服务器进行相应设置。</li><li><code>RemoteForward 2001 server:143</code>：指定远程端口转发。</li><li><code>SendEnv COLOR</code>：SSH 客户端向服务器发送的环境变量名，多个环境变量之间使用空格分隔。环境变量的值从客户端当前环境中拷贝。</li><li><code>ServerAliveCountMax 3</code>：如果没有收到服务器的回应，客户端连续发送多少次<code>keepalive</code>信号，才断开连接。该项默认值为3。</li><li><code>ServerAliveInterval 300</code>：客户端建立连接后，如果在给定秒数内，没有收到服务器发来的消息，客户端向服务器发送<code>keepalive</code>消息。如果不希望客户端发送，这一项设为<code>0</code>。</li><li><code>StrictHostKeyChecking yes</code>：<code>yes</code>表示严格检查，服务器公钥为未知或发生变化，则拒绝连接。<code>no</code>表示如果服务器公钥未知，则加入客户端公钥数据库，如果公钥发生变化，不改变客户端公钥数据库，输出一条警告，依然允许连接继续进行。<code>ask</code>（默认值）表示询问用户是否继续进行。</li><li><code>TCPKeepAlive yes</code>：客户端是否定期向服务器发送<code>keepalive</code>信息。</li><li><code>User userName</code>：指定远程登录的账户名。</li><li><code>UserKnownHostsFile /users/smith/.ssh/my_local_hosts_file</code>：指定当前用户的<code>known_hosts</code>文件（服务器公钥指纹列表）的位置。</li><li><code>VerifyHostKeyDNS yes</code>：是否通过检查 SSH 服务器的 DNS 记录，确认公钥指纹是否与<code>known_hosts</code>文件保存的一致。</li></ul><hr><h2 id=ssh-密钥登录>SSH 密钥登录</h2><p>SSH 默认采用密码登录，这种方法有很多缺点，简单的密码不安全，复杂的密码不容易记忆，每次手动输入也很麻烦。<strong>密钥登录是比密码登录更好的解决方案</strong>。</p><h3 id=密钥是什么>密钥是什么</h3><p>密钥（key）是一个非常大的数字，通过加密算法得到。对称加密只需要一个密钥，非对称加密需要两个密钥成对使用，分为公钥（public key）和私钥（private key）。</p><p><strong>SSH 密钥登录采用的是非对称加密</strong>，每个用户通过自己的密钥登录。其中，<strong>私钥必须私密保存，不能泄漏</strong>；<strong>公钥则是公开的，可以对外发送</strong>。它们的关系是，<strong>公钥和私钥是一一对应的</strong>，<strong>每一个私钥都有且仅有一个对应的公钥</strong>，<strong>反之亦然</strong>。</p><p><strong>如果数据使用公钥加密，那么只有使用对应的私钥才能解密，其他密钥都不行</strong>；<strong>反过来，如果使用私钥加密（这个过程一般称为“签名”），也只有使用对应的公钥解密。</strong></p><h3 id=密钥登录的过程>密钥登录的过程</h3><p>SSH 密钥登录分为以下的步骤:</p><p>预备步骤，客户端通过<code>ssh-keygen</code>生成自己的公钥和私钥。</p><p>第一步，手动将客户端的公钥放入远程服务器的指定位置。</p><p>第二步，客户端向服务器发起 SSH 登录的请求。</p><p>第三步，服务器收到用户 SSH 登录的请求，发送一些随机数据给用户，要求用户证明自己的身份。</p><p>第四步，客户端收到服务器发来的数据，使用私钥对数据进行签名，然后再发还给服务器。</p><p>第五步，服务器收到客户端发来的加密签名后，使用对应的公钥解密，然后跟原始数据比较。如果一致，就允许用户登录。</p><h3 id=ssh-keygen命令生成密钥><code>ssh-keygen</code>命令：生成密钥</h3><h4 id=基本用法-1>基本用法</h4><p>密钥登录时，首先需要生成公钥和私钥。OpenSSH 提供了一个工具程序<code>ssh-keygen</code>命令，<strong>用来生成密钥</strong>。</p><p>直接输入<code>ssh-keygen</code>，程序会询问一系列问题，然后生成密钥:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ ssh-keygen
</span></span></code></pre></td></tr></table></div></div><p>通常做法是使用<code>-t</code>参数，指定密钥的加密算法:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ ssh-keygen -t dsa
</span></span></code></pre></td></tr></table></div></div><p>上面示例中，<code>-t</code>参数用来指定密钥的加密算法，一般会选择 DSA 算法或 RSA 算法。如果省略该参数，默认使用 RSA 算法。</p><p>一般都加<code>-t</code>选项，有的ssh版本默认的加密算法不同。</p><p>输入上面的命令以后，<code>ssh-keygen</code>会要求用户回答一些问题:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ ssh-keygen -t dsa
</span></span><span class=line><span class=cl>Generating public/private dsa key pair.
</span></span><span class=line><span class=cl>Enter file in which to save the key <span class=o>(</span>/home/username/.ssh/id_dsa<span class=o>)</span>:  press ENTER
</span></span><span class=line><span class=cl>Enter passphrase <span class=o>(</span>empty <span class=k>for</span> no passphrase<span class=o>)</span>: ********
</span></span><span class=line><span class=cl>Enter same passphrase again: ********
</span></span><span class=line><span class=cl>Your identification has been saved in /home/username/.ssh/id_dsa.
</span></span><span class=line><span class=cl>Your public key has been saved in /home/username/.ssh/id_dsa.pub.
</span></span><span class=line><span class=cl>The key fingerprint is:
</span></span><span class=line><span class=cl>14:ba:06:98:a8:98:ad:27:b5:ce:55:85:ec:64:37:19 username@shell.isp.com
</span></span></code></pre></td></tr></table></div></div><p>上面示例中，执行<code>ssh-keygen</code>命令以后，会出现第一个问题，<strong>询问密钥保存的文件名</strong>，默认是<code>~/.ssh/id_dsa</code>文件，这个是私钥的文件名，对应的公钥文件<code>~/.ssh/id_dsa.pub</code>是自动生成的。用户的密钥一般都放在主目录的<code>.ssh</code>目录里面。</p><p>如果选择<code>rsa</code>算法，生成的密钥文件默认就会是<code>~/.ssh/id_rsa</code>（私钥）和<code>~/.ssh/id_rsa.pub</code>（公钥）。</p><p>接着，就会是第二个问题**，询问是否要为私钥文件设定密码保护（passphrase）<strong>。这样的话，即使入侵者</strong>拿到私钥，还是需要破解密码**。如果为了方便，不想设定密码保护，可以直接按回车键，密码就会为空。后面还会让你再输入一次密码，两次输入必须一致。注意，这里“密码”的英文单词是 passphrase，这是为了避免与 Linux 账户的密码单词 password 混淆，表示这不是用户系统账户的密码。</p><p>秘钥密码如果不为空，那么每次连接都需要输入密码。</p><p>最后，就会生成私钥和公钥，屏幕上还会给出公钥的指纹，以及当前的用户名和主机名作为注释，<strong>用来识别密钥的来源</strong>。</p><p>公钥文件和私钥文件都是文本文件，可以用文本编辑器看一下它们的内容。公钥文件的内容类似下面这样:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>ssh-dss AAAAB3NzaC1yc2EAAAABIwAAAIEAvpB4lUbAaEbh9u6HLig7amsfywD4fqSZq2ikACIUBn3GyRPfeF93l/
</span></span><span class=line><span class=cl>weQh702ofXbDydZAKMcDvBJqRhUotQUwqV6HJxqoqPDlPGUUyo8RDIkLUIPRyq
</span></span><span class=line><span class=cl>ypZxmK9aCXokFiHoGCXfQ9imUP/w/jfqb9ByDtG97tUJF6nFMP5WzhM= username@shell.isp.com
</span></span></code></pre></td></tr></table></div></div><p>上面示例中，末尾的<code>username@shell.isp.com</code>是公钥的注释，用来识别不同的公钥，表示这是哪台主机（<code>shell.isp.com</code>）的哪个用户（<code>username</code>）的公钥，<strong>不是必需项</strong>。</p><p>注意，公钥只有一行。因为它太长了，所以上面分成三行显示。</p><p>下面的命令可以列出用户所有的公钥:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ ls -l ~/.ssh/id_*.pub
</span></span></code></pre></td></tr></table></div></div><p>生成密钥以后，建议修改它们的权限，防止其他人读取:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ chmod <span class=m>600</span> ~/.ssh/id_rsa
</span></span><span class=line><span class=cl>$ chmod <span class=m>600</span> ~/.ssh/id_rsa.pub
</span></span></code></pre></td></tr></table></div></div><h4 id=配置项>配置项</h4><p><code>ssh-keygen</code>的命令行配置项，主要有下面这些:</p><p><strong>（1）<code>-b</code></strong></p><p><code>-b</code>参数指定密钥的二进制位数。这个参数值越大，密钥就越不容易破解，但是加密解密的计算开销也会加大。</p><p>一般来说，<code>-b</code>至少应该是<code>1024</code>，更安全一些可以设为<code>2048</code>或者更高。</p><p><strong>（2）<code>-C</code></strong></p><p><code>-C</code>参数可以为密钥文件指定新的注释，格式为<code>username@host</code>。</p><p>下面命令生成一个4096位 RSA 加密算法的密钥对，并且给出了用户名和主机名。一般默认即可。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ ssh-keygen -t rsa -b <span class=m>4096</span> -C <span class=s2>&#34;your_email@domain.com&#34;</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>（3）<code>-f</code></strong></p><p><code>-f</code>参数指定生成的私钥文件。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ ssh-keygen -t dsa -f mykey
</span></span></code></pre></td></tr></table></div></div><p>上面命令会在当前目录生成私钥文件<code>mykey</code>和公钥文件<code>mykey.pub</code>。</p><p><strong>（4）<code>-F</code></strong></p><p><code>-F</code>参数检查某个主机名是否在<code>known_hosts</code>文件里面。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ ssh-keygen -F example.com
</span></span></code></pre></td></tr></table></div></div><p><strong>（5）<code>-N</code></strong></p><p><code>-N</code>参数用于指定私钥的密码（passphrase）。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ ssh-keygen -t dsa -N secretword
</span></span></code></pre></td></tr></table></div></div><p><strong>（6）<code>-p</code></strong></p><p><code>-p</code>参数用于重新指定私钥的密码（passphrase）。它与<code>-N</code>的不同之处在于，新密码不在命令中指定，而是执行后再输入。ssh 先要求输入旧密码，然后要求输入两遍新密码。</p><p><strong>（7）<code>-R</code></strong></p><p><code>-R</code>参数将指定的主机公钥指纹移出<code>known_hosts</code>文件。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ ssh-keygen -R example.com
</span></span></code></pre></td></tr></table></div></div><p><strong>（8）<code>-t</code></strong></p><p><code>-t</code>参数用于指定生成密钥的加密算法，一般为<code>dsa</code>或<code>rsa</code></p><h3 id=手动上传公钥>手动上传公钥</h3><p><strong>生成密钥以后，公钥必须上传到服务器，才能使用公钥登录</strong>。</p><p><strong>OpenSSH 规定，用户公钥保存在服务器的<code>~/.ssh/authorized_keys</code>文件</strong>。你要以哪个用户的身份登录到服务器，密钥就必须保存在<strong>该用户主目录</strong>的<code>~/.ssh/authorized_keys</code>文件。只要把公钥添加到这个文件之中，就相当于公钥上传到服务器了。<strong>每个公钥占据一行</strong>。如果该文件不存在，可以手动创建。</p><p>用户可以手动编辑该文件，把公钥粘贴进去，也可以在本机计算机上，执行下面的命令：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ cat ~/.ssh/id_rsa.pub <span class=p>|</span> ssh user@host <span class=s2>&#34;mkdir -p ~/.ssh &amp;&amp; cat &gt;&gt; ~/.ssh/authorized_keys&#34;</span>
</span></span></code></pre></td></tr></table></div></div><p>上面示例中，<code>user@host</code>要替换成你所要登录的用户名和主机名。</p><p><strong>注意</strong>，<code>authorized_keys</code>文件的权限要设为<code>644</code>，即只有文件所有者才能写。如果权限设置不对，SSH 服务器可能会拒绝读取该文件：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ chmod <span class=m>644</span> ~/.ssh/authorized_keys
</span></span></code></pre></td></tr></table></div></div><p>只要公钥上传到服务器，下次登录时，<strong>OpenSSH 就会自动采用密钥登录</strong>，不再提示输入密码。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ ssh -l username shell.isp.com
</span></span><span class=line><span class=cl>Enter passphrase <span class=k>for</span> key <span class=s1>&#39;/home/you/.ssh/id_dsa&#39;</span>: ************
</span></span><span class=line><span class=cl>Last login: Mon Mar <span class=m>24</span> 02:17:27 <span class=m>2014</span> from ex.ample.com
</span></span><span class=line><span class=cl>shell.isp.com&gt;
</span></span></code></pre></td></tr></table></div></div><p>上面例子中，SSH 客户端使用私钥之前，会要求用户输入密码（passphrase），用来解开私钥。如果秘钥有密码，那么每次都需要输入密码。</p><h3 id=ssh-copy-id-命令自动上传公钥>ssh-copy-id 命令：自动上传公钥</h3><p>OpenSSH 自带一个<code>ssh-copy-id</code>命令，可以自动将公钥拷贝到远程服务器的<code>~/.ssh/authorized_keys</code>文件。如果<code>~/.ssh/authorized_keys</code>文件不存在，<code>ssh-copy-id</code>命令会自动创建该文件。</p><p>用户在本地计算机执行下面的命令，就可以把本地的公钥拷贝到服务器。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ ssh-copy-id -i key_file user@host
</span></span></code></pre></td></tr></table></div></div><p>上面命令中，<code>-i</code>参数用来指定公钥文件，<code>user</code>是所要登录的账户名，<code>host</code>是服务器地址。如果省略用户名，默认为当前的本机用户名。执行完该命令，公钥就会拷贝到服务器。</p><p>注意，公钥文件可以<strong>不指定<code>.pub</code>后缀名</strong>，<code>ssh-copy-id</code>会自动在当前目录里面寻找。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1># ~/.ssh</span>
</span></span><span class=line><span class=cl>$ ssh-copy-id -i id_rsa user@host
</span></span></code></pre></td></tr></table></div></div><p>上面命令中，公钥文件会自动匹配到<code>~/.ssh/id_rsa.pub</code>。</p><p><strong>注意</strong>，<code>ssh-copy-id</code>是直接将公钥添加到<code>authorized_keys</code>文件的末尾。如果<code>authorized_keys</code>文件的末尾不是一个换行符，会导致新的公钥添加到前一个公钥的末尾，两个公钥连在一起，使得它们都无法生效。所以，如果<code>authorized_keys</code>文件已经存在，使用<code>ssh-copy-id</code>命令之前，务必保证<code>authorized_keys</code>文件的末尾是换行符（假设该文件已经存在）。</p><h3 id=ssh-agent-命令ssh-add-命令>ssh-agent 命令，ssh-add 命令</h3><h4 id=基本用法-2>基本用法</h4><p>私钥设置了密码以后，每次使用都必须输入密码，有时让人感觉非常麻烦。比如，连续使用<code>scp</code>命令远程拷贝文件时，每次都要求输入密码。</p><p><code>ssh-agent</code>命令就是为了解决这个问题而设计的，它让用户在整个 Bash 对话（session）之中，<strong>只在第一次使用 SSH 命令时输入密码，然后将私钥保存在内存中，后面都不需要再输入私钥的密码了</strong>。</p><p>第一步，使用下面的命令新建一次命令行对话:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ ssh-agent bash
</span></span></code></pre></td></tr></table></div></div><p>上面命令中，如果你使用的命令行环境不是 Bash，可以用其他的 Shell 命令代替。比如<code>zsh</code>和<code>fish</code>。</p><p>如果想在当前对话启用<code>ssh-agent</code>，可以使用下面的命令:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ <span class=nb>eval</span> <span class=sb>`</span>ssh-agent<span class=sb>`</span>
</span></span></code></pre></td></tr></table></div></div><p>上面命令中，<code>ssh-agent</code>会先自动在后台运行，并将需要设置的环境变量输出在屏幕上，类似下面这样:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ ssh-agent
</span></span><span class=line><span class=cl><span class=nv>SSH_AUTH_SOCK</span><span class=o>=</span>/tmp/ssh-barrett/ssh-22841-agent<span class=p>;</span> <span class=nb>export</span> SSH_AUTH_SOCK<span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nv>SSH_AGENT_PID</span><span class=o>=</span>22842<span class=p>;</span> <span class=nb>export</span> SSH_AGENT_PID<span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> Agent pid 22842<span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p><code>eval</code>命令的作用，就是运行上面的<code>ssh-agent</code>命令的输出，设置环境变量。</p><p>第二步，在新建的 Shell 对话里面，使用<code>ssh-add</code>命令添加默认的私钥（比如<code>~/.ssh/id_rsa</code>，或<code>~/.ssh/id_dsa</code>，或<code>~/.ssh/id_ecdsa</code>，或<code>~/.ssh/id_ed25519</code>）:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ ssh-add
</span></span><span class=line><span class=cl>Enter passphrase <span class=k>for</span> /home/you/.ssh/id_dsa: ********
</span></span><span class=line><span class=cl>Identity added: /home/you/.ssh/id_dsa <span class=o>(</span>/home/you/.ssh/id_dsa<span class=o>)</span>
</span></span></code></pre></td></tr></table></div></div><p>上面例子中，添加私钥时，会要求输入密码。以后，在这个对话里面再使用密钥时，就不需要输入私钥的密码了，因为私钥已经加载到内存里面了。</p><p>如果添加的不是默认私钥，<code>ssh-add</code>命令需要显式指定私钥文件:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ ssh-add my-other-key-file
</span></span></code></pre></td></tr></table></div></div><p>上面的命令中，<code>my-other-key-file</code>就是用户指定的私钥文件。</p><p>第三步，使用 ssh 命令正常登录远程服务器。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ ssh remoteHost
</span></span></code></pre></td></tr></table></div></div><p>上面命令中，<code>remoteHost</code>是远程服务器的地址，ssh 使用的是默认的私钥。这时如果私钥设有密码，ssh 将不再询问密码，而是直接取出内存里面的私钥。</p><p>如果要使用其他私钥登录服务器，需要使用 ssh 命令的<code>-i</code>参数指定私钥文件:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ ssh –i OpenSSHPrivateKey remoteHost
</span></span></code></pre></td></tr></table></div></div><p>最后，如果要退出<code>ssh-agent</code>，可以直接退出子 Shell（按下 Ctrl + d），也可以使用下面的命令:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ ssh-agent -k
</span></span></code></pre></td></tr></table></div></div><h3 id=ssh-add命令><code>ssh-add</code>命令</h3><p><code>ssh-add</code>命令用来将私钥加入<code>ssh-agent</code>，它有如下的参数:</p><p><strong>（1）<code>-d</code></strong></p><p><code>-d</code>参数从内存中删除指定的私钥。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ ssh-add -d name-of-key-file
</span></span></code></pre></td></tr></table></div></div><p><strong>（2）<code>-D</code></strong></p><p><code>-D</code>参数从内存中删除所有已经添加的私钥。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ ssh-add -D
</span></span></code></pre></td></tr></table></div></div><p><strong>（3）<code>-l</code></strong></p><p><code>-l</code>参数列出所有已经添加的私钥。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ ssh-add -l
</span></span></code></pre></td></tr></table></div></div><h3 id=关闭密码登录>关闭密码登录</h3><p><strong>为了安全性，启用密钥登录之后，最好关闭服务器的密码登录</strong>。</p><p>对于 OpenSSH，具体方法就是打开服务器 sshd 的配置文件<code>/etc/ssh/sshd_config</code>，将<code>PasswordAuthentication</code>这一项设为<code>no</code>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>PasswordAuthentication no
</span></span></code></pre></td></tr></table></div></div><p>修改配置文件以后，不要忘了重新启动 sshd，否则不会生效。</p><hr><h2 id=ssh-证书登录>SSH 证书登录</h2><p>SSH 是服务器登录工具，一般情况下都采用密码登录或密钥登录。</p><p>但是，SSH 还有第三种登录方法，那就是证书登录。某些情况下，它是更合理、更安全的登录方法，本文就介绍这种登录方法。</p><h3 id=非证书登录的缺点>非证书登录的缺点</h3><p>密码登录和密钥登录，都有各自的缺点。</p><p>密码登录需要输入服务器密码，这非常麻烦，也不安全，存在被暴力破解的风险。</p><p>密钥登录需要服务器保存用户的公钥，也需要用户保存服务器公钥的指纹。这对于多用户、多服务器的大型机构很不方便，如果有员工离职，需要将他的公钥从每台服务器删除。</p><h3 id=证书登录是什么>证书登录是什么？</h3><p>证书登录就是为了解决上面的缺点而设计的。它引入了一个<strong>证书颁发机构</strong>（Certificate Authority，简称 CA），对信任的服务器颁发服务器证书，对信任的用户颁发用户证书。</p><p>登录时，用户和服务器不需要提前知道彼此的公钥，只需要交换各自的证书，验证是否可信即可。</p><p>证书登录的主要优点有两个：（1）用户和服务器不用交换公钥，这更容易管理，也具有更好的可扩展性。（2）证书可以设置到期时间，而公钥没有到期时间。针对不同的情况，可以设置有效期很短的证书，进一步提高安全性。</p><h3 id=证书登录的流程>证书登录的流程</h3><p>SSH 证书登录之前，如果还没有证书，需要生成证书。具体方法是：（1）用户和服务器都将自己的公钥，发给 CA；（2）CA 使用服务器公钥，生成服务器证书，发给服务器；（3）CA 使用用户的公钥，生成用户证书，发给用户。</p><p>有了证书以后，用户就可以登录服务器了。整个过程都是 SSH 自动处理，用户无感知。</p><p>第一步，用户登录服务器时，SSH 自动将用户证书发给服务器。</p><p>第二步，服务器检查用户证书是否有效，以及是否由可信的 CA 颁发。证实以后，就可以信任用户。</p><p>第三步，SSH 自动将服务器证书发给用户。</p><p>第四步，用户检查服务器证书是否有效，以及是否由信任的 CA 颁发。证实以后，就可以信任服务器。</p><p>第五步，双方建立连接，服务器允许用户登录。</p><h3 id=生成-ca-的密钥>生成 CA 的密钥</h3><p>证书登录的前提是，必须有一个 CA，而 CA 本质上就是一对密钥，跟其他密钥没有不同，CA 就用这对密钥去签发证书。</p><p>虽然 CA 可以用同一对密钥签发用户证书和服务器证书，但是出于安全性和灵活性，最好用不同的密钥分别签发。所以，CA 至少需要两对密钥，一对是签发用户证书的密钥，假设叫做<code>user_ca</code>，另一对是签发服务器证书的密钥，假设叫做<code>host_ca</code>。</p><p>使用下面的命令，生成<code>user_ca</code>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 生成 CA 签发用户证书的密钥</span>
</span></span><span class=line><span class=cl>$ ssh-keygen -t rsa -b <span class=m>4096</span> -f ~/.ssh/user_ca -C user_ca
</span></span></code></pre></td></tr></table></div></div><p>上面的命令会在<code>~/.ssh</code>目录生成一对密钥：<code>user_ca</code>（私钥）和<code>user_ca.pub</code>（公钥）。</p><p>这个命令的各个参数含义如下。</p><ul><li><code>-t rsa</code>：指定密钥算法 RSA。</li><li><code>-b 4096</code>：指定密钥的位数是4096位。安全性要求不高的场合，这个值可以小一点，但是不应小于1024。</li><li><code>-f ~/.ssh/user_ca</code>：指定生成密钥的位置和文件名。</li><li><code>-C user_ca</code>：指定密钥的识别字符串，相当于注释，可以随意设置。</li></ul><p>使用下面的命令，生成<code>host_ca</code>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 生成 CA 签发服务器证书的密钥</span>
</span></span><span class=line><span class=cl>$ ssh-keygen -t rsa -b <span class=m>4096</span> -f host_ca -C host_ca
</span></span></code></pre></td></tr></table></div></div><p>上面的命令会在<code>~/.ssh</code>目录生成一对密钥：<code>host_ca</code>（私钥）和<code>host_ca.pub</code>（公钥）。</p><p>现在，<code>~/.ssh</code>目录应该至少有四把密钥。</p><ul><li><code>~/.ssh/user_ca</code></li><li><code>~/.ssh/user_ca.pub</code></li><li><code>~/.ssh/host_ca</code></li><li><code>~/.ssh/host_ca.pub</code></li></ul><h3 id=ca-签发服务器证书>CA 签发服务器证书</h3><p>有了秘钥以后，就可以签发服务器证书CA了。</p><p>签发证书，除了 CA 的密钥以外，还需要<strong>服务器的公钥</strong>。一般来说，SSH 服务器（通常是<code>sshd</code>）安装时，已经生成密钥<code>/etc/ssh/ssh_host_rsa_key</code>了。如果没有的话，可以用下面的命令生成：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ sudo ssh-keygen -f /etc/ssh/ssh_host_rsa_key -b <span class=m>4096</span> -t rsa
</span></span></code></pre></td></tr></table></div></div><p>上面命令会在<code>/etc/ssh</code>目录，生成<code>ssh_host_rsa_key</code>（私钥）和<code>ssh_host_rsa_key.pub</code>（公钥）。然后，需要把服务器公钥<code>ssh_host_rsa_key.pub</code>，<strong>复制或上传到 CA 所在的服务器</strong>。</p><p>上传以后，CA 就可以使用密钥<code>host_ca</code>为服务器的公钥<code>ssh_host_rsa_key.pub</code>签发服务器证书：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ ssh-keygen -s host_ca -I host.example.com -h -n host.example.com -V +52w ssh_host_rsa_key.pub
</span></span></code></pre></td></tr></table></div></div><p>上面的命令会生成服务器证书<code>ssh_host_rsa_key-cert.pub</code>（服务器公钥名字加后缀<code>-cert</code>）。这个命令各个参数的含义如下。</p><ul><li><code>-s</code>：指定 CA 签发证书的密钥。</li><li><code>-I</code>：身份字符串，可以随便设置，相当于注释，方便区分证书，将来可以使用这个字符串撤销证书。</li><li><code>-h</code>：指定该证书是服务器证书，而不是用户证书。</li><li><code>-n host.example.com</code>：指定服务器的域名，表示证书仅对该域名有效。如果有多个域名，则使用逗号分隔。用户登录该域名服务器时，SSH 通过证书的这个值，分辨应该使用哪张证书发给用户，用来证明服务器的可信性。</li><li><code>-V +52w</code>：指定证书的有效期，这里为52周（一年）。默认情况下，证书是永远有效的。建议使用该参数指定有效期，并且有效期最好短一点，最长不超过52周。</li><li><code>ssh_host_rsa_key.pub</code>：服务器公钥。</li></ul><p>生成证书以后，可以使用下面的命令，查看证书的细节。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ ssh-keygen -L -f ssh_host_rsa_key-cert.pub
</span></span></code></pre></td></tr></table></div></div><p>最后，为证书设置权限。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ chmod <span class=m>600</span> ssh_host_rsa_key-cert.pub
</span></span></code></pre></td></tr></table></div></div><h3 id=ca-签发用户证书>CA 签发用户证书</h3><p>下面，再用 CA 签发用户证书。这时需要用户的公钥，如果没有的话，客户端可以用下面的命令生成一对密钥：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ ssh-keygen -f ~/.ssh/user_key -b <span class=m>4096</span> -t rsa
</span></span></code></pre></td></tr></table></div></div><p>上面命令会在<code>~/.ssh</code>目录，生成<code>user_key</code>（私钥）和<code>user_key.pub</code>（公钥）。</p><p>然后，将用户公钥<code>user_key.pub</code>，上传或复制到 CA 服务器。接下来，就可以使用 CA 的密钥<code>user_ca</code>为用户公钥<code>user_key.pub</code>签发用户证书：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ ssh-keygen -s user_ca -I user@example.com -n user -V +1d user_key.pub
</span></span></code></pre></td></tr></table></div></div><p>上面的命令会生成用户证书<code>user_key-cert.pub</code>（用户公钥名字加后缀<code>-cert</code>）。这个命令各个参数的含义如下。</p><ul><li><code>-s</code>：指定 CA 签发证书的密钥</li><li><code>-I</code>：身份字符串，可以随便设置，相当于注释，方便区分证书，将来可以使用这个字符串撤销证书。</li><li><code>-n user</code>：指定用户名，表示证书仅对该用户名有效。如果有多个用户名，使用逗号分隔。用户以该用户名登录服务器时，SSH 通过这个值，分辨应该使用哪张证书，证明自己的身份，发给服务器。</li><li><code>-V +1d</code>：指定证书的有效期，这里为1天，强制用户每天都申请一次证书，提高安全性。默认情况下，证书是永远有效的。</li><li><code>user_key.pub</code>：用户公钥。</li></ul><p>生成证书以后，可以使用下面的命令，查看证书的细节。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ ssh-keygen -L -f user_key-cert.pub
</span></span></code></pre></td></tr></table></div></div><p>最后，为证书设置权限。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ chmod <span class=m>600</span> user_key-cert.pub
</span></span></code></pre></td></tr></table></div></div><h3 id=服务器安装证书>服务器安装证书</h3><p>CA 生成服务器证书<code>ssh_host_rsa_key-cert.pub</code>以后，需要将该证书发回服务器，可以使用下面的<code>scp</code>命令，将证书拷贝过去：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ scp ~/.ssh/ssh_host_rsa_key-cert.pub root@host.example.com:/etc/ssh/
</span></span></code></pre></td></tr></table></div></div><p>然后，将下面一行添加到服务器配置文件<code>/etc/ssh/sshd_config</code>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>HostCertificate /etc/ssh/ssh_host_rsa_key-cert.pub
</span></span></code></pre></td></tr></table></div></div><p>上面的代码告诉 sshd，服务器证书是哪一个文件。</p><p>重新启动 sshd。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ sudo systemctl restart sshd
</span></span><span class=line><span class=cl><span class=c1># 或者</span>
</span></span><span class=line><span class=cl>$ sudo service sshd restart
</span></span></code></pre></td></tr></table></div></div><h3 id=服务器安装-ca-公钥>服务器安装 CA 公钥</h3><p>为了让服务器信任用户证书，必须将 CA 签发用户证书的公钥<code>user_ca.pub</code>，拷贝到服务器：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ scp ~/.ssh/user_ca.pub root@host.example.com:/etc/ssh/
</span></span></code></pre></td></tr></table></div></div><p>上面的命令，将 CA 签发用户证书的公钥<code>user_ca.pub</code>，拷贝到 SSH 服务器的<code>/etc/ssh</code>目录。</p><p>然后，将下面一行添加到服务器配置文件<code>/etc/ssh/sshd_config</code>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>TrustedUserCAKeys /etc/ssh/user_ca.pub
</span></span></code></pre></td></tr></table></div></div><p>上面的做法是将<code>user_ca.pub</code>加到<code>/etc/ssh/sshd_config</code>，这会产生全局效果，即服务器的所有账户都会信任<code>user_ca</code>签发的所有用户证书。</p><p>另一种做法是将<code>user_ca.pub</code>加到服务器某个账户的<code>~/.ssh/authorized_keys</code>文件，只让该账户信任<code>user_ca</code>签发的用户证书。具体方法是打开<code>~/.ssh/authorized_keys</code>，追加一行，开头是<code>@cert-authority principals="..."</code>，然后后面加上<code>user_ca.pub</code>的内容，大概是下面这个样子。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>@cert-authority <span class=nv>principals</span><span class=o>=</span><span class=s2>&#34;user&#34;</span> ssh-rsa AAAAB3Nz...XNRM1EX2gQ<span class=o>==</span>
</span></span></code></pre></td></tr></table></div></div><p>上面代码中，<code>principals="user"</code>指定用户登录的服务器账户名，一般就是<code>authorized_keys</code>文件所在的账户。</p><p>重新启动 sshd。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ sudo systemctl restart sshd
</span></span><span class=line><span class=cl><span class=c1># 或者</span>
</span></span><span class=line><span class=cl>$ sudo service sshd restart
</span></span></code></pre></td></tr></table></div></div><p>至此，SSH 服务器已配置为信任<code>user_ca</code>签发的证书。</p><h3 id=客户端安装证书>客户端安装证书</h3><p>客户端安装用户证书很简单，就是从 CA 将用户证书<code>user_key-cert.pub</code>复制到客户端，与用户的密钥<code>user_key</code>保存在同一个目录即可。</p><h3 id=客户端安装-ca-公钥>客户端安装 CA 公钥</h3><p>为了让客户端信任服务器证书，必须将 CA 签发服务器证书的公钥<code>host_ca.pub</code>，加到客户端的<code>/etc/ssh/ssh_known_hosts</code>文件（全局级别）或者<code>~/.ssh/known_hosts</code>文件（用户级别）。</p><p>具体做法是打开<code>ssh_known_hosts</code>或<code>known_hosts</code>文件，追加一行，开头为<code>@cert-authority *.example.com</code>，然后将<code>host_ca.pub</code>文件的内容（即公钥）粘贴在后面，大概是下面这个样子：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>@cert-authority *.example.com ssh-rsa AAAAB3Nz...XNRM1EX2gQ<span class=o>==</span>
</span></span></code></pre></td></tr></table></div></div><p>上面代码中，<code>*.example.com</code>是域名的模式匹配，表示只要服务器符合该模式的域名，且签发服务器证书的 CA 匹配后面给出的公钥，就都可以信任。如果没有域名限制，这里可以写成<code>*</code>。如果有多个域名模式，可以使用逗号分隔；如果服务器没有域名，可以用主机名（比如<code>host1,host2,host3</code>）或者 IP 地址（比如<code>11.12.13.14,21.22.23.24</code>）。</p><p>然后，就可以使用证书，登录远程服务器了。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ ssh -i ~/.ssh/user_key user@host.example.com
</span></span></code></pre></td></tr></table></div></div><p>上面命令的<code>-i</code>参数用来指定用户的密钥。如果证书与密钥在同一个目录，则连接服务器时将自动使用该证书。</p><h3 id=废除证书>废除证书</h3><p>废除证书的操作，分成用户证书的废除和服务器证书的废除两种。</p><p>服务器证书的废除，用户需要在<code>known_hosts</code>文件里面，修改或删除对应的<code>@cert-authority</code>命令的那一行。</p><p>用户证书的废除，需要在服务器新建一个<code>/etc/ssh/revoked_keys</code>文件，然后在配置文件<code>sshd_config</code>添加一行，内容如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>RevokedKeys /etc/ssh/revoked_keys
</span></span></code></pre></td></tr></table></div></div><p><code>revoked_keys</code>文件保存不再信任的用户公钥，由下面的命令生成：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ ssh-keygen -kf /etc/ssh/revoked_keys -z <span class=m>1</span> ~/.ssh/user1_key.pub
</span></span></code></pre></td></tr></table></div></div><p>上面命令中，<code>-z</code>参数用来指定用户公钥保存在<code>revoked_keys</code>文件的哪一行，这个例子是保存在第1行。</p><p>如果以后需要废除其他的用户公钥，可以用下面的命令保存在第2行。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ ssh-keygen -ukf /etc/ssh/revoked_keys -z <span class=m>2</span> ~/.ssh/user2_key.pub
</span></span></code></pre></td></tr></table></div></div><h3 id=参考链接>参考链接</h3><ul><li><a class=link href=https://smallstep.com/blog/ssh-emergency-access/ target=_blank rel=noopener>SSH Emergency Access</a>, Carl Tashian</li><li><a class=link href=https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/deployment_guide/sec-using_openssh_certificate_authentication target=_blank rel=noopener>Using OpenSSH Certificate Authentication</a>, Red Hat Enterprise Linux Deployment Guide</li><li><a class=link href=https://gravitational.com/blog/how-to-ssh-properly/ target=_blank rel=noopener>How to SSH Properly</a>, Gus Luxton</li></ul><hr><h2 id=scp-命令>scp 命令</h2><p><code>scp</code>是 SSH 提供的一个<strong>客户端程序</strong>，用来在两台主机之间加密传送文件（即复制文件）。</p><h3 id=简介-1>简介</h3><p><code>scp</code>是 secure copy 的缩写，相当于<code>cp</code>命令 + SSH。它的底层是 SSH 协议，默认端口是22，相当于先使用<code>ssh</code>命令登录远程主机，然后再执行拷贝操作。</p><p><code>scp</code>主要用于以下三种复制操作：</p><ul><li>本地复制到远程。</li><li>远程复制到本地。</li><li>两个远程系统之间的复制。</li></ul><p>使用<code>scp</code>传输数据时，文件和密码都是加密的，不会泄漏敏感信息。</p><h3 id=基本语法>基本语法</h3><p><code>scp</code>的语法类似<code>cp</code>的语法：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ scp <span class=nb>source</span> destination
</span></span></code></pre></td></tr></table></div></div><p>上面命令中，<code>source</code>是文件当前的位置，<code>destination</code>是文件所要复制到的位置。它们都可以包含用户名和主机名。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ scp user@host:foo.txt bar.txt
</span></span></code></pre></td></tr></table></div></div><p>上面命令将远程主机（<code>user@host</code>）用户主目录下的<code>foo.txt</code>，复制为本机当前目录的<code>bar.txt</code>。可以看到，主机与文件之间要使用冒号（<code>:</code>）分隔。</p><p><code>scp</code>会先用 SSH 登录到远程主机，然后在加密连接之中复制文件。客户端发起连接后，会提示用户输入密码，这部分是跟 SSH 的用法一致的。</p><p>用户名和主机名都是可以省略的。用户名的默认值是本机的当前用户名，主机名默认为当前主机。注意，<code>scp</code>会使用 SSH 客户端的配置文件<code>.ssh/config</code>，如果配置文件里面定义了主机的别名，这里也可以使用别名连接。</p><p><code>scp</code>支持一次复制多个文件:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ scp source1 source2 destination
</span></span></code></pre></td></tr></table></div></div><p>上面命令会将<code>source1</code>和<code>source2</code>两个文件，复制到<code>destination</code>。</p><p>注意，如果所要复制的文件，在目标位置已经存在同名文件，<code>scp</code>会在没有警告的情况下覆盖同名文件。</p><h3 id=用法示例>用法示例</h3><p><strong>（1）本地文件复制到远程</strong></p><p>复制本机文件到远程系统的用法如下:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 语法</span>
</span></span><span class=line><span class=cl>$ scp SourceFile user@host:directory/TargetFile
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 示例</span>
</span></span><span class=line><span class=cl>$ scp file.txt remote_username@10.10.0.2:/remote/directory
</span></span></code></pre></td></tr></table></div></div><p>下面是复制整个目录的例子:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 将本机的 documents 目录拷贝到远程主机，</span>
</span></span><span class=line><span class=cl><span class=c1># 会在远程主机创建 documents 目录: 远程目录存在，则复制，不存在则改名。注意只能一级目录</span>
</span></span><span class=line><span class=cl>$ scp -r documents username@server_ip:/path_to_remote_directory
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 将本机整个目录拷贝到远程目录下</span>
</span></span><span class=line><span class=cl>$ scp -r localmachine/path_to_the_directory username@server_ip:/path_to_remote_directory/
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 将本机目录下的所有内容拷贝到远程目录下</span>
</span></span><span class=line><span class=cl>$ scp -r localmachine/path_to_the_directory/* username@server_ip:/path_to_remote_directory/
</span></span></code></pre></td></tr></table></div></div><p><strong>（2）远程文件复制到本地</strong></p><p>从远程主机复制文件到本地的用法如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 语法</span>
</span></span><span class=line><span class=cl>$ scp user@host:directory/SourceFile TargetFile
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 示例</span>
</span></span><span class=line><span class=cl>$ scp remote_username@10.10.0.2:/remote/file.txt /local/directory
</span></span></code></pre></td></tr></table></div></div><p>下面是复制整个目录的例子：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 拷贝一个远程目录到本机目录下</span>
</span></span><span class=line><span class=cl>$ scp -r username@server_ip:/path_to_remote_directory local-machine/path_to_the_directory/
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 拷贝远程目录下的所有内容，到本机目录下</span>
</span></span><span class=line><span class=cl>$ scp -r username@server_ip:/path_to_remote_directory/* local-machine/path_to_the_directory/
</span></span><span class=line><span class=cl>$ scp -r user@host:directory/SourceFolder TargetFolder
</span></span></code></pre></td></tr></table></div></div><p><strong>（3）两个远程系统之间的复制</strong></p><p>本机发出指令，从远程主机 A 拷贝到远程主机 B 的用法如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 语法</span>
</span></span><span class=line><span class=cl>$ scp user@host1:directory/SourceFile user@host2:directory/SourceFile
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 示例</span>
</span></span><span class=line><span class=cl>$ scp user1@host1.com:/files/file.txt user2@host2.com:/files
</span></span></code></pre></td></tr></table></div></div><p>系统将提示你输入两个远程帐户的密码。数据将直接从一个远程主机传输到另一个远程主机。</p><p><strong>注意</strong>：远程目录存在，则复制，不存在则改名。<strong>注意只能改一级目录</strong>。</p><h3 id=配置项-1>配置项</h3><p><strong>（1）<code>-c</code></strong></p><p><code>-c</code>参数用来指定文件拷贝数据传输的加密算法。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ scp -c blowfish some_file your_username@remotehost.edu:~
</span></span></code></pre></td></tr></table></div></div><p>上面代码指定加密算法为<code>blowfish</code>。</p><p><strong>（2）<code>-C</code></strong></p><p><code>-C</code>参数表示是否在传输时压缩文件。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ scp -c blowfish -C local_file your_username@remotehost.edu:~
</span></span></code></pre></td></tr></table></div></div><p><strong>（3）<code>-F</code></strong></p><p><code>-F</code>参数用来指定 ssh_config 文件，供 ssh 使用。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ scp -F /home/pungki/proxy_ssh_config Label.pdf root@172.20.10.8:/root
</span></span></code></pre></td></tr></table></div></div><p><strong>（4）<code>-i</code></strong></p><p><code>-i</code>参数用来指定密钥。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ scp -vCq -i private_key.pem ~/test.txt root@192.168.1.3:/some/path/test.txt
</span></span></code></pre></td></tr></table></div></div><p><strong>（5）<code>-l</code></strong></p><p><code>-l</code>参数用来限制传输数据的带宽速率，单位是 Kbit/sec。对于多人分享的带宽，这个参数可以留出一部分带宽供其他人使用。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ scp -l <span class=m>80</span> yourusername@yourserver:/home/yourusername/* .
</span></span></code></pre></td></tr></table></div></div><p>上面代码中，<code>scp</code>命令占用的带宽限制为每秒 80K 比特位，即每秒 10K 字节。</p><p><strong>（6）<code>-p</code></strong></p><p><code>-p</code>参数用来保留修改时间（modification time）、访问时间（access time）、文件状态（mode）等原始文件的信息。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ scp -p ~/test.txt root@192.168.1.3:/some/path/test.txt
</span></span></code></pre></td></tr></table></div></div><p><strong>（7）<code>-P</code></strong></p><p><code>-P</code>参数用来指定远程主机的 SSH 端口。如果远程主机使用默认端口22，可以不用指定，否则需要用<code>-P</code>参数在命令中指定。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ scp -P <span class=m>2222</span> user@host:directory/SourceFile TargetFile
</span></span></code></pre></td></tr></table></div></div><p><strong>（8）<code>-q</code></strong></p><p><code>-q</code>参数用来关闭显示拷贝的进度条。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ scp -q Label.pdf mrarianto@202.x.x.x:.
</span></span></code></pre></td></tr></table></div></div><p><strong>（9）<code>-r</code></strong></p><p><code>-r</code>参数表示是否以递归方式复制目录。</p><p><strong>（10）<code>-v</code></strong></p><p><code>-v</code>参数用来显示详细的输出。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ scp -v ~/test.txt root@192.168.1.3:/root/help2356.txt
</span></span></code></pre></td></tr></table></div></div><hr><h2 id=sftp-命令>sftp 命令</h2><p>FTP（File Transfer Protocol，文件传输协议），提供文件的上传和下载功能。<code>sftp</code>是基于SSH协议的文件传输协议，提供了加密和认证功能。</p><p><code>sftp</code>是 SSH 提供的一个客户端应用程序（<strong>意味着认证方式通用</strong>），主要用来安全地访问 FTP。因为 FTP 是不加密协议，很不安全，<code>sftp</code>就相当于将 FTP 放入了 SSH。</p><p>下面的命令连接 FTP 主机：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ sftp username@hostname
</span></span></code></pre></td></tr></table></div></div><p>执行上面的命令，会要求输入 FTP 的密码。密码验证成功以后，就会出现 FTP 的提示符<code>sftp> </code>，下面是一个例子：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ sftp USER@penguin.example.com
</span></span><span class=line><span class=cl>USER@penguin.example.com<span class=err>&#39;</span>s password:
</span></span><span class=line><span class=cl>Connected to penguin.example.com.
</span></span><span class=line><span class=cl>sftp&gt;
</span></span></code></pre></td></tr></table></div></div><p>FTP 的提示符下面，就可以输入各种 FTP 命令了，这部分完全跟传统的 FTP 用法完全一样：</p><ul><li><p><code>ls [directory]</code>：列出一个远程目录的内容。如果没有指定目标目录，则默认列出当前目录。</p></li><li><p><code>cd directory</code>：从当前目录改到指定目录。</p></li><li><p><code>mkdir directory</code>：创建一个远程目录。</p></li><li><p><code>rmdir path</code>：删除一个远程目录。</p></li><li><p><code>put localfile [remotefile]</code>：本地文件传输到远程主机。</p><ul><li>需要注意的是远程主机的工作目录是当前用户的主目录。本地主机是当前目录。<ul><li>所以可以相互省略工作目录</li><li><code>put [filename]</code>：上传文件。</li></ul></li></ul></li><li><p><code>get remotefile [localfile]</code>：远程文件传输到本地。</p><ul><li>这里可以省略本地主机当前目录，默认为本地主机当前目录。</li><li>目录加<code>-r</code>选项。</li><li><code>get [filename]</code>：下载文件。</li></ul></li><li><p><code>bye</code>：退出 sftp。</p></li><li><p><code>quit</code>：退出 sftp。</p></li><li><p><code>exit</code>：退出 sftp。</p></li><li><p><code>help</code>：显示帮助信息。</p><ul><li>更多命令基本与Linux通用。</li></ul></li></ul><hr><h2 id=rsync-命令>rsync 命令</h2><h3 id=简介-2>简介</h3><p>rsync 是一个常用的 Linux 应用程序，<strong>用于文件同步</strong>。</p><p>它可以在本地计算机与远程计算机之间，或者两个本地目录之间同步文件（但不支持两台远程计算机之间的同步）。它也可以当作文件复制工具，替代<code>cp</code>和<code>mv</code>命令。与<code>scp</code>类似。</p><p>它名称里面的<code>r</code>指的是 remote，rsync 其实就是“远程同步”（remote sync）的意思。与其他文件传输工具（如 FTP 或 scp）不同，rsync 的最大特点是会检查发送方和接收方已有的文件，<strong>仅传输有变动的部分</strong>（默认规则是文件大小或修改时间有变动）。</p><p>虽然 rsync 不是 SSH 工具集的一部分，但因为也涉及到远程操作，所以放在这里一起介绍。</p><p><code>rsync</code>具有以下主要特性：</p><ul><li><strong>增量传输</strong>：只传输源和目标之间的差异，而不是整个文件或目录。</li><li><strong>快速</strong>：通过采用一种叫做“快速检查算法”（rolling checksum）的方法，它可以快速找到文件的差异。</li><li><strong>灵活</strong>：支持各种不同的传输模式，包括本地到本地、本地到远程、远程到本地。</li><li><strong>安全</strong>：可以通过SSH协议传输数据，保证数据的安全性。</li><li><strong>支持软链接、硬链接和设备文件</strong>：在同步过程中，能够保留这些文件的属性。</li><li><strong>可断点续传</strong>：在传输中断后，能够从中断点继续。</li><li><strong>文件权限和所有权保留</strong>：能够保留文件的权限、所有者和时间戳信息。</li><li><strong>广泛的选项和参数</strong>：提供了丰富的选项和参数来满足各种需求。</li></ul><h3 id=安装>安装</h3><p>如果本机或者远程计算机没有安装 rsync，可以用下面的命令安装:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Debian/Ubuntu</span>
</span></span><span class=line><span class=cl>$ sudo apt install rsync
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># CentOS/RHEL</span>
</span></span><span class=line><span class=cl>$ sudo yum install rsync
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># CentOS 8及之后的版本(包括RHEL 8)/Fedora</span>
</span></span><span class=line><span class=cl>$ sudo dnf install rsync
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Arch Linux/Windows msys2</span>
</span></span><span class=line><span class=cl>$ sudo pacman -S rsync
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># macOS</span>
</span></span><span class=line><span class=cl>$ brew install rsync
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># FreeBSD</span>
</span></span><span class=line><span class=cl>sudo pkg install rsync
</span></span></code></pre></td></tr></table></div></div><p><strong>注意</strong>，传输的双方都必须安装 rsync。</p><h3 id=基本用法-3>基本用法</h3><p><code>rsync</code>的基本语法如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>rsync <span class=o>[</span>options<span class=o>]</span> <span class=nb>source</span> destination
</span></span></code></pre></td></tr></table></div></div><p><strong>source</strong>：源文件或目录的路径。</p><p><strong>destination</strong>：目标文件或目录的路径。</p><p>远程主机在路径前加<code>usname@hostname:</code>，与<code>scp</code>一样。</p><p>rsync 可以用于本地计算机的两个目录之间的同步。下面就用<strong>本地同步举例</strong>，顺便讲解 rsync 几个主要参数的用法:</p><p><code>-v</code>：显示详细的输出信息。</p><p><code>-r</code>参数</p><p>本机使用 rsync 命令时，可以作为<code>cp</code>和<code>mv</code>命令的替代方法，将源目录拷贝到目标目录:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ rsync -r <span class=nb>source</span> destination
</span></span></code></pre></td></tr></table></div></div><p>上面命令中，<code>-r</code>表示递归，即包含子目录。注意，<code>-r</code>是必须的，否则 rsync 运行不会成功。<code>source</code>目录表示源目录，<code>destination</code>表示目标目录。上面命令执行以后，目标目录下就会出现<code>destination/source</code>这个子目录。</p><p>如果有多个文件或目录需要同步，可以写成下面这样:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ rsync -r source1 source2 destination
</span></span></code></pre></td></tr></table></div></div><p>上面命令中，<code>source1</code>、<code>source2</code>都会被同步到<code>destination</code>目录。</p><p><code>-a</code>参数</p><p><code>-a</code>参数可以替代<code>-r</code>，除了可以递归同步以外，还可以同步元信息（比如修改时间、权限等）。由于 rsync 默认使用文件大小和修改时间决定文件是否需要更新，所以<code>-a</code>比<code>-r</code>更有用。下面的用法才是常见的写法:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ rsync -a <span class=nb>source</span> destination
</span></span></code></pre></td></tr></table></div></div><p>目标目录<code>destination</code>如果不存在，rsync 会自动创建。执行上面的命令后，源目录<code>source</code>被完整地复制到了目标目录<code>destination</code>下面，即形成了<code>destination/source</code>的目录结构。</p><p>如果只想同步源目录<code>source</code>里面的内容到目标目录<code>destination</code>，则需要在源目录后面加上斜杠:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ rsync -a source/ destination
</span></span></code></pre></td></tr></table></div></div><p>上面命令执行后，<code>source</code>目录里面的内容，就都被复制到了<code>destination</code>目录里面，并不会在<code>destination</code>下面创建一个<code>source</code>子目录。</p><p><code>-n</code>参数</p><p>如果不确定 rsync 执行后会产生什么结果，可以先用<code>-n</code>或<code>--dry-run</code>参数模拟执行的结果：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ rsync -anv source/ destination
</span></span></code></pre></td></tr></table></div></div><p>上面命令中，<code>-n</code>参数模拟命令执行的结果，并不真的执行命令。<code>-v</code>参数则是将结果输出到终端，这样就可以看到哪些内容会被同步。</p><p><code>--delete</code>参数</p><p>默认情况下，rsync 只确保源目录的所有内容（明确排除的文件除外）都复制到目标目录。它不会使两个目录保持相同，并且不会删除文件。如果要使得目标目录成为源目录的镜像副本，则必须使用<code>--delete</code>参数，这将删除只存在于目标目录、不存在于源目录的文件。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ rsync -av --delete source/ destination
</span></span></code></pre></td></tr></table></div></div><p>上面命令中，<code>--delete</code>参数会使得<code>destination</code>成为<code>source</code>的一个镜像。</p><h3 id=排除文件>排除文件</h3><p><code>--exclude</code>参数</p><p>有时，我们希望同步时排除某些文件或目录，这时可以用<code>--exclude</code>参数指定排除模式：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ rsync -av --exclude<span class=o>=</span><span class=s1>&#39;*.txt&#39;</span> source/ destination
</span></span><span class=line><span class=cl><span class=c1># 或者</span>
</span></span><span class=line><span class=cl>$ rsync -av --exclude <span class=s1>&#39;*.txt&#39;</span> source/ destination
</span></span></code></pre></td></tr></table></div></div><p>上面命令排除了所有 TXT 文件。</p><p>注意，rsync 会同步以“点”开头的隐藏文件，如果要排除隐藏文件，可以这样写<code>--exclude=".*"</code>。</p><p>如果要排除某个目录里面的所有文件，但不希望排除目录本身，可以写成下面这样：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ rsync -av --exclude <span class=s1>&#39;dir1/*&#39;</span> source/ destination
</span></span></code></pre></td></tr></table></div></div><p>多个排除模式，可以用多个<code>--exclude</code>参数：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ rsync -av --exclude <span class=s1>&#39;file1.txt&#39;</span> --exclude <span class=s1>&#39;dir1/*&#39;</span> source/ destination
</span></span></code></pre></td></tr></table></div></div><p>多个排除模式也可以利用 Bash 的大扩号的扩展功能，只用一个<code>--exclude</code>参数：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ rsync -av --exclude<span class=o>={</span><span class=s1>&#39;file1.txt&#39;</span>,<span class=s1>&#39;dir1/*&#39;</span><span class=o>}</span> source/ destination
</span></span></code></pre></td></tr></table></div></div><p>如果排除模式很多，可以将它们写入一个文件，每个模式一行，然后用<code>--exclude-from</code>参数指定这个文件：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ rsync -av --exclude-from<span class=o>=</span><span class=s1>&#39;exclude-file.txt&#39;</span> source/ destination
</span></span></code></pre></td></tr></table></div></div><p><code>--include</code>参数</p><p><code>--include</code>参数用来指定必须同步的文件模式，往往与<code>--exclude</code>结合使用：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ rsync -av --include<span class=o>=</span><span class=s2>&#34;*.txt&#34;</span> --exclude<span class=o>=</span><span class=s1>&#39;*&#39;</span> source/ destination
</span></span></code></pre></td></tr></table></div></div><p>上面命令指定同步时，排除所有文件，但是会包括 TXT 文件。</p><h3 id=远程同步>远程同步</h3><h4 id=ssh-协议>SSH 协议</h4><p>rsync 除了支持本地两个目录之间的同步，也支持远程同步。它可以将本地内容，同步到远程服务器：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ rsync -av source/ username@remote_host:destination
</span></span></code></pre></td></tr></table></div></div><p>也可以将远程内容同步到本地：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ rsync -av username@remote_host:source/ destination
</span></span></code></pre></td></tr></table></div></div><p>rsync 默认使用 SSH 进行远程登录和数据传输。</p><p>由于早期 rsync 不使用 SSH 协议，需要用<code>-e</code>参数指定协议，后来才改的。所以，下面<code>-e ssh</code>可以省略：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ rsync -av -e ssh source/ user@remote_host:/destination
</span></span></code></pre></td></tr></table></div></div><p>但是，如果 ssh 命令有附加的参数，则必须使用<code>-e</code>参数指定所要执行的 SSH 命令：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ rsync -av -e <span class=s1>&#39;ssh -p 2234&#39;</span> source/ user@remote_host:/destination
</span></span></code></pre></td></tr></table></div></div><p>上面命令中，<code>-e</code>参数指定 SSH 使用2234端口。</p><h4 id=rsync-协议>rsync 协议</h4><p>除了使用 SSH，如果另一台服务器安装并运行了 rsync 守护程序，则也可以用<code>rsync://</code>协议（默认端口873）进行传输。具体写法是服务器与目标目录之间使用双冒号分隔<code>::</code>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ rsync -av source/ 192.168.122.32::module/destination
</span></span></code></pre></td></tr></table></div></div><p>注意，上面地址中的<code>module</code>并不是实际路径名，而是 rsync 守护程序指定的一个资源名，由管理员分配。</p><p>如果想知道 rsync 守护程序分配的所有 module 列表，可以执行下面命令：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ rsync rsync://192.168.122.32
</span></span></code></pre></td></tr></table></div></div><p>rsync 协议除了使用双冒号，也可以直接用<code>rsync://</code>协议指定地址：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ rsync -av source/ rsync://192.168.122.32/module/destination
</span></span></code></pre></td></tr></table></div></div><h3 id=增量备份>增量备份</h3><p>rsync 的最大特点就是它可以完成增量备份，也就是默认只复制有变动的文件。</p><p>除了源目录与目标目录直接比较，rsync 还支持使用基准目录，即将源目录与基准目录之间变动的部分，同步到目标目录。</p><p>具体做法是，第一次同步是全量备份，所有文件在基准目录里面同步一份。以后每一次同步都是增量备份，只同步源目录与基准目录之间有变动的部分，将这部分保存在一个新的目标目录。这个新的目标目录之中，也是包含所有文件，但实际上，只有那些变动过的文件是存在于该目录，其他没有变动的文件都是指向基准目录文件的硬链接。</p><p><code>--link-dest</code>参数用来指定同步时的基准目录：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ rsync -a --delete --link-dest /compare/path /source/path /target/path
</span></span></code></pre></td></tr></table></div></div><p>上面命令中，<code>--link-dest</code>参数指定基准目录<code>/compare/path</code>，然后源目录<code>/source/path</code>跟基准目录进行比较，找出变动的文件，将它们拷贝到目标目录<code>/target/path</code>。那些没变动的文件则会生成硬链接。这个命令的第一次备份时是全量备份，后面就都是增量备份了。</p><p>下面是一个脚本示例，备份用户的主目录：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=cp>#!/bin/bash
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1># A script to perform incremental backups using rsync</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>set</span> -o errexit
</span></span><span class=line><span class=cl><span class=nb>set</span> -o nounset
</span></span><span class=line><span class=cl><span class=nb>set</span> -o pipefail
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>readonly</span> <span class=nv>SOURCE_DIR</span><span class=o>=</span><span class=s2>&#34;</span><span class=si>${</span><span class=nv>HOME</span><span class=si>}</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl><span class=nb>readonly</span> <span class=nv>BACKUP_DIR</span><span class=o>=</span><span class=s2>&#34;/mnt/data/backups&#34;</span>
</span></span><span class=line><span class=cl><span class=nb>readonly</span> <span class=nv>DATETIME</span><span class=o>=</span><span class=s2>&#34;</span><span class=k>$(</span>date <span class=s1>&#39;+%Y-%m-%d_%H:%M:%S&#39;</span><span class=k>)</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl><span class=nb>readonly</span> <span class=nv>BACKUP_PATH</span><span class=o>=</span><span class=s2>&#34;</span><span class=si>${</span><span class=nv>BACKUP_DIR</span><span class=si>}</span><span class=s2>/</span><span class=si>${</span><span class=nv>DATETIME</span><span class=si>}</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl><span class=nb>readonly</span> <span class=nv>LATEST_LINK</span><span class=o>=</span><span class=s2>&#34;</span><span class=si>${</span><span class=nv>BACKUP_DIR</span><span class=si>}</span><span class=s2>/latest&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>mkdir -p <span class=s2>&#34;</span><span class=si>${</span><span class=nv>BACKUP_DIR</span><span class=si>}</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>rsync -av --delete <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  <span class=s2>&#34;</span><span class=si>${</span><span class=nv>SOURCE_DIR</span><span class=si>}</span><span class=s2>/&#34;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  --link-dest <span class=s2>&#34;</span><span class=si>${</span><span class=nv>LATEST_LINK</span><span class=si>}</span><span class=s2>&#34;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  --exclude<span class=o>=</span><span class=s2>&#34;.cache&#34;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  <span class=s2>&#34;</span><span class=si>${</span><span class=nv>BACKUP_PATH</span><span class=si>}</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>rm -rf <span class=s2>&#34;</span><span class=si>${</span><span class=nv>LATEST_LINK</span><span class=si>}</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>ln -s <span class=s2>&#34;</span><span class=si>${</span><span class=nv>BACKUP_PATH</span><span class=si>}</span><span class=s2>&#34;</span> <span class=s2>&#34;</span><span class=si>${</span><span class=nv>LATEST_LINK</span><span class=si>}</span><span class=s2>&#34;</span>
</span></span></code></pre></td></tr></table></div></div><p>上面脚本中，每一次同步都会生成一个新目录<code>${BACKUP_DIR}/${DATETIME}</code>，并将软链接<code>${BACKUP_DIR}/latest</code>指向这个目录。下一次备份时，就将<code>${BACKUP_DIR}/latest</code>作为基准目录，生成新的备份目录。最后，再将软链接<code>${BACKUP_DIR}/latest</code>指向新的备份目录。</p><h3 id=配置项-2>配置项</h3><p><code>-a</code>、<code>--archive</code>参数表示存档模式，保存所有的元数据，比如修改时间（modification time）、权限、所有者等，并且软链接也会同步过去。</p><p><code>--append</code>参数指定文件接着上次中断的地方，继续传输。</p><p><code>--append-verify</code>参数跟<code>--append</code>参数类似，但会对传输完成后的文件进行一次校验。如果校验失败，将重新发送整个文件。</p><p><code>-b</code>、<code>--backup</code>参数指定在删除或更新目标目录已经存在的文件时，将该文件更名后进行备份，默认行为是删除。更名规则是添加由<code>--suffix</code>参数指定的文件后缀名，默认是<code>~</code>。</p><p><code>--backup-dir</code>参数指定文件备份时存放的目录，比如<code>--backup-dir=/path/to/backups</code>。</p><p><code>--bwlimit</code>参数指定带宽限制，默认单位是 KB/s，比如<code>--bwlimit=100</code>。</p><p><code>-c</code>、<code>--checksum</code>参数改变<code>rsync</code>的校验方式。默认情况下，rsync 只检查文件的大小和最后修改日期是否发生变化，如果发生变化，就重新传输；使用这个参数以后，则通过判断文件内容的校验和，决定是否重新传输。</p><p><code>--delete</code>参数删除只存在于目标目录、不存在于源目标的文件，即保证目标目录是源目标的镜像。</p><p><code>-e</code>参数指定使用 SSH 协议传输数据。</p><p><code>--exclude</code>参数指定排除不进行同步的文件，比如<code>--exclude="*.iso"</code>。</p><p><code>--exclude-from</code>参数指定一个本地文件，里面是需要排除的文件模式，每个模式一行。</p><p><code>--existing</code>、<code>--ignore-non-existing</code>参数表示不同步目标目录中不存在的文件和目录。</p><p><code>-h</code>参数表示以人类可读的格式输出。</p><p><code>-h</code>、<code>--help</code>参数返回帮助信息。</p><p><code>-i</code>参数表示输出源目录与目标目录之间文件差异的详细情况。</p><p><code>--ignore-existing</code>参数表示只要该文件在目标目录中已经存在，就跳过去，不再同步这些文件。</p><p><code>--include</code>参数指定同步时要包括的文件，一般与<code>--exclude</code>结合使用。</p><p><code>--link-dest</code>参数指定增量备份的基准目录。</p><p><code>-m</code>参数指定不同步空目录。</p><p><code>--max-size</code>参数设置传输的最大文件的大小限制，比如不超过200KB（<code>--max-size='200k'</code>）。</p><p><code>--min-size</code>参数设置传输的最小文件的大小限制，比如不小于10KB（<code>--min-size=10k</code>）。</p><p><code>-n</code>参数或<code>--dry-run</code>参数模拟将要执行的操作，而并不真的执行。配合<code>-v</code>参数使用，可以看到哪些内容会被同步过去。</p><p><code>-P</code>参数是<code>--progress</code>和<code>--partial</code>这两个参数的结合。</p><p><code>--partial</code>参数允许恢复中断的传输。不使用该参数时，<code>rsync</code>会删除传输到一半被打断的文件；使用该参数后，传输到一半的文件也会同步到目标目录，下次同步时再恢复中断的传输。一般需要与<code>--append</code>或<code>--append-verify</code>配合使用。</p><p><code>--partial-dir</code>参数指定将传输到一半的文件保存到一个临时目录，比如<code>--partial-dir=.rsync-partial</code>。一般需要与<code>--append</code>或<code>--append-verify</code>配合使用。</p><p><code>--progress</code>参数表示显示进展。</p><p><code>-r</code>参数表示递归，即包含子目录。</p><p><code>--remove-source-files</code>参数表示传输成功后，删除发送方的文件。</p><p><code>--size-only</code>参数表示只同步大小有变化的文件，不考虑文件修改时间的差异。</p><p><code>--suffix</code>参数指定文件名备份时，对文件名添加的后缀，默认是<code>~</code>。</p><p><code>-u</code>、<code>--update</code>参数表示同步时跳过目标目录中修改时间更新的文件，即不同步这些有更新的时间戳的文件。</p><p><code>-v</code>参数表示输出细节。<code>-vv</code>表示输出更详细的信息，<code>-vvv</code>表示输出最详细的信息。</p><p><code>--version</code>参数返回 rsync 的版本。</p><p><code>-z</code>参数指定同步时压缩数据。</p><h3 id=参考链接-1>参考链接</h3><ul><li><a class=link href=https://www.digitalocean.com/community/tutorials/how-to-use-rsync-to-sync-local-and-remote-directories-on-a-vps target=_blank rel=noopener>How To Use Rsync to Sync Local and Remote Directories on a VPS</a>, Justin Ellingwood</li><li><a class=link href=https://www.howtoforge.com/mirroring_with_rsync target=_blank rel=noopener>Mirror Your Web Site With rsync</a>, Falko Timme</li><li><a class=link href=https://linuxconfig.org/examples-on-how-to-use-rsync-for-local-and-remote-data-backups-and-synchonization target=_blank rel=noopener>Examples on how to use Rsync</a>, Egidio Docile</li><li><a class=link href=https://linuxconfig.org/how-to-create-incremental-backups-using-rsync-on-linux target=_blank rel=noopener>How to create incremental backups using rsync on Linux</a>, Egidio Docile</li></ul><hr><h2 id=ssh-服务器>SSH 服务器</h2><h3 id=简介-3>简介</h3><p>SSH 的架构是服务器/客户端模式，两端运行的软件是不一样的。OpenSSH 的客户端软件是 ssh，服务器软件是 sshd。本章介绍 sshd 的各种知识。</p><p>如果没有安装 sshd，可以用下面的命令安装:</p><p><strong>在Linux上安装SSH服务端</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1># Debian/Ubuntu</span>
</span></span><span class=line><span class=cl>$ sudo apt install openssh-server
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># CentOS/RHEL</span>
</span></span><span class=line><span class=cl>$ sudo yum install openssh-server
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Fedora</span>
</span></span><span class=line><span class=cl>$ sudo dnf install openssh-server
</span></span></code></pre></td></tr></table></div></div><p><strong>在macOS上安装SSH服务端</strong></p><p>macOS内置了OpenSSH服务端，但默认情况下它是关闭的。可以通过以下步骤启用：</p><ol><li>打开“系统偏好设置”。</li><li>进入“共享”设置。</li><li>勾选“远程登录”选项。</li><li>选择允许哪些用户可以通过SSH登录。</li></ol><p>之后，SSH服务端将开始运行，你可以使用SSH客户端连接到你的macOS机器。</p><p><strong>在Windows上安装SSH服务端</strong></p><p>从Windows 10版本1809开始，Windows内置了OpenSSH Server。可以通过以下步骤启用：</p><ol><li><p>打开“设置” > “应用” > “可选功能”。</p></li><li><p>向下滚动并点击“添加功能”。</p></li><li><p>在列表中找到并安装“OpenSSH Server”。</p></li><li><p>安装完成后，打开PowerShell并启动SSH服务：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-powershell data-lang=powershell><span class=line><span class=cl><span class=nb>Start-Service</span> <span class=n>sshd</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>使SSH服务在开机时自动启动：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-powershell data-lang=powershell><span class=line><span class=cl><span class=nb>Set-Service</span> <span class=n>-Name</span> <span class=n>sshd</span> <span class=n>-StartupType</span> <span class=s1>&#39;Automatic&#39;</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>如果需要检查服务状态：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-powershell data-lang=powershell><span class=line><span class=cl><span class=nb>Get-Service</span> <span class=n>-Name</span> <span class=n>sshd</span>
</span></span></code></pre></td></tr></table></div></div></li></ol><p>一般来说，sshd 安装后会跟着系统一起启动。如果当前 sshd 没有启动，可以用下面的命令启动。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ sshd
</span></span></code></pre></td></tr></table></div></div><p>上面的命令运行后，如果提示“sshd re-exec requires execution with an absolute path”，就需要使用绝对路径来启动。这是为了防止有人出于各种目的，放置同名软件在<code>$PATH</code>变量指向的目录中，代替真正的 sshd:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1># Centos、Ubuntu、OS X</span>
</span></span><span class=line><span class=cl>$ /usr/sbin/sshd
</span></span></code></pre></td></tr></table></div></div><p>上面的命令运行以后，sshd 自动进入后台，所以命令后面不需要加上<code>&</code>。</p><p>除了直接运行可执行文件，也可以通过 Systemd 启动 sshd:</p><p>启动SSH服务并使其在开机时自动启动：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1># Debian/Ubuntu</span>
</span></span><span class=line><span class=cl>sudo systemctl start ssh
</span></span><span class=line><span class=cl>sudo systemctl <span class=nb>enable</span> ssh 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># CentOS/RHEL/Fedora</span>
</span></span><span class=line><span class=cl>sudo systemctl start sshd
</span></span><span class=line><span class=cl>sudo systemctl <span class=nb>enable</span> sshd
</span></span></code></pre></td></tr></table></div></div><p>检查SSH服务的状态：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1># Debian/Ubuntu</span>
</span></span><span class=line><span class=cl>sudo systemctl status ssh
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># CentOS/RHEL/Fedora</span>
</span></span><span class=line><span class=cl>sudo systemctl status sshd
</span></span></code></pre></td></tr></table></div></div><p>重启SSH服务：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1># Debian/Ubuntu</span>
</span></span><span class=line><span class=cl>$ sudo systemctl restart ssh
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># CentOS/RHEL/Fedora</span>
</span></span><span class=line><span class=cl>$ sudo systemctl restart sshd
</span></span></code></pre></td></tr></table></div></div><h3 id=sshd-配置文件>sshd 配置文件</h3><p>sshd 的配置文件在<code>/etc/ssh</code>目录，主配置文件是<code>sshd_config</code>，此外还有一些安装时生成的密钥：</p><ul><li><code>/etc/ssh/sshd_config</code>：配置文件</li><li><code>/etc/ssh/ssh_host_ecdsa_key</code>：ECDSA 私钥。</li><li><code>/etc/ssh/ssh_host_ecdsa_key.pub</code>：ECDSA 公钥。</li><li><code>/etc/ssh/ssh_host_key</code>：用于 SSH 1 协议版本的 RSA 私钥。</li><li><code>/etc/ssh/ssh_host_key.pub</code>：用于 SSH 1 协议版本的 RSA 公钥。</li><li><code>/etc/ssh/ssh_host_rsa_key</code>：用于 SSH 2 协议版本的 RSA 私钥。</li><li><code>/etc/ssh/ssh_host_rsa_key.pub</code>：用于 SSH 2 协议版本的 RSA 公钥。</li><li><code>/etc/pam.d/sshd</code>：PAM 配置文件。</li></ul><p>注意，如果重装 sshd，上面这些密钥都会重新生成，导致客户端重新连接 ssh 服务器时，会跳出警告，拒绝连接。为了避免这种情况，可以在重装 sshd 时，先备份<code>/etc/ssh</code>目录，重装后再恢复这个目录。</p><p>配置文件<code>sshd_config</code>的格式是，每个命令占据一行。每行都是配置项和对应的值，配置项的大小写不敏感，与值之间使用空格分隔。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>Port <span class=m>2034</span>
</span></span></code></pre></td></tr></table></div></div><p>上面的配置命令指定，配置项<code>Port</code>的值是<code>2034</code>。<code>Port</code>写成<code>port</code>也可。</p><p>配置文件还有另一种格式，就是配置项与值之间有一个等号，等号前后的空格可选。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nv>Port</span> <span class=o>=</span> <span class=m>2034</span>
</span></span></code></pre></td></tr></table></div></div><p>配置文件里面，<code>#</code>开头的行表示注释。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 这是一行注释</span>
</span></span></code></pre></td></tr></table></div></div><p>注意，注释只能放在一行的开头，不能放在一行的结尾。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>Port <span class=m>2034</span> <span class=c1># 此处不允许注释</span>
</span></span></code></pre></td></tr></table></div></div><p>上面的写法是错误的。</p><p>另外，空行等同于注释。</p><p>sshd 启动时会自动读取默认的配置文件。如果希望使用其他的配置文件，可以用 sshd 命令的<code>-f</code>参数指定。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ sshd -f /usr/local/ssh/my_config
</span></span></code></pre></td></tr></table></div></div><p>上面的命令指定 sshd 使用另一个配置文件<code>my_config</code>。</p><p>修改配置文件以后，可以用 sshd 命令的<code>-t</code>（test）检查有没有语法错误。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ sshd -t
</span></span></code></pre></td></tr></table></div></div><p>配置文件修改以后，并不会自动生效，必须重新启动 sshd。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ sudo systemctl restart sshd
</span></span></code></pre></td></tr></table></div></div><h3 id=sshd-密钥>sshd 密钥</h3><p>sshd 有自己的一对或多对密钥。<strong>它使用密钥向客户端证明自己的身份</strong>。所有密钥都是公钥和私钥成对出现，公钥的文件名一般是私钥文件名加上后缀<code>.pub</code>。</p><p>DSA 格式的密钥文件默认为<code>/etc/ssh/ssh_host_dsa_key</code>（公钥为<code>ssh_host_dsa_key.pub</code>），RSA 格式的密钥为<code>/etc/ssh/ssh_host_rsa_key</code>（公钥为<code>ssh_host_rsa_key.pub</code>）。如果需要支持 SSH 1 协议，则必须有密钥<code>/etc/ssh/ssh_host_key</code>。</p><p>如果密钥不是默认文件，那么可以通过配置文件<code>sshd_config</code>的<code>HostKey</code>配置项指定。默认密钥的<code>HostKey</code>设置如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># HostKey for protocol version 1</span>
</span></span><span class=line><span class=cl><span class=c1># HostKey /etc/ssh/ssh_host_key</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># HostKeys for protocol version 2</span>
</span></span><span class=line><span class=cl><span class=c1># HostKey /etc/ssh/ssh_host_rsa_key</span>
</span></span><span class=line><span class=cl><span class=c1># HostKey /etc/ssh/ssh_host_dsa_key</span>
</span></span></code></pre></td></tr></table></div></div><p>上面命令前面的<code>#</code>表示这些行都是注释，因为这是默认值，有没有这几行都一样。</p><p>如果要修改密钥，就要去掉行首的<code>#</code>，指定其他密钥。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>HostKey /usr/local/ssh/my_dsa_key
</span></span><span class=line><span class=cl>HostKey /usr/local/ssh/my_rsa_key
</span></span><span class=line><span class=cl>HostKey /usr/local/ssh/my_old_ssh1_key
</span></span></code></pre></td></tr></table></div></div><h3 id=sshd-配置项>sshd 配置项</h3><p>以下是<code>/etc/ssh/sshd_config</code>文件里面的配置项：</p><p><strong>AcceptEnv</strong></p><p><code>AcceptEnv</code>指定允许接受客户端通过<code>SendEnv</code>命令发来的哪些环境变量，即允许客户端设置服务器的环境变量清单，变量名之间使用空格分隔（<code>AcceptEnv PATH TERM</code>）。</p><p><strong>AllowGroups</strong></p><p><code>AllowGroups</code>指定允许登录的用户组（<code>AllowGroups groupName</code>，多个组之间用空格分隔。如果不使用该项，则允许所有用户组登录。</p><p><strong>AllowUsers</strong></p><p><code>AllowUsers</code>指定允许登录的用户，用户名之间使用空格分隔（<code>AllowUsers user1 user2</code>），也可以使用多行<code>AllowUsers</code>命令指定，用户名支持使用通配符。如果不使用该项，则允许所有用户登录。该项也可以使用<code>用户名@域名</code>的格式（比如<code>AllowUsers jones@example.com</code>）。</p><p><strong>AllowTcpForwarding</strong></p><p><code>AllowTcpForwarding</code>指定是否允许端口转发，默认值为<code>yes</code>（<code>AllowTcpForwarding yes</code>），<code>local</code>表示只允许本地端口转发，<code>remote</code>表示只允许远程端口转发。</p><p><strong>AuthorizedKeysFile</strong></p><p><code>AuthorizedKeysFile</code>指定储存用户公钥的目录，默认是用户主目录的<code>ssh/authorized_keys</code>目录（<code>AuthorizedKeysFile .ssh/authorized_keys</code>）。</p><p><strong>Banner</strong></p><p><code>Banner</code>指定用户登录后，sshd 向其展示的信息文件（<code>Banner /usr/local/etc/warning.txt</code>），默认不展示任何内容。</p><p><strong>ChallengeResponseAuthentication</strong></p><p><code>ChallengeResponseAuthentication</code>指定是否使用“键盘交互”身份验证方案，默认值为<code>yes</code>（<code>ChallengeResponseAuthentication yes</code>）。</p><p>从理论上讲，“键盘交互”身份验证方案可以向用户询问多重问题，但是实践中，通常仅询问用户密码。如果要完全禁用基于密码的身份验证，请将<code>PasswordAuthentication</code>和<code>ChallengeResponseAuthentication</code>都设置为<code>no</code>。</p><p><strong>Ciphers</strong></p><p><code>Ciphers</code>指定 sshd 可以接受的加密算法（<code>Ciphers 3des-cbc</code>），多个算法之间使用逗号分隔。</p><p><strong>ClientAliveCountMax</strong></p><p><code>ClientAliveCountMax</code>指定建立连接后，客户端失去响应时，服务器尝试连接的次数（<code>ClientAliveCountMax 8</code>）。</p><p><strong>ClientAliveInterval</strong></p><p><code>ClientAliveInterval</code>指定允许客户端发呆的时间，单位为秒（<code>ClientAliveInterval 180</code>）。如果这段时间里面，客户端没有发送任何信号，SSH 连接将关闭。</p><p><strong>Compression</strong></p><p><code>Compression</code>指定客户端与服务器之间的数据传输是否压缩。默认值为<code>yes</code>（<code>Compression yes</code>）</p><p><strong>DenyGroups</strong></p><p><code>DenyGroups</code>指定不允许登录的用户组（<code>DenyGroups groupName</code>）。</p><p><strong>DenyUsers</strong></p><p><code>DenyUsers</code>指定不允许登录的用户（<code>DenyUsers user1</code>），用户名之间使用空格分隔，也可以使用多行<code>DenyUsers</code>命令指定。</p><p><strong>FascistLogging</strong></p><p>SSH 1 版本专用，指定日志输出全部 Debug 信息（<code>FascistLogging yes</code>）。</p><p><strong>HostKey</strong></p><p><code>HostKey</code>指定 sshd 服务器的密钥，详见前文。</p><p><strong>KeyRegenerationInterval</strong></p><p><code>KeyRegenerationInterval</code>指定 SSH 1 版本的密钥重新生成时间间隔，单位为秒，默认是3600秒（<code>KeyRegenerationInterval 3600</code>）。</p><p><strong>ListenAddress</strong></p><p><code>ListenAddress</code>指定 sshd 监听的本机 IP 地址，即 sshd 启用的 IP 地址，默认是 0.0.0.0（<code>ListenAddress 0.0.0.0</code>）表示在本机所有网络接口启用。可以改成只在某个网络接口启用（比如<code>ListenAddress 192.168.10.23</code>），也可以指定某个域名启用（比如<code>ListenAddress server.example.com</code>）。</p><p>如果要监听多个指定的 IP 地址，可以使用多行<code>ListenAddress</code>命令。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>ListenAddress 172.16.1.1
</span></span><span class=line><span class=cl>ListenAddress 192.168.0.1
</span></span></code></pre></td></tr></table></div></div><p><strong>LoginGraceTime</strong></p><p><code>LoginGraceTime</code>指定允许客户端登录时发呆的最长时间，比如用户迟迟不输入密码，连接就会自动断开，单位为秒（<code>LoginGraceTime 60</code>）。如果设为<code>0</code>，就表示没有限制。</p><p><strong>LogLevel</strong></p><p><code>LogLevel</code>指定日志的详细程度，可能的值依次为<code>QUIET</code>、<code>FATAL</code>、<code>ERROR</code>、<code>INFO</code>、<code>VERBOSE</code>、<code>DEBUG</code>、<code>DEBUG1</code>、<code>DEBUG2</code>、<code>DEBUG3</code>，默认为<code>INFO</code>（<code>LogLevel INFO</code>）。</p><p><strong>MACs</strong></p><p><code>MACs</code>指定sshd 可以接受的数据校验算法（<code>MACs hmac-sha1</code>），多个算法之间使用逗号分隔。</p><p><strong>MaxAuthTries</strong></p><p><code>MaxAuthTries</code>指定允许 SSH 登录的最大尝试次数（<code>MaxAuthTries 3</code>），如果密码输入错误达到指定次数，SSH 连接将关闭。</p><p><strong>MaxStartups</strong></p><p><code>MaxStartups</code>指定允许同时并发的 SSH 连接数量（MaxStartups）。如果设为<code>0</code>，就表示没有限制。</p><p>这个属性也可以设为<code>A:B:C</code>的形式，比如<code>MaxStartups 10:50:20</code>，表示如果达到10个并发连接，后面的连接将有50%的概率被拒绝；如果达到20个并发连接，则后面的连接将100%被拒绝。</p><p><strong>PasswordAuthentication</strong></p><p><code>PasswordAuthentication</code>指定是否允许密码登录，默认值为<code>yes</code>（<code>PasswordAuthentication yes</code>），建议改成<code>no</code>（禁止密码登录，只允许密钥登录）。</p><p><strong>PermitEmptyPasswords</strong></p><p><code>PermitEmptyPasswords</code>指定是否允许空密码登录，即用户的密码是否可以为空，默认为<code>yes</code>（<code>PermitEmptyPasswords yes</code>），建议改成<code>no</code>（禁止无密码登录）。</p><p><strong>PermitRootLogin</strong></p><p><code>PermitRootLogin</code>指定是否允许根用户登录，默认为<code>yes</code>（<code>PermitRootLogin yes</code>），建议改成<code>no</code>（禁止根用户登录）。</p><p>还有一种写法是写成<code>prohibit-password</code>，表示 root 用户不能用密码登录，但是可以用密钥登录。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>PermitRootLogin prohibit-password
</span></span></code></pre></td></tr></table></div></div><p><strong>PermitUserEnvironment</strong></p><p><code>PermitUserEnvironment</code>指定是否允许 sshd 加载客户端的<code>~/.ssh/environment</code>文件和<code>~/.ssh/authorized_keys</code>文件里面的<code>environment= options</code>环境变量设置。默认值为<code>no</code>（<code>PermitUserEnvironment no</code>）。</p><p><strong>Port</strong></p><p><code>Port</code>指定 sshd 监听的端口，即客户端连接的端口，默认是22（<code>Port 22</code>）。出于安全考虑，可以改掉这个端口（比如<code>Port 8822</code>）。</p><p>配置文件可以使用多个<code>Port</code>命令，同时监听多个端口。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>Port <span class=m>22</span>
</span></span><span class=line><span class=cl>Port <span class=m>80</span>
</span></span><span class=line><span class=cl>Port <span class=m>443</span>
</span></span><span class=line><span class=cl>Port <span class=m>8080</span>
</span></span></code></pre></td></tr></table></div></div><p>上面的示例表示同时监听4个端口。</p><p><strong>PrintMotd</strong></p><p><code>PrintMotd</code>指定用户登录后，是否向其展示系统的 motd（Message of the day）的信息文件<code>/etc/motd</code>。该文件用于通知所有用户一些重要事项，比如系统维护时间、安全问题等等。默认值为<code>yes</code>（<code>PrintMotd yes</code>），由于 Shell 一般会展示这个信息文件，所以这里可以改为<code>no</code>。</p><p><strong>PrintLastLog</strong></p><p><code>PrintLastLog</code>指定是否打印上一次用户登录时间，默认值为<code>yes</code>（<code>PrintLastLog yes</code>）。</p><p><strong>Protocol</strong></p><p><code>Protocol</code>指定 sshd 使用的协议。<code>Protocol 1</code>表示使用 SSH 1 协议，建议改成<code>Protocol 2</code>（使用 SSH 2 协议）。<code>Protocol 2,1</code>表示同时支持两个版本的协议。</p><p><strong>PubkeyAuthentication</strong></p><p><code>PubkeyAuthentication</code>指定是否允许公钥登录，默认值为<code>yes</code>（<code>PubkeyAuthentication yes</code>）。</p><p><strong>QuietMode</strong></p><p>SSH 1 版本专用，指定日志只输出致命的错误信息（<code>QuietMode yes</code>）。</p><p><strong>RSAAuthentication</strong></p><p><code>RSAAuthentication</code>指定允许 RSA 认证，默认值为<code>yes</code>（<code>RSAAuthentication yes</code>）。</p><p><strong>ServerKeyBits</strong></p><p><code>ServerKeyBits</code>指定 SSH 1 版本的密钥重新生成时的位数，默认是768（<code>ServerKeyBits 768</code>）。</p><p><strong>StrictModes</strong></p><p><code>StrictModes</code>指定 sshd 是否检查用户的一些重要文件和目录的权限。默认为<code>yes</code>（<code>StrictModes yes</code>），即对于用户的 SSH 配置文件、密钥文件和所在目录，SSH 要求拥有者必须是根用户或用户本人，用户组和其他人的写权限必须关闭。</p><p><strong>SyslogFacility</strong></p><p><code>SyslogFacility</code>指定 Syslog 如何处理 sshd 的日志，默认是 Auth（<code>SyslogFacility AUTH</code>）。</p><p><strong>TCPKeepAlive</strong></p><p><code>TCPKeepAlive</code>指定打开 sshd 跟客户端 TCP 连接的 keepalive 参数（<code>TCPKeepAlive yes</code>）。</p><p><strong>UseDNS</strong></p><p><code>UseDNS</code>指定用户 SSH 登录一个域名时，服务器是否使用 DNS，确认该域名对应的 IP 地址包含本机（<code>UseDNS yes</code>）。打开该选项意义不大，而且如果 DNS 更新不及时，还有可能误判，建议关闭。</p><p><strong>UseLogin</strong></p><p><code>UseLogin</code>指定用户认证内部是否使用<code>/usr/bin/login</code>替代 SSH 工具，默认为<code>no</code>（<code>UseLogin no</code>）。</p><p><strong>UserPrivilegeSeparation</strong></p><p><code>UserPrivilegeSeparation</code>指定用户认证通过以后，使用另一个子线程处理用户权限相关的操作，这样有利于提高安全性。默认值为<code>yes</code>（<code>UsePrivilegeSeparation yes</code>）。</p><p><strong>VerboseMode</strong></p><p>SSH 2 版本专用，指定日志输出详细的 Debug 信息（<code>VerboseMode yes</code>）。</p><p><strong>X11Forwarding</strong></p><p><code>X11Forwarding</code>指定是否打开 X window 的转发，默认值为 no（<code>X11Forwarding no</code>）。</p><p>修改配置文件以后，可以使用下面的命令验证，配置文件是否有语法错误。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ sshd -t
</span></span></code></pre></td></tr></table></div></div><p>新的配置文件生效，必须重启 sshd。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ sudo systemctl restart sshd
</span></span></code></pre></td></tr></table></div></div><h3 id=sshd-的命令行配置项>sshd 的命令行配置项</h3><p>sshd 命令有一些配置项。这些配置项在调用时指定，可以覆盖配置文件的设置：</p><p>（1）<code>-d</code></p><p><code>-d</code>参数用于显示 debug 信息。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ sshd -d
</span></span></code></pre></td></tr></table></div></div><p>（2）<code>-D</code></p><p><code>-D</code>参数指定 sshd 不作为后台守护进程运行。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ sshd -D
</span></span></code></pre></td></tr></table></div></div><p>（3）<code>-e</code></p><p><code>-e</code>参数将 sshd 写入系统日志 syslog 的内容导向标准错误（standard error）。</p><p>（4）<code>-f</code></p><p><code>-f</code>参数指定配置文件的位置。</p><p>（5）<code>-h</code></p><p><code>-h</code>参数用于指定密钥。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ sshd -h /usr/local/ssh/my_rsa_key
</span></span></code></pre></td></tr></table></div></div><p>（6）<code>-o</code></p><p><code>-o</code>参数指定配置文件的一个配置项和对应的值。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ sshd -o <span class=s2>&#34;Port 2034&#34;</span>
</span></span></code></pre></td></tr></table></div></div><p>配置项和对应值之间，可以使用等号。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ sshd -o <span class=s2>&#34;Port = 2034&#34;</span>
</span></span></code></pre></td></tr></table></div></div><p>如果省略等号前后的空格，也可以不使用引号。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ sshd -o <span class=nv>Port</span><span class=o>=</span><span class=m>2034</span>
</span></span></code></pre></td></tr></table></div></div><p><code>-o</code>参数可以多个一起使用，用来指定多个配置关键字。</p><p>（7）<code>-p</code></p><p><code>-p</code>参数指定 sshd 的服务端口。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ sshd -p <span class=m>2034</span>
</span></span></code></pre></td></tr></table></div></div><p>上面命令指定 sshd 在<code>2034</code>端口启动。</p><p><code>-p</code>参数可以指定多个端口。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ sshd -p <span class=m>2222</span> -p <span class=m>3333</span>
</span></span></code></pre></td></tr></table></div></div><p>（8）<code>-t</code></p><p><code>-t</code>参数检查配置文件的语法是否正确。</p><hr><h2 id=ssh-日志>SSH 日志</h2><p>SSH 在服务器端可以生成日志，记录登录当前服务器的情况。</p><p>SSH 日志是写在系统日志当中的，查看的时候需要从系统日志里面找到跟 SSH 相关的记录。</p><h3 id=journalctl-命令>journalctl 命令</h3><p>如果系统使用 Systemd，可以使用<code>journalctl</code>命令查看日志:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ journalctl -u ssh
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>Mar <span class=m>25</span> 20:25:36 web0 sshd<span class=o>[</span>14144<span class=o>]</span>: Accepted publickey <span class=k>for</span> ubuntu from 10.103.160.144 port <span class=m>59200</span> ssh2: RSA SHA256:l/zFNib1vJ+64nxLB4N9KaVhBEMf8arbWGxHQg01SW8
</span></span><span class=line><span class=cl>Mar <span class=m>25</span> 20:25:36 web0 sshd<span class=o>[</span>14144<span class=o>]</span>: pam_unix<span class=o>(</span>sshd:session<span class=o>)</span>: session opened <span class=k>for</span> user ubuntu by <span class=o>(</span><span class=nv>uid</span><span class=o>=</span>0<span class=o>)</span>
</span></span><span class=line><span class=cl>Mar <span class=m>25</span> 20:39:12 web0 sshd<span class=o>[</span>14885<span class=o>]</span>: pam_unix<span class=o>(</span>sshd:session<span class=o>)</span>: session closed <span class=k>for</span> user ubuntu
</span></span><span class=line><span class=cl>...
</span></span></code></pre></td></tr></table></div></div><p>上面示例中，返回的日志每一行就是一次登录尝试，按照从早到晚的顺序，其中包含了登录失败的尝试。<code>-u</code>参数是 Unit 单元的意思，<code>-u ssh</code>就是查看 SSH 单元，有的发行版需要写成<code>-u sshd</code>。</p><p><code>-b0</code>参数可以查看自从上次登录后的日志。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ journalctl -u ssh -b0
</span></span></code></pre></td></tr></table></div></div><p><code>-r</code>参数表示逆序输出，最新的在前面。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ journalctl -u ssh -b0 -r
</span></span></code></pre></td></tr></table></div></div><p><code>since</code>和<code>until</code>参数可以指定日志的时间范围。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ journalctl -u ssh --since yesterday <span class=c1># 查看昨天的日志</span>
</span></span><span class=line><span class=cl>$ journalctl -u ssh --since -3d --until -2d <span class=c1># 查看三天前的日志</span>
</span></span><span class=line><span class=cl>$ journalctl -u ssh --since -1h <span class=c1># 查看上个小时的日志</span>
</span></span><span class=line><span class=cl>$ journalctl -u ssh --until <span class=s2>&#34;2022-03-12 07:00:00&#34;</span> <span class=c1># 查看截至到某个时间点的日志</span>
</span></span></code></pre></td></tr></table></div></div><p>下面的命令查看实时日志。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ journalctl -fu ssh
</span></span></code></pre></td></tr></table></div></div><h3 id=其他命令>其他命令</h3><p>如果系统没有使用 Systemd，可以在<code>/var/log/auth.log</code>文件中找到 sshd 的日志。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ sudo grep sshd /var/log/auth.log
</span></span></code></pre></td></tr></table></div></div><p>下面的命令查看最后 500 行里面的 sshd 条目。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ sudo tail -n <span class=m>500</span> /var/log/auth.log <span class=p>|</span> grep sshd
</span></span></code></pre></td></tr></table></div></div><p><code>-f</code>参数可以实时跟踪日志。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ sudo tail -f -n <span class=m>500</span> /var/log/auth.log <span class=p>|</span> grep sshd
</span></span></code></pre></td></tr></table></div></div><p>如果只是想看谁登录了系统，而不是深入查看所有细节，可以使用<code>lastlog</code>命令。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ lastlog
</span></span></code></pre></td></tr></table></div></div><h3 id=日志设置>日志设置</h3><p>sshd 的配置文件<code>/etc/ssh/sshd_config</code>，可以调整日志级别。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>LogLevel VERBOSE
</span></span></code></pre></td></tr></table></div></div><p>如果为了调试，可以将日志调整为 DEBUG。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl> LogLevel DEBUG
</span></span></code></pre></td></tr></table></div></div><hr><h2 id=fail2ban-教程>Fail2Ban 教程</h2><h3 id=简介-4>简介</h3><p>Fail2Ban 是一个 Linux 系统的应用软件，用来防止系统入侵，主要是防止暴力破解系统密码。它是用 Python 开发的。</p><p>它主要通过监控日志文件（比如<code>/var/log/auth.log</code>、<code>/var/log/apache/access.log</code>等）来生效。一旦发现恶意攻击的登录请求，它会封锁对方的 IP 地址，使得对方无法再发起请求。</p><p>Fail2Ban 可以防止有人反复尝试 SSH 密码登录，但是如果 SSH 采用的是密钥登录，禁止了密码登录，就不需要 Fail2Ban 来保护。</p><p>Fail2Ban 的安装命令如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1># ubuntu &amp; Debian</span>
</span></span><span class=line><span class=cl>$ sudo apt install fail2ban
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Fedora</span>
</span></span><span class=line><span class=cl>$ sudo dnf install epel-release
</span></span><span class=line><span class=cl>$ sudo dnf install fail2ban
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Centos &amp; Red hat</span>
</span></span><span class=line><span class=cl>$ yum install epel-release
</span></span><span class=line><span class=cl>$ yum install fail2ban
</span></span></code></pre></td></tr></table></div></div><p>安装后，使用下面的命令查看 Fail2Ban 的状态：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ systemctl status fail2ban
</span></span></code></pre></td></tr></table></div></div><p>如果没有启动，就启动 Fail2Ban：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ sudo systemctl start fail2ban
</span></span></code></pre></td></tr></table></div></div><p>重新启动 Fail2Ban：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ sudo systemctl restart fail2ban
</span></span></code></pre></td></tr></table></div></div><p>设置 Fail2Ban 重启后自动运行：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ sudo systemctl <span class=nb>enable</span> fail2ban
</span></span></code></pre></td></tr></table></div></div><h3 id=fail2ban-client>fail2ban-client</h3><p>Fail2Ban 自带一个客户端 fail2ban-client，用来操作 Fail2Ban：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ fail2ban-client
</span></span></code></pre></td></tr></table></div></div><p>上面的命令会输出 fail2ban-client 所有的用法。</p><p>下面的命令查看激活的监控目标(需要额外配置，后面介绍）：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ fail2ban-client status
</span></span></code></pre></td></tr></table></div></div><p>输出：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>Status
</span></span><span class=line><span class=cl><span class=p>|</span>- Number of jail:	<span class=m>1</span>
</span></span><span class=line><span class=cl><span class=sb>`</span>- Jail list:	sshd
</span></span></code></pre></td></tr></table></div></div><p>下面的命令查看某个监控目标（这里是 sshd）的运行情况：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ sudo fail2ban-client status sshd
</span></span></code></pre></td></tr></table></div></div><p>输出：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>Status <span class=k>for</span> the jail: sshd
</span></span><span class=line><span class=cl><span class=p>|</span>- Filter
</span></span><span class=line><span class=cl><span class=p>|</span>  <span class=p>|</span>- Currently failed: <span class=m>1</span>
</span></span><span class=line><span class=cl><span class=p>|</span>  <span class=p>|</span>- Total failed:     <span class=m>9</span>
</span></span><span class=line><span class=cl><span class=p>|</span>  <span class=sb>`</span>- Journal matches:  <span class=nv>_SYSTEMD_UNIT</span><span class=o>=</span>sshd.service + <span class=nv>_COMM</span><span class=o>=</span>sshd
</span></span><span class=line><span class=cl><span class=sb>`</span>- Actions
</span></span><span class=line><span class=cl>   <span class=p>|</span>- Currently banned: <span class=m>1</span>
</span></span><span class=line><span class=cl>   <span class=p>|</span>- Total banned:     <span class=m>1</span>
</span></span><span class=line><span class=cl>   <span class=sb>`</span>- Banned IP list:   0.0.0.0
</span></span></code></pre></td></tr></table></div></div><p>下面的命令输出一个简要的版本，包括所有监控目标被封的 IP 地址：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ sudo fail2ban-client banned
</span></span><span class=line><span class=cl><span class=o>[{</span><span class=s1>&#39;sshd&#39;</span>: <span class=o>[</span><span class=s1>&#39;192.168.100.50&#39;</span><span class=o>]}</span>, <span class=o>{</span><span class=s1>&#39;apache-auth&#39;</span>: <span class=o>[]}]</span>
</span></span></code></pre></td></tr></table></div></div><p>下面的命令可以解封某个 IP 地址：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ sudo fail2ban-client <span class=nb>set</span> sshd unbanip 192.168.1.69
</span></span></code></pre></td></tr></table></div></div><p>手动禁止一个 IP 地址：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>sudo fail2ban-client <span class=nb>set</span> sshd banip &lt;IP地址&gt;
</span></span></code></pre></td></tr></table></div></div><h3 id=配置>配置</h3><h4 id=主配置文件>主配置文件</h4><p>Fail2Ban 主配置文件是在<code>/etc/fail2ban/fail2ban.conf</code>，可以新建一份副本<code>/etc/fail2ban/fail2ban.local</code>作为本地配置文件，修改都针对本地配置文件：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ sudo cp /etc/fail2ban/fail2ban.conf /etc/fail2ban/fail2ban.local
</span></span></code></pre></td></tr></table></div></div><p>下面是设置 Fail2Ban 的日志位置：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=p>[</span><span class=n>Definition</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>logtarget</span> <span class=o>=</span> <span class=o>/</span><span class=k>var</span><span class=o>/</span><span class=nb>log</span><span class=o>/</span><span class=n>fail2ban</span><span class=o>/</span><span class=n>fail2ban</span><span class=o>.</span><span class=n>log</span>
</span></span></code></pre></td></tr></table></div></div><p>修改配置以后，需要重新启动<code>fail2ban.service</code>，让其生效。</p><h4 id=封禁配置>封禁配置</h4><p>Fail2Ban 封禁行为的配置文件是<code>/etc/fail2ban/jail.conf</code>。为了便于修改，可以把它复制一份<code>/etc/fail2ban/jail.local</code>本地配置文件，后面的修改都针对<code>jail.local</code>这个文件：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ sudo cp /etc/fail2ban/jail.conf /etc/fail2ban/jail.local
</span></span></code></pre></td></tr></table></div></div><p>你也可以在目录<code>/etc/fail2ban/jail.d</code>里面，新建单独的子配置文件，比如<code>/etc/fail2ban/jail.d/sshd.local</code>。</p><p>同样地，修改配置以后，需要重新启动<code>fail2ban.service</code>，让其生效。</p><p>配置文件里面，<code>[DEFAULT]</code>标题行表示对于所有封禁目标生效。举例来说，如果封禁时间修改为1天，<code>/etc/fail2ban/jail.local</code>里面可以写成：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=p>[</span><span class=l>DEFAULT]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=l>bantime = 1d</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>如果某人被封时，对站长发送邮件通知，可以如下设置。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=p>[</span><span class=l>DEFAULT]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=l>destemail = yourname@example.com</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=l>sender = yourname@example.com</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c># to ban &amp; send an e-mail with whois report to the destemail.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=l>action = %(action_mw)s</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c># same as action_mw but also send relevant log lines</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c>#action = %(action_mwl)s</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>如果配置写在其他标题行下，就表示只对该封禁目标生效，比如写在<code>[sshd]</code>下面，就表示只对 sshd 生效。</p><p>默认情况下，Fail2Ban 对<strong>各种服务都是关闭的</strong>，如果要针对某一项服务开启，需要在配置文件里面声明。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[sshd]
</span></span><span class=line><span class=cl>enabled = true
</span></span></code></pre></td></tr></table></div></div><p>上面声明表示，Fail2Ban 对 sshd 开启。</p><h4 id=配置项-3>配置项</h4><p>下面是配置文件<code>jail.local</code>的配置项含义，所有配置项的格式都是<code>key=value</code>。</p><p>（1）bantime</p><p>封禁的时间长度，单位<code>m</code>表示分钟，<code>d</code>表示天，<code>h</code>表示小时，如果不写单位，则表示秒。Fail2Ban 默认封禁10分钟（10m 或 600）。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[DEFAULT]
</span></span><span class=line><span class=cl>bantime = 10m
</span></span></code></pre></td></tr></table></div></div><p>（2）findtime</p><p>登录失败计算的时间长度，单位<code>m</code>表示分钟，<code>d</code>表示天，如果不写单位，则表示秒。Fail2Ban 默认封禁 10 分钟内登录 5 次失败的客户端。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[DEFAULT]
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>findtime = 10m
</span></span><span class=line><span class=cl>maxretry = 5
</span></span></code></pre></td></tr></table></div></div><p>（3）maxretry</p><p>尝试登录的最大失败次数。</p><p>（4）destemail</p><p>接受通知的邮件地址。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[DEFAULT]
</span></span><span class=line><span class=cl>destemail = root@localhost
</span></span><span class=line><span class=cl>sender = root@&lt;fq-hostname&gt;
</span></span><span class=line><span class=cl>mta = sendmail
</span></span></code></pre></td></tr></table></div></div><p>（5）sendername</p><p>通知邮件的“发件人”字段的值。</p><p>（6）mta</p><p>发送邮件的邮件服务，默认是<code>sendmail</code>。</p><p>（7）action</p><p>封禁时采取的动作。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[DEFAULT]
</span></span><span class=line><span class=cl>action = $(action_)s
</span></span></code></pre></td></tr></table></div></div><p>上面的<code>action_</code>是默认动作，表示拒绝封禁对象的流量，直到封禁期结束。</p><p>下面是 Fail2Ban 提供的一些其他动作。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=c># ban &amp; send an e-mail with whois report to the destemail.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=l>action_mw = %(action_)s</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=l>%(mta)s-whois[sender=&#34;%(sender)s&#34;, dest=&#34;%(destemail)s&#34;, protocol=&#34;%(protocol)s&#34;, chain=&#34;%(chain)s&#34;]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c># ban &amp; send an e-mail with whois report and relevant log lines</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c># to the destemail.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=l>action_mwl = %(action_)s</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>             </span><span class=l>%(mta)s-whois-lines[sender=&#34;%(sender)s&#34;, dest=&#34;%(destemail)s&#34;, logpath=&#34;%(logpath)s&#34;, chain=&#34;%(chain)s&#34;]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c># See the IMPORTANT note in action.d/xarf-login-attack for when to use this action</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c>#</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c># ban &amp; send a xarf e-mail to abuse contact of IP address and include relevant log lines</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c># to the destemail.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=l>action_xarf = %(action_)s</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>             </span><span class=l>xarf-login-attack[service=%(__name__)s, sender=&#34;%(sender)s&#34;, logpath=&#34;%(logpath)s&#34;, port=&#34;%(port)s&#34;]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c># ban IP on CloudFlare &amp; send an e-mail with whois report and relevant log lines</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c># to the destemail.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=l>action_cf_mwl = cloudflare[cfuser=&#34;%(cfemail)s&#34;, cftoken=&#34;%(cfapikey)s&#34;]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=l>%(mta)s-whois-lines[sender=&#34;%(sender)s&#34;, dest=&#34;%(destemail)s&#34;, logpath=&#34;%(logpath)s&#34;, chain=&#34;%(chain)s&#34;]</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>（8）ignoreip</p><p>Fail2Ban 可以忽视的可信 IP 地址。多个 IP 地址之间使用空格分隔。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>ignoreip = 127.0.0.1/8 192.168.1.10 192.168.1.20
</span></span></code></pre></td></tr></table></div></div><p>（9）port</p><p>指定要监控的端口。可以设为任何端口号或服务名称，比如<code>ssh</code>、<code>22</code>、<code>2200</code>等。</p><h3 id=ssh-配置>ssh 配置</h3><p>下面是 sshd 的设置范例：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=p>[</span><span class=l>sshd]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=l>enabled   = true</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=l>port = ssh</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=l>filter    = sshd</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=l>banaction = iptables</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=l>backend   = systemd</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=l>maxretry  = 5</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=l>findtime  = 1d</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=l>bantime   = 2w</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=l>ignoreip  = 127.0.0.1/8</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>首先需要注意，为了让 Fail2Ban 能够完整发挥作用，最好在<code>/etc/ssh/sshd_config</code>里面设置<code>LogLevel VERBOSE</code>，保证日志有足够的信息。</p><hr><h2 id=ssh-端口转发->SSH 端口转发: ?</h2><h3 id=简介-5>简介</h3><p>SSH 除了登录服务器，还有一大用途，就是作为加密通信的中介，充当两台服务器之间的通信加密跳板，使得原本不加密的通信变成加密通信。这个功能称为<strong>端口转发</strong>（port forwarding），又称 <strong>SSH 隧道</strong>（tunnel）。</p><p>端口转发有两个主要作用：</p><p>（1）将不加密的数据放在 SSH 安全连接里面传输，使得原本不安全的网络服务增加了安全性，比如通过端口转发访问 Telnet、FTP 等明文服务，数据传输就都会加密。</p><p>（2）作为数据通信的加密跳板，绕过网络防火墙。</p><p>端口转发有三种使用方法：动态转发，本地转发，远程转发。下面逐一介绍。</p><h3 id=动态转发>动态转发</h3><p>动态转发指的是，本机与 SSH 服务器之间创建了一个加密连接，然后本机内部针对某个端口的通信，都通过这个加密连接转发。它的一个使用场景就是，访问所有外部网站，都通过 SSH 转发。</p><p>动态转发需要把本地端口绑定到 SSH 服务器。至于 SSH 服务器要去访问哪一个网站，完全是动态的，取决于原始通信，所以叫做动态转发。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ ssh -D local-port tunnel-host -N
</span></span></code></pre></td></tr></table></div></div><p>上面命令中，<code>-D</code>表示动态转发，<code>local-port</code>是本地端口，<code>tunnel-host</code>是 SSH 服务器，<code>-N</code>表示这个 SSH 连接只进行端口转发，不登录远程 Shell，不能执行远程命令，只能充当隧道。</p><p>举例来说，如果本地端口是<code>2121</code>，那么动态转发的命令就是下面这样。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ ssh -D <span class=m>2121</span> tunnel-host -N
</span></span></code></pre></td></tr></table></div></div><p>注意，这种转发采用了 SOCKS5 协议。访问外部网站时，需要把 HTTP 请求转成 SOCKS5 协议，才能把本地端口的请求转发出去。</p><p>下面是 SSH 隧道建立后的一个使用实例。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ curl -x socks5://localhost:2121 http://www.example.com
</span></span></code></pre></td></tr></table></div></div><p>上面命令中，curl 的<code>-x</code>参数指定代理服务器，即通过 SOCKS5 协议的本地<code>2121</code>端口，访问<code>http://www.example.com</code>。</p><p>如果经常使用动态转发，可以将设置写入 SSH 客户端的用户个人配置文件（<code>~/.ssh/config</code>）。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>DynamicForward tunnel-host:local-port
</span></span></code></pre></td></tr></table></div></div><h3 id=本地转发>本地转发</h3><p>本地转发（local forwarding）指的是，SSH 服务器作为中介的跳板机，建立本地计算机与特定目标网站之间的加密连接。本地转发是在本地计算机的 SSH 客户端建立的转发规则。</p><p>它会指定一个本地端口（local-port），所有发向那个端口的请求，都会转发到 SSH 跳板机（tunnel-host），然后 SSH 跳板机作为中介，将收到的请求发到目标服务器（target-host）的目标端口（target-port）。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ ssh -L local-port:target-host:target-port tunnel-host
</span></span></code></pre></td></tr></table></div></div><p>上面命令中，<code>-L</code>参数表示本地转发，<code>local-port</code>是本地端口，<code>target-host</code>是你想要访问的目标服务器，<code>target-port</code>是目标服务器的端口，<code>tunnel-host</code>是 SSH 跳板机。</p><p>举例来说，现在有一台 SSH 跳板机<code>tunnel-host</code>，我们想要通过这台机器，在本地<code>2121</code>端口与目标网站<code>www.example.com</code>的80端口之间建立 SSH 隧道，就可以写成下面这样。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ ssh -L 2121:www.example.com:80 tunnel-host -N
</span></span></code></pre></td></tr></table></div></div><p>然后，访问本机的<code>2121</code>端口，就是访问<code>www.example.com</code>的80端口。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ curl http://localhost:2121
</span></span></code></pre></td></tr></table></div></div><p>注意，本地端口转发采用 HTTP 协议，不用转成 SOCKS5 协议。</p><p>另一个例子是加密访问邮件获取协议 POP3。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ ssh -L 1100:mail.example.com:110 mail.example.com
</span></span></code></pre></td></tr></table></div></div><p>上面命令将本机的1100端口，绑定邮件服务器<code>mail.example.com</code>的110端口（POP3 协议的默认端口）。端口转发建立以后，POP3 邮件客户端只需要访问本机的1100端口，请求就会通过 SSH 跳板机（这里是<code>mail.example.com</code>），自动转发到<code>mail.example.com</code>的110端口。</p><p>上面这种情况有一个前提条件，就是<code>mail.example.com</code>必须运行 SSH 服务器。否则，就必须通过另一台 SSH 服务器中介，执行的命令要改成下面这样。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ ssh -L 1100:mail.example.com:110 other.example.com
</span></span></code></pre></td></tr></table></div></div><p>上面命令中，本机的1100端口还是绑定<code>mail.example.com</code>的110端口，但是由于<code>mail.example.com</code>没有运行 SSH 服务器，所以必须通过<code>other.example.com</code>中介。本机的 POP3 请求通过1100端口，先发给<code>other.example.com</code>的22端口（sshd 默认端口），再由后者转给<code>mail.example.com</code>，得到数据以后再原路返回。</p><p>注意，采用上面的中介方式，只有本机到<code>other.example.com</code>的这一段是加密的，<code>other.example.com</code>到<code>mail.example.com</code>的这一段并不加密。</p><p>这个命令最好加上<code>-N</code>参数，表示不在 SSH 跳板机执行远程命令，让 SSH 只充当隧道。另外还有一个<code>-f</code>参数表示 SSH 连接在后台运行。</p><p>如果经常使用本地转发，可以将设置写入 SSH 客户端的用户个人配置文件（<code>~/.ssh/config</code>）。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>Host test.example.com
</span></span><span class=line><span class=cl>LocalForward client-IP:client-port server-IP:server-port
</span></span></code></pre></td></tr></table></div></div><h3 id=远程转发>远程转发</h3><p>远程转发指的是在远程 SSH 服务器建立的转发规则。</p><p>它跟本地转发正好反过来。建立本地计算机到远程计算机的 SSH 隧道以后，本地转发是通过本地计算机访问远程计算机，而远程转发则是通过远程计算机访问本地计算机。它的命令格式如下:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ ssh -R remote-port:target-host:target-port -N remotehost
</span></span></code></pre></td></tr></table></div></div><p>上面命令中，<code>-R</code>参数表示远程端口转发，<code>remote-port</code>是远程计算机的端口，<code>target-host</code>和<code>target-port</code>是目标服务器及其端口，<code>remotehost</code>是远程计算机。</p><p>远程转发主要针对内网的情况。下面举两个例子:</p><p>第一个例子是内网某台服务器<code>localhost</code>在 80 端口开了一个服务，可以通过远程转发将这个 80 端口，映射到具有公网 IP 地址的<code>my.public.server</code>服务器的 8080 端口，使得访问<code>my.public.server:8080</code>这个地址，就可以访问到那台内网服务器的 80 端口。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ ssh -R 8080:localhost:80 -N my.public.server
</span></span></code></pre></td></tr></table></div></div><p>上面命令是在内网<code>localhost</code>服务器上执行，建立从<code>localhost</code>到<code>my.public.server</code>的 SSH 隧道。运行以后，用户访问<code>my.public.server:8080</code>，就会自动映射到<code>localhost:80</code>。</p><p>第二个例子是本地计算机<code>local</code>在外网，SSH 跳板机和目标服务器<code>my.private.server</code>都在内网，必须通过 SSH 跳板机才能访问目标服务器。但是，本地计算机<code>local</code>无法访问内网之中的 SSH 跳板机，而 SSH 跳板机可以访问本机计算机。</p><p>由于本机无法访问内网 SSH 跳板机，就无法从外网发起 SSH 隧道，建立端口转发。必须反过来，从 SSH 跳板机发起隧道，建立端口转发，这时就形成了远程端口转发。跳板机执行下面的命令，绑定本地计算机<code>local</code>的<code>2121</code>端口，去访问<code>my.private.server:80</code>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ ssh -R 2121:my.private.server:80 -N <span class=nb>local</span>
</span></span></code></pre></td></tr></table></div></div><p>上面命令是在 SSH 跳板机上执行的，建立跳板机到<code>local</code>的隧道，并且这条隧道的出口映射到<code>my.private.server:80</code>。</p><p>显然，远程转发要求本地计算机<code>local</code>也安装了 SSH 服务器，这样才能接受 SSH 跳板机的远程登录。</p><p>执行上面的命令以后，跳板机到<code>local</code>的隧道已经建立了。然后，就可以从本地计算机访问目标服务器了，即在本机执行下面的命令。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ curl http://localhost:2121
</span></span></code></pre></td></tr></table></div></div><p>本机执行上面的命令以后，就会输出服务器<code>my.private.server</code>的 80 端口返回的内容。</p><p>如果经常执行远程端口转发，可以将设置写入 SSH 客户端的用户个人配置文件（<code>~/.ssh/config</code>）。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>Host remote-forward
</span></span><span class=line><span class=cl>  HostName test.example.com
</span></span><span class=line><span class=cl>  RemoteForward remote-port target-host:target-port
</span></span></code></pre></td></tr></table></div></div><p>完成上面的设置后，执行下面的命令就会建立远程转发。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ ssh -N remote-forward
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 等同于</span>
</span></span><span class=line><span class=cl>$ ssh -R remote-port:target-host:target-port -N test.example.com
</span></span></code></pre></td></tr></table></div></div><h3 id=实例>实例</h3><p>下面看两个端口转发的实例。</p><h4 id=简易-vpn>简易 VPN</h4><p>VPN 用来在外网与内网之间建立一条加密通道。内网的服务器不能从外网直接访问，必须通过一个跳板机，如果本机可以访问跳板机，就可以使用 SSH 本地转发，简单实现一个 VPN。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ ssh -L 2080:corp-server:80 -L 2443:corp-server:443 tunnel-host -N
</span></span></code></pre></td></tr></table></div></div><p>上面命令通过 SSH 跳板机，将本机的<code>2080</code>端口绑定内网服务器的<code>80</code>端口，本机的<code>2443</code>端口绑定内网服务器的<code>443</code>端口。</p><h4 id=两级跳板>两级跳板</h4><p>端口转发可以有多级，比如新建两个 SSH 隧道，第一个隧道转发给第二个隧道，第二个隧道才能访问目标服务器。</p><p>首先，在本机新建第一级隧道。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ ssh -L 7999:localhost:2999 tunnel1-host
</span></span></code></pre></td></tr></table></div></div><p>上面命令在本地<code>7999</code>端口与<code>tunnel1-host</code>之间建立一条隧道，隧道的出口是<code>tunnel1-host</code>的<code>localhost:2999</code>，也就是<code>tunnel1-host</code>收到本机的请求以后，转发给自己的<code>2999</code>端口。</p><p>然后，在第一台跳板机（<code>tunnel1-host</code>）执行下面的命令，新建第二级隧道。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ ssh -L 2999:target-host:7999 tunnel2-host -N
</span></span></code></pre></td></tr></table></div></div><p>上面命令将第一台跳板机<code>tunnel1-host</code>的<code>2999</code>端口，通过第二台跳板机<code>tunnel2-host</code>，连接到目标服务器<code>target-host</code>的<code>7999</code>端口。</p><p>最终效果就是，访问本机的<code>7999</code>端口，就会转发到<code>target-host</code>的<code>7999</code>端口。</p><p>在远程机器上<code>/etc/ssh/sshd_config</code> 打开 <code>GatewayPorts yes</code> ，才能通过公网访问 远程8080转发 的本地80服务。</p><h3 id=参考链接-2>参考链接</h3><ul><li><a class=link href=https://solitum.net/posts/an-illustrated-guide-to-ssh-tunnels/ target=_blank rel=noopener>An Illustrated Guide to SSH Tunnels</a>, Scott Wiersdorf</li><li><a class=link href=https://grahamhelton.com/blog/ssh-cheatsheet/ target=_blank rel=noopener>An Excruciatingly Detailed Guide To SSH</a>, Graham Helton</li></ul><hr><h2 id=参考>参考</h2><blockquote><ul><li>原文地址： <a class=link href=https://wangdoc.com/ssh/ target=_blank rel=noopener>https://wangdoc.com/ssh/</a></li></ul></blockquote></section><footer class=article-footer><section class=article-tags><a href=/tags/ssh/>SSH</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>相关文章</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/p/vim-introduction/><div class=article-details><h2 class=article-title>Vim Introduction</h2></div></a></article><article><a href=/p/terminal-and-shell-introduction/><div class=article-details><h2 class=article-title>Terminal And Shell Introduction</h2></div></a></article><article><a href=/p/vim-common-commands/><div class=article-details><h2 class=article-title>Vim Common Commands</h2></div></a></article><article><a href=/p/linux-common-commands/><div class=article-details><h2 class=article-title>Linux Common Commands</h2></div></a></article><article><a href=/p/batch-del-cf-dns-record/><div class=article-details><h2 class=article-title>Batch Del CF DNS Record</h2></div></a></article></div></div></aside><script src=//unpkg.com/@waline/client@v2/dist/waline.js></script><link href=//unpkg.com/@waline/client@v2/dist/waline.css rel=stylesheet><div id=waline class=waline-container></div><style>.waline-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding);--waline-font-size:var(--article-font-size)}.waline-container .wl-count{color:var(--card-text-color-main)}</style><script>Waline.init({comment:!0,copyright:!1,dark:'html[data-scheme="dark"]',el:"#waline",emoji:["https://unpkg.com/@waline/emojis@1.0.1/weibo"],lang:"zh-cn",locale:{admin:"👻Hi",placeholder:"🎉留下你的脚印..."},pageview:!0,reaction:!0,requiredMeta:["nick"],serverURL:"https://waline.nek.us.kg/"})</script><footer class=site-footer><section class=copyright>Copyright &copy;
2020 -
2024 <b><a href=https://github.com/arlettebrook target=_blank rel=noopener>@Arlettebrook</a></b></section><section class=powerby>博客内容遵循<b><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/legalcode.zh-hans target=_blank rel=noopener> 知识共享 署名-非商业性-相同方式共享4.0国际协议</a></b><br>使用 <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> 构建<br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.25.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>