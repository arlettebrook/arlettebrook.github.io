[{"content":" 注意：要学会使用-h \u0026ndash;help选项，查看命令，看不懂在查阅。git help \u0026lt;command\u0026gt;可进入官方文档。Git入门参考。以下常用命令个人收集总结。\n# git简单命令 # git init git init \u0026lt;directory\u0026gt;在指定的⽬录下创建⼀个空的git repo。不带参数将在当前⽬录下创建⼀个git repo。 # git clone git clone \u0026lt;repo\u0026gt;克隆⼀个指定repo到本地。指定的repo可以是本地⽂件系统或者由HTTP或SSH指定的远程路径。 git clone -b \u0026lt;branch\u0026gt; \u0026lt;repo\u0026gt;克隆指定仓库的分支 git clone --recursive \u0026lt;repo\u0026gt;递归地克隆，克隆带有子模块的仓库 git clone --recurse-submodules \u0026lt;repository_url\u0026gt;同理 可组合使用 # git add git add \u0026lt;directory\u0026gt;将指定⽬录的所有修改加⼊到下⼀次 commit中。把\u0026lt;directory\u0026gt;替换成\u0026lt;file\u0026gt;将添加指定⽂件的修改。 git add *、git add .、git add -A三条命令但是一样的，将所以修改提交到暂存区。 # git commit 这个命令通常带-m选项git commit -m \u0026quot;\u0026lt;message\u0026gt;\u0026quot;提交暂存区的修改，使⽤指定的 \u0026lt;message\u0026gt;作为提交信息，⽽不是打开⽂本编辑器输⼊提交信息。 git commit -m \u0026lt;message\u0026gt; --amend将当前staged修改合并到最近⼀次的commit中。 # git status git status显示哪些⽂件已被staged、以及未跟踪(untracked)。 # git reflog git reflog显示本地repo的所有commit⽇志。 与git log的区别 log项目的提交历史，reflog本地仓库的引用提交日志。 引用会保留所以的提交历史，如何重置的历史。主要目的是提供一个安全网，以便在误操作（如错误的 git reset）后可以恢复丢失的提交或分支。 git log 的输出是永久性的，而 reflog 会在一段时间后自动过期（默认是 30 天），以节省空间。 # git rm git rm fileName删除指定的文件。 与rm fileName的区别。 git rm不能删除未跟踪的文件， git rm删除之后直接到暂存区，而rm是到工作区 注意删除之后都需要提交操作。 撤销操作不用记，git都会有提示 # git switch 该命令适用于特定git版本。\ngit switch \u0026lt;branch\u0026gt;切换到指定分支，\ngit checkout \u0026lt;branch\u0026gt;同理，但这个都适用。 git switch -c \u0026lt;branch\u0026gt;创建并切换指定分支\n# git branch git branch显示本地repo的所有分⽀。\n-v显示详细信息 带*的为当前分支 git branch -r显示远程仓库的所以分支。\n可以使用git checkout \u0026lt;branch\u0026gt;检出远程分支，可以省略origin/。 git branch -a显示本地和远程的所有分支\ngit branch -m \u0026lt;old_branch_name\u0026gt; \u0026lt;new_branch_name\u0026gt;重命名分支\n新分支名已经存在， -M 强制重命名。 git branch \u0026lt;name\u0026gt;创建指定分支\ngit branch -D \u0026lt;branch\u0026gt;强制删除指定分支，无论是否合并到当前分支。\ngit branch -d \u0026lt;branch\u0026gt;删除指定的分支，如果没有合并到当前分支，git会阻止操作。\n# git merge git merge \u0026lt;branch\u0026gt;合并指定分支。将指定\u0026lt;branch\u0026gt;分⽀合并到当前分⽀。 是在当前分支合并指定分支。 合并分支可能会出现冲突。要解决冲突之后才能合并。 git merge --abort放弃本次合并 # git一般命令 # git revert git revert \u0026lt;commit\u0026gt; 对指定\u0026lt;commit\u0026gt;创建⼀个undo的commit，并应⽤到当前分⽀。就是撤销指定的提交并保留记录 效果：撤销指定的提交，回到了撤销提交的是上个版本，保留了撤销历史。会打开编辑器显示具体效果 一般不用 # git reset git reset \u0026lt;commit\u0026gt;重置到指定的提交，不会保留commit历史。工作区和暂存区会变成未跟踪。--hard选项完全重置到指定提交。未跟踪的重置不了。重置历史可以通过git reflog查看，利用这个可以重置已经重置的版本库。\n\u0026lt;commit\u0026gt;可以是： HEAD表示最新的提交或者这个版本库，HEAD^、HEAD~1上上次提交或者上个版本 或者使用commit_hash，提交的哈希值可以使用git log查看，只需要前几位就行。 git reset（重置到最新的提交）移除所有暂存区、工作区的修改，到未跟踪。这些命令其实省略了HEAD\ngit reset --hard 重置到最新的提交，删除工作区和暂存区\ngit reset \u0026lt;file\u0026gt;将\u0026lt;file\u0026gt;从暂存区移除，但保持⼯作区不变。此操作不会修改⼯作区的任何⽂件。\n# git restore git restore \u0026lt;file\u0026gt;...撤销对工作区的修改，是对以跟踪的文件当未添加到暂存区的文件。多个文件用空格分开。 git checkout -- \u0026lt;file\u0026gt;...同理，--可以省略 git restore --staged \u0026lt;file\u0026gt;...撤销对暂存区的修改到未跟踪。针对添加到暂存区的文件。 git reset HEAD \u0026lt;file\u0026gt;...同理，HEAD可以省略。 具体用哪一个，git都会有提示，不用记。 # git checkout git checkout \u0026lt;branch\u0026gt;切换到指定的分支\n如果分支为远程分支，则检出远程分支 git checkout -b \u0026lt;new-branch\u0026gt;切换并创建指定的分支\ngit checkout \u0026lt;file\u0026gt;撤销工作区的修改\ngit restore \u0026lt;file\u0026gt;同理 git checkout \u0026lt;commit\u0026gt;根据指定的提交创建一个分支,处于游离态。一般不用。\ngit checkout -b \u0026lt;local_branch_name\u0026gt; origin/\u0026lt;remote_branch_name\u0026gt;切换到远程分支\ngit checkout \u0026lt;branch\u0026gt;差不多，可以使用git fetch origin获取仓库所以信息，在检出分支。 git checkout -切换到前一个分支。\n# git remote 用来管理远程仓库列表，origin为远程仓库的默认别名。这些远端仓库的信息都被保存在./git/config 文件中。\ngit remote列出所有已配置的远程仓库的信息。\n-v显示详细信息 git remote add \u0026lt;remote_name\u0026gt; \u0026lt;remote_url\u0026gt;添加远程仓库\n添加⼀个新的远程连接。添加后可使⽤ \u0026lt;name\u0026gt;作为指定\u0026lt;url\u0026gt;远程连接的名称。 只有配置了这个才能推送到远程仓库。 git remote rename \u0026lt;old_name\u0026gt; \u0026lt;new_name\u0026gt;重命名远程仓库。 git remote set-url \u0026lt;remote_name\u0026gt; \u0026lt;new_url\u0026gt;修改远程仓库的url。 git remote remove \u0026lt;remote_name\u0026gt;或git remote rm \u0026lt;remote_name\u0026gt;删除远程仓库。 git remote show \u0026lt;remote_name\u0026gt;显示远程仓库的详细信息，包括 URL、跟踪的分支等。\n补充如何创建远程仓库\n创建远程仓库可以先在github上创建好，然后在本地pull下来，在进行修改后push上去。\n可以建一个空白仓库，在本地push上去，但需要进行绑定。\n1 2 3 git remote add origin https://github.com/username/null-project.git git branch -M main git push -u origin main # gjit push 将本地仓库推送到远程仓库\ngit push \u0026lt;remote_repository\u0026gt; \u0026lt;本地分支名\u0026gt;:\u0026lt;远程分支名\u0026gt;推送本地分支到指定的远程分支。如果远程分支不存在，会自动创建。:前后不能有空格。\n当分支同名，可以简写成git push \u0026lt;remote_repository\u0026gt; \u0026lt;本地分支名\u0026gt; 果无法提交的话执行，-f、--force选项强制推送，一般不用。 git push -u \u0026lt;remote_repository\u0026gt; \u0026lt;本地分支名\u0026gt;设置默认推送分支。\n作用：这样设置以后，推送到远程仓库可以简写成git push git push 代替 git push origin master -u是--set-upstream的短形式。 git push \u0026lt;remote_repository\u0026gt; -d \u0026lt;远程分支名\u0026gt;删除远程分支 。\n--delete长选项。 git push origin :test同理，没有写本地分支，就是删除远程分支。 git push \u0026lt;remote\u0026gt; \u0026lt;tagname\u0026gt;推送指定标签到指定远程仓库，一般为`origin``\n``git push \u0026ndash;tags`推送所用标签到远程\n# git pull git pull \u0026lt;remote_repository\u0026gt; \u0026lt;远程分支名\u0026gt;:\u0026lt;本地分支名\u0026gt;从远程仓库拉取最新代码到本地仓库。 git pull会拉取并合并，出现冲突要解决之后才能合并。 git fetch获取当前远程仓库的最新信息，不会合并。 通常可以简写成git pull,远程仓库默认是origin，分支默认是当前分支。 git pull --rebase\u0026lt;remote\u0026gt; 抓取远程分⽀，并以rebase模式并⼊本地repo⽽不是merge。 # git fetch git fetch origin获取远程仓库最新的更改。不会合并。默认仓库是origin，分支是当前分支，这里可以省略origin git fetch origin \u0026lt;branch\u0026gt;获取特定分支的更改. git fetch --all获取所用仓库远程仓库的最新更改。 与git pull的区别 都会获取远程仓库最新的更改。 但是fetch不会合并，而pull会合并。可以理解为git pull 是 git fetch 和 git merge 的组合 获取最新更改之后可以： git checkout \u0026lt;branch\u0026gt;检出指定分支，如果加origin要这样git checkout -b \u0026lt;branch\u0026gt; origin/\u0026lt;branch\u0026gt; git merge origin/master合并远程 master 分支的更改到当前的分支 git rebase origin/master使用 rebase 来整合更改（这可能会改变提交历史） # git stash git stash保存工作区、暂存区，可以切换分支去完成别的任务。不保存修改，未提交的修改会错乱到别的分支。并且只能保存已追踪的文件。 git stash list查看保存的工作区以及暂存区。 git stash apply恢复保存的工作区以及暂存区。 这个命令执行之后不会删除存储的工作区以及暂存区。 要用git stash drop才能删除。 git stash pop恢复并删除保存的工作区以及暂存区。 默认都是保存、恢复第一个stash即stash@{0}。若要指定第几个在后面加stash@{num}。 如恢复第二个stash：git stash pop stash@{1} 每个分支共用一个stash。 # git tag 作用：用于标记项目的版本发布或重要的里程碑。 分类 git tag \u0026lt;tagname\u0026gt; \u0026lt;commit ID\u0026gt;轻量标签 git tag vn.n.n打标签，n.n.n表示对应的版本号，版本号前面一般加v，遵循一定的命名规范，如v1.0.1。 默认是打在最新的一次提交。 后面跟提交的哈希值可以指定给那次提交打标签。如git tag v0.9.0 f52c633。 哈希值可以通过git log查看 git tag -a \u0026lt;tagname\u0026gt; -m \u0026quot;\u0026lt;tag message\u0026gt;\u0026quot; \u0026lt;commit ID\u0026gt;附注标签 如git tag -a v0.1 -m \u0026quot;version 0.1 released\u0026quot; 1094adb 推荐id省略默认最新提交。 查看标签 git tag显示所有的本地tag列表，按照字母顺序排序。如果tag数量较多，可能会显示不全。省略选项-l、--list git show \u0026lt;tagname\u0026gt;显示指定tag的详细信息，包括提交的作者、提交时间、提交信息等。 git tag -n：显示tag列表，并同时显示每个tag对应的提交信息。 git ls-remote --tags origin：显示远程仓库中的所有tag信息。更推荐这种。 或者先git fetch获取最新的更改，然后git tag检出所有标签。 删除标签 git tag -d \u0026lt;tagname\u0026gt;删除本地标签 删除远程标签：首先需要在本地删除标签，然后推送到远程仓库 git push origin :refs/tags/\u0026lt;tagname\u0026gt; 远程标签是refs/tags/v0.0.1这样存在的，跟删除远程分支差不多。 标签一旦创建，就不能直接修改,如果需要修改标签，通常需要删除原标签，并重新创建一个新标签。 推送标签 打的标签不会自动推送到远程仓库，需要手动推送。 git push \u0026lt;remote\u0026gt; \u0026lt;tagname\u0026gt;推送指定标签到指定远程仓库，一般为origin git push \u0026lt;remote\u0026gt; --tags推送所用标签到远程 # git复杂命令 # git log git log以缺省格式显示全部commit历史。更多⾃定义参数请参考后续部分。q退出，空格下一页，h查看帮助 git log --stat：显示详细的commit历史。 git log -\u0026lt;limit\u0026gt;限制log的显示数量。例如：”git log -5”仅显示最新5条commit。 git log --oneline每⾏显示⼀条commit，简化信息。与--pretty=oneline等效 git log --author= \u0026quot;\u0026lt;pattern\u0026gt;\u0026quot;按提交者名字搜索并显示commit。 git log --grep= \u0026quot;\u0026lt;pattern\u0026gt;\u0026quot;按指定内容搜索并显示commit。 git log \u0026lt;since\u0026gt;..\u0026lt;until\u0026gt;显示指定范围的commit。范围参数可以是commit ID、分⽀名称、HEAD或任意相对位置。 git log -- \u0026lt;file\u0026gt;仅显示包含指定⽂件修改的commit。 git log --graph使⽤\u0026ndash;graph参数显示图形化的branch信息。 # git diff git diff⽐较⼯作区和暂存区的修改。 git diff HEAD⽐较⼯作区和上⼀次commit后的修改。 HEAD指向当前分支最新的commit版本库 git diff --cached⽐较暂存区和上⼀次commit后的修改。 git diff --stashed查看暂存区与最新提交的差异，与上面一样 git diff \u0026lt;commit1\u0026gt; \u0026lt;commit2\u0026gt;查看两个提交之间的差异。 git diff \u0026lt;filename\u0026gt;后面指定文件，只查看该文件的修改情况，没有参数查询全部 用git diff HEAD -- readme.txt命令可以查看版本库和工作区里面最新版本的区别 # git config 作用：通过git config命令配置git的配置文件\ngit配置文件级别分为：\n仓库级别 --local 【优先级最高】。文件所在位置仓库下的.git/config 当前用户级别 --global【优先级次之】一般配置它。文件所在位置用户家目录下的.gitconfig 系统所有用户级别 --system【优先级最低】。文件所在位置git安装目录下的 ./etc/gitconfig -l、--list查看配置。常用\ngit config -l查看所有的配置信息，依次是系统级别、用户级别、仓库级别 git config --local -l 查看仓库级别配置。必须要进入到具体的目录下。 git config --global -l 查看当前用户配置 git config --system -l 查看系统所有用户配置 可以与--show-origin 显示文件位置，--show-scope显示文件级别组合使用 -e、--edit打开编辑器编辑指定级别的配置文件，没有指定默认仓库级别，会使用默认编辑器打开编辑。安装的时候设置的。\n添加配置、修改配置：直接配置对应的配置参数就行。一般配置用户级别就行。省略了--add选项。没有指定级别，默认仓库基本。常用的添加配置命令:\n用户邮箱和用户名。安装git之后必设置的配置\ngit config --global user.email \u0026quot;Your mail\u0026quot;\ngit config --global user.name \u0026quot;Your name\u0026quot;\n如果我们没有配置，在提交代码时会有如下错误：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 xxx@DESKTOP-MD21325 MINGW64 /d/test/test (master) $ git commit -m \u0026#34;feature: add readme\u0026#34; Author identity unknown *** Please tell me who you are. Run git config --global user.email \u0026#34;you@example.com\u0026#34; git config --global user.name \u0026#34;Your Name\u0026#34; to set your account\u0026#39;s default identity. Omit --global to set the identity only in this repository. fatal: unable to auto-detect email address (got \u0026#39;xxx@DESKTOP-MD21325.(none)\u0026#39;) 设置自己的代理。网速慢必设置的配置\ngit config --global http.proxy \u0026quot;http://proxy_ip:port\u0026quot;\ngit config --global https.proxy \u0026quot;https://proxy_ip:port\u0026quot;\n--unset取消配置，注意要指定取消的配置级别。常用取消配置命令：\n取消代理配置\ngit config --global --unset http.proxy\ngit config --global --unset https.proxy\n--get查看指定级别、指定配置项的配置，默认仓库级别。如：\n查看代理配置\ngit config --global --get http.proxy\ngit config --global --get https.proxy\ngit config --global alias.\u0026lt;alias-name\u0026gt; \u0026lt;git-command\u0026gt;配置⼀个git命令的快捷⽅式。例如：配置”alias.glog log \u0026ndash;graph \u0026ndash;oneline”使”git glog”相当于”git log \u0026ndash;graph \u0026ndash;oneline”.\ngit config --global core.editor \u0026lt;editor\u0026gt;配置⽂本编辑器，例如vi，在必要时⾃动打开此⽂本编辑器。安装的时候也可以指定默认编辑器。\n# git submodule git submodule init初始化子模块，将子模块的配置信息存储在父仓库中。\n通常执行之后再执行更新子模块使用，如克隆带有子模块的仓库，没有加--recursive，是不会克隆子模块的 初始化子模块之后，执行更新子模块就会根据配置信息下载子模块 git submodule update根据父仓库子模块的配置信息更新子模块，如果没有初始化子模块可以加参数--init，会下载与父项目绑定版本的子模块，若要更新加--remote\n--init初识化子模块 --recursive会递归下载子模块的子模块 --remote根据子模块远程仓库的配置信息更新子模块，会下载最新版本的子模块 注意更新之后要提交更新的版本，否则当在执行更新命令没有加--remote时会退回与父仓库绑定的版本 git submodule add \u0026lt;repository\u0026gt; \u0026lt;path\u0026gt;添加子模块。其中，\u0026lt;repository\u0026gt;是子模块的远程仓库地址，\u0026lt;path\u0026gt;是子模块在主项目中的路径。\n子模块可以当正常仓库使用。创建时\u0026lt;path\u0026gt;路径不能存在文件，更克隆差不多。 # git subtree 作用：将一个仓库中的目录作为另一个仓库，可以指定分支 用途：搭建项目网站时，将项目网站资源推送到gh-pages分支上 git subtree push --prefix=dist origin gh-pages将目录添加到gh-pages分支上，dist为项目网站的目录 git subtree push --prefix=\u0026lt;prefix\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;branch\u0026gt;将子目录的内容推送到远程仓库。它会将当前仓库中子目录的修改推送到指定的远程仓库和分支中。 注意：以这种推送的方式添加的subtree不能执行subtree pull命令，只有通过subtree add添加的才能都执行，但能够执行subtree push命令 git subtree pull --prefix=\u0026lt;prefix\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;branch\u0026gt;这个命令用于从远程仓库更新子目录的内容。它会拉取远程仓库的最新代码，并更新到当前仓库的子目录中。 git subtree add --prefix=\u0026lt;prefix\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;branch\u0026gt;这个命令用于将远程仓库的内容作为子目录添加到当前仓库中。\u0026lt;prefix\u0026gt;是子目录的名称，\u0026lt;repository\u0026gt;是远程仓库的地址，\u0026lt;branch\u0026gt;是要合并的分支。 # git rebase 作用：rebase翻译成变基，顾名思义：改变基准点。可以使提交历史更加清晰和线性。\n原因：通过合并两个不同的分支，提交历史会很错乱。而通过变基，会使得提交历史更加整洁和可读。\n如何实现：就是修改创建分支的起点（基准点），到最新的提交。起点变了，提交历史就简化了。\n命令：\ngit rebase \u0026lt;base\u0026gt;基于\u0026lt;base\u0026gt;对当前分⽀进⾏rebase。\u0026lt;base\u0026gt;可以是commit、分⽀名称、tag或相对于HEAD的commit。 git rebase -i \u0026lt;base\u0026gt;以交互模式对当前分⽀做rebase。 rebase的过程中可能会出现冲突，解决冲突之后需要使用git add命令将解决冲突后的文件标记为已解决，然后，使用git rebase --continue命令继续rebase过程。Git会尝试继续应用剩余的提交。如果再次出现冲突，你需要重复上述解决冲突和继续rebase的步骤。 如果在rebase过程中出现了问题，或者你决定放弃rebase操作，你可以使用git rebase --abort命令来撤销整个rebase操作。 git rebase的注意事项\n避免对已经推送到远程仓库的提交执行rebase操作：这可能会导致提交历史的不一致，给其他协作者带来困扰。 保持工作目录干净：在执行rebase之前，确保你的工作目录中没有未提交的更改。 谨慎使用：由于rebase会改变提交历史，因此在与他人共享分支时要特别小心。通常，在公共分支上应该使用merge而不是rebase。 通过掌握git rebase的用法和注意事项，你可以更有效地管理你的Git仓库，保持代码的清晰和整洁。\n​\n# 扩展 # .gitignore文件 Git提供了.gitignore文件，用于指定哪些文件或目录应该被Git忽略，不纳入版本控制系统中。.gitignore文件是一个文本文件，可以包含一些简单的规则，指定应该忽略哪些文件或目录。以下是一些.gitignore文件的示例规则：\n忽略所有以.tmp结尾的文件：\n1 *.tmp 忽略所有的log文件：\n1 *.log 忽略所有的.idea目录：\n1 .idea/ 忽略所有的build目录及其内容：\n1 build/ 忽略根目录下的config.json文件，但不忽略子目录中的config.json文件：\n1 /config.json 忽略所有的node_modules目录及其内容：\n1 node_modules/ 忽略所有的DS_Store文件（Mac OS X系统中的文件）：\n1 .DS_Store 可以将这些规则写入.gitignore文件中，并将该文件添加到Git仓库中，以使Git忽略这些文件或目录。需要注意的是，即使某些文件或目录已经被添加到Git仓库中，也可以通过修改.gitignore文件来让Git忽略它们，但需要执行以下命令才能使.gitignore文件生效：\n1 2 3 4 git rm -r --cached . git add . git commit -m \u0026#34;update .gitignore\u0026#34; git push 这些命令会删除Git缓存中已经添加的文件，然后重新添加文件并提交更改，以使.gitignore文件生效。\n总结：\n当Git执行提交操作时，它会检查.gitignore文件中列出的文件和目录，并将它们从提交中排除。这是非常有用的，因为有些文件或目录不应该被纳入版本控制系统中，例如编译生成的文件、日志文件、临时文件等。\n.gitignore文件的语法是基于模式匹配的，其中的特殊字符有：\n*：匹配任意字符，但不包括路径分隔符（/）。 ?：匹配任意单个字符，但不包括路径分隔符（/）。 /：路径分隔符，用于指定目录。 !：用于否定模式，即不忽略指定的文件或目录。 可以在.gitignore文件中使用通配符、路径、注释等语法，以更精确地指定需要忽略的文件或目录。同时，可以在仓库的根目录下创建一个.gitignore文件，也可以在子目录中创建独立的.gitignore文件。\n# git账户认证 当我们对远程仓库就行修改时，需要对应的权限，不是什么人都能够修改仓库。只有通过了git账户认证，才能修改对应的仓库。 常见git账户认证的方式： SSH秘钥认证 这是Git中最常见的认证方式之一。用户首先生成一对公钥和私钥，然后将公钥添加到Git服务器上的用户帐户中。当用户尝试与Git服务器进行通信时，Git将使用私钥进行身份验证。这种方式相对安全，因为私钥是保存在用户本地机器上的，不会被传输到Git服务器。 秘钥生成命令：bash中运行ssh-keygen,一直回车就行，秘钥位置：主目录下的.ssh目录 公钥设置位置：github账户Settings-\u0026gt;SSH and GPG keys-\u0026gt;New SSH key将公钥复制粘贴保存就行。 HTTPS认证 在这种方式中，用户需要提供用户名和密码进行身份验证。用户需要在Git服务器上创建一个用户帐户，并将其关联到本地的Git仓库中。当用户执行需要身份验证的操作时，Git会要求输入用户名和密码。这种方式相对简单，适用于个人项目或小型团队。 设置位置：在使用Git进行操作时，如push或pull，系统会提示你输入用户名和密码进行身份验证。 访问令牌（Personal Access Token）认证：不常用 访问令牌提供了一种更安全、更灵活的身份验证方式，因为它可以限制令牌的使用权限，并且可以随时撤销或重新生成令牌。 设置位置：github账户Settings-\u0026gt;Developer Settings-\u0026gt;Personal access tokens-\u0026gt;Tokens (classic)-\u0026gt;Generate new token，然后根据自己的需求设置token的权限。 # ssh-keygen ssh-keygen命令是一个用于生成、管理和转换SSH认证密钥的工具。它支持RSA和DSA两种认证密钥类型，并且提供了多种选项和参数，以满足不同的需求。\n使用ssh-keygen命令，你可以生成新的密钥对，指定密钥的长度、类型以及保存的文件名。生成的私钥将保存在本地，而公钥则用于在SSH服务器上进行身份验证。\n以下是一些常用的ssh-keygen命令选项：\n-t：指定要创建的密钥类型，默认为RSA。 -b：指定密钥长度（以位为单位）。对于RSA密钥，最小要求是768位，默认是2048位。对于DSA密钥，长度必须是1024位（根据FIPS 1862标准规定）。 -f：指定用于保存密钥的文件名。如果不指定，将使用默认值id_rsa（对于私钥）和id_rsa.pub（对于公钥）。 -C：提供一个新注释，通常用于标识密钥的用途或所有者。 -P 和 -N：分别用于提供旧密码和新密码，以保护私钥文件。如果留空，则表示不需要密码。 在生成密钥对后，你可以将公钥复制到需要访问的SSH服务器上，通常是将公钥内容追加到服务器的~/.ssh/authorized_keys文件中。这样，当你使用SSH客户端连接到服务器时，客户端将使用私钥进行身份验证，如果验证成功，你将能够无需输入密码即可登录到服务器。\n请注意，私钥的安全性至关重要。私钥应该妥善保管，并且不应该与其他人共享。同时，定期更换密钥对也是保持安全性的好习惯。\n除了生成和管理密钥对，ssh-keygen还提供了其他功能，如转换密钥格式、读取密钥文件等。你可以通过查看ssh-keygen的帮助文档或手册页（通过运行man ssh-keygen命令）来获取更详细的信息和用法示例。\n","date":"2024-04-22T22:18:17+08:00","permalink":"https://arlettebrook.github.io/en/p/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","title":"Git常用命令"},{"content":" # 静态网页生成器 无论您需要搭建个人博客还是为您的项目创建文档，静态网页生成器（static site generator）都是一个不错的选择。无需服务器、数据库，只要你熟悉 Markdown，喜欢GitHub，使用生成器创建静态 HTML 文件，然后推送到 GitHub Pages 等免费服务即可。\n# 常见的静态网页生成器 Hugo是由Go语言实现的静态网站生成器。简单、易用、高效、易扩展、快速部署。 jekyll 是一个静态网页、博客生成器 vuepress是基于 Vue 的静态网页生成器 Hexo 是一个由Nodejs驱动的快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 参考：静态网页生成器\n# 快速使用Hugo搭建个人博客站点 # 安装Hugo 根据自己的操作系统，下载已经构建好的Hugo二进制文件官方地址\n官方推荐下载扩展版，支持的功能更多 解压之后，将hugo可执行文件加入到PATH环境变量中，即可使用\n1 2 3 hugo version # 查看版本，扩展版含这个extended标签 hugo -h # 显示帮助信息 hugo subcommand -h # 获取子命令的帮助信息 # 使用Hugo hugo需要配合git一起使用，并且官方推荐使用bash作为终端\n创建项目并安装主题hugo-theme-stack\n1 2 3 4 5 hugo new site quickstart # 创建目录结构 cd quickstart git init git submodule add https://github.com/CaiJimmy/hugo-theme-stack/ themes/hugo-theme-stack # 安装主题 添加内容并使用安装主题的默认配置\n使用安装主题的实例进行快速添加内容 只需要进入主题文件中的exampleSite中的content拷贝到quickstart根目录中 同理，在主题文件中的exampleSite中的hugo.yaml拷贝到quickstart根目录中，重命名为,并删除hugo.toml 最后运行\n1 2 hugo server # 本地启动一个http服务器，便于开发和测试站点，默认热更新 hugo server --navigateToChanged # 自动重定向：编辑内容时，浏览器会自动重定向到上次修改的页面 会使用到的命令\n1 2 3 4 5 6 7 8 9 10 11 hugo new content post/fist-post.md # 会在content目录下创建post/fist-post.md文件 # 执行完后，会在content/post目录自动生成一个MarkDown格式的first.md文件： +++ date = \u0026#34;2015-01-08T08:36:54-07:00\u0026#34; draft = true title = \u0026#34;Fist Post\u0026#34; +++ # draft 默认为true，构建网站时不会构建该文档 # 要构建草稿文档可以用-D或--buildDrafts选项启动服务 hugo server -D # title 默认为文件名首字母大写 构建命令\n进入项目目录，运行\n1 hugo hugo命令会构建生成静态文件，会将文件发布项目的public目录下\n要将站点发布到其他目录，请使用该标志--destination或在站点配置中设置publishDir\n注意：每次构建不会清空public目录，只会覆盖旧内容。\n这样做是为了防止，构建之后在public添加的文件被删除\n草稿、未来和过期内容\nHugo 允许在内容的前面设置draft、date、publishDate和expiryDate。默认情况下，Hugo 在以下情况下不会发布内容：\n其draft值为true\n是date在未来\n是publishDate在未来\n已经expiryDate过去了\n下面的行为可以取消\n1 2 3 hugo --buildDrafts # or -D hugo --buildExpired # or -E hugo --buildFuture # or -F 注意：当这样构建之后，需要手动删除不期望构建的文件，在推送站点\n否则当推送到远程会出现意外的内容\n所以建议运行上面的命令之后，前提public中没有手动添加的文件，在构建之前手动清空public目录，防止出现草稿、过期和未来的内容\n最后将public中的所以文件推送到静态网站托管平台即可\n也可以使用自动构建和部署 更多内容参考：\n使用hugo搭建个人博客站点 （1）带着Stack主题入坑Hugo （2）部署你的Hugo博客 （3）Stack主题的自定义 自定义主题添加了assets/scss、layouts/_default/、layouts/index.html,不用了删了就行 # 目录结构 archetypes目录包含新内容的模板\n目录下的default.md由标记（markdown）和内容格式\n内容格式：\u0026mdash;yaml\u0026mdash;、+++toml+++、{json}\n1 2 3 4 5 --- # +++/{ date: \u0026#39;{{ .Date }}\u0026#39; # yaml draft: true title: \u0026#39;{{ replace .File.ContentBaseName `-` ` ` | title }}\u0026#39; --- # +++/{ 当运行hugo new content post/my-first-post.md命令时会根据default.md创建内容文件\n1 2 3 4 5 --- date: \u0026#34;2023-08-24T11:49:46-07:00\u0026#34; draft: true title: My First Post --- 可以创建新内容的模版\n1 2 3 archetypes/ ├── default.md └── post.md 若运行hugo new content post/my-first-post.md查找模版的顺序 archetypes/post.md archetypes/default.md themes/my-theme/archetypes/post.md themes/my-theme/archetypes/default.md 如果这些都不存在，Hugo 将使用内置的默认原型 assets目录包含通常通过资产管道传递的全局资源，包括图像、CSS、Sass、JavaScript 和 TypeScript 等资源。\nconfig目录包含站点配置，可能分为多个子目录和文件。对于具有最少配置的项目或不需要在不同环境中表现不同的项目，hugo.toml在项目根目录中命名的单个配置文件就足够了\ncontent目录包含构成站点内容的标记文件（通常是 Markdown）和页面资源。\n对应stack主题： post存放发布的文章格式md page存放导航区域的md格式配置 不同的语言结尾用.en.md等表示 根据模版进行修改即可，根据自己的需求，没有的需要自己补充和修改文件内容 categories存放类别的md格式配置 data目录包含增强内容、配置、本地化和导航的数据文件（JSON、TOML、YAML 或 XML）。\ni18n目录包含多语言站点的翻译表。\ncontent目录包含将内容、数据和资源转换为完整网站的模板。\npublic目录包含运行hugo或hugo server命令时生成的已发布网站。 Hugo 根据需要重新创建该目录及其内容\nresources目录包含 Hugo 资产管道的缓存输出，这些输出是在运行hugo或hugo server命令时生成的。默认情况下，此缓存目录包括 CSS 和图像。 Hugo 根据需要重新创建该目录及其内容。\nstatic目录包含在您构建站点时将复制到公共目录的文件。例如：favicon.ico、robots.txt和 验证站点所有权的文件.与assets差不多\nthemes目录包含一个或多个主题，每个主题都位于其自己的子目录中。\n联合文件系统：\n这样理解：安装的主题里面同样有自己站点的目录结构，hugo构建时会将主题里面的文件挂载到站点，优先级是站点的高 # 配置文件 hugo支持三种配置文件hugo.tomal、hugo.yaml、hugo.json，喜欢用那个就用那个。\n每种文件格式的规范：TOML、YAML和JSON。\n配置文件可以有多个，可以放到config目录下，默认都是使用hugo开头的文件\n指定配置文件构建\n1 2 hugo server --config other.toml hugo --config a.toml,b.yaml,c.json # 可以指定多个，左边的优先级高 更多内容配置参考\n额外的一些关于配置文件的总结\n默认语言修改为zh-cn，意味着index.md表示中文，index.zh-cn.md也表示中文，此时的英文要用index.en.md表示 更多内容参考：\nHugo官方文档 Hugo中文文档 Hugo theme # 文章评论 使用Waline，其教程很完整。\n根据Waline教程从头完成到使用Vercel部署完成。\n最后在config.yaml中的waline的serverURL给上你的Vercel服务器地址。\n以及开启评论，最后waline还可以配置评论通知渠道。\n将cloudflare解析的域名绑定到vercel文档 概括：添加一条CNAME记录值为cname.vercel-dns.com，开启代理，将SSL/TLS修改为完全 将cloudflare解析的域名绑定到github-pages文档 概括：添加一条子域，类型CNAME记录值为username.github.io，开启代理，将SSL/TLS修改为完全,username为你的用户名 更多内容请查阅文档 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 comments: enabled: true provider: waline waline: serverURL: url lang: zh-cn pageview: true copyright: false emoji: - https://unpkg.com/@waline/emojis@1.0.1/weibo requiredMeta: - name - email locale: admin: 👻Hi! placeholder: 🎉留下你的脚印... # 搜索引擎优化（SEO） 本网站使用Hugo搭建，而且使用的stack主题支持自动生成基于Open Graph协议（OG协议）的标签，此处记录一下如何在Hugo搭建的网站中做搜索引擎优化（SEO）。\n目的：提升网站在搜索引擎中的排名\nOpen Graph（开放图谱）协议，简称OG协议，是Facebook在2010年公布的一项协议，用来标记网页内容。简单来讲，OG协议就是嵌在网页头部的一些标签，这些标签标记了网页的标题、描述等特征，使得网页成为一个“富媒体对象”，可以被其他社交网站引用。\n很多搜索引擎都支持OG协议，在网页中使用OG协议的标签，就更有利于提升我们的网页在搜索引擎中的排名。\nOG协议的标签在网页中通常表示为类似下面所示的格式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;meta property=\u0026#34;og:title\u0026#34; content=\u0026#34;The Rock\u0026#34; /\u0026gt; \u0026lt;meta property=\u0026#34;og:type\u0026#34; content=\u0026#34;video.movie\u0026#34; /\u0026gt; \u0026lt;meta property=\u0026#34;og:url\u0026#34; content=\u0026#34;https://www.imdb.com/title/tt0117500/\u0026#34; /\u0026gt; \u0026lt;meta property=\u0026#34;og:image\u0026#34; content=\u0026#34;https://ia.media-imdb.com/images/rock.jpg\u0026#34; /\u0026gt; \u0026lt;meta property=\u0026#39;og:url\u0026#39; content=\u0026#39;https://arlettebrook.github.io/search/\u0026#39;\u0026gt; \u0026lt;meta property=\u0026#39;og:site_name\u0026#39; content=\u0026#39;Arlettebrook\u0026amp;#39;s blog\u0026#39;\u0026gt; \u0026lt;meta property=\u0026#39;og:type\u0026#39; content=\u0026#39;article\u0026#39;\u0026gt;\u0026lt;meta property=\u0026#39;article:section\u0026#39; content=\u0026#39;P age\u0026#39; /\u0026gt; -\u0026lt;meta name=\u0026#34;twitter:title\u0026#34; content=\u0026#34;搜索\u0026#34;\u0026gt; +\u0026lt;meta name=\u0026#34;twitter:site\u0026#34; content=\u0026#34;@arlettebrook\u0026#34;\u0026gt; + \u0026lt;meta name=\u0026#34;twitter:creator\u0026#34; content=\u0026#34;@arlettebrook\u0026#34;\u0026gt;\u0026lt;meta name=\u0026#34;twitter:title\u0026#34; co ntent=\u0026#34;搜索\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;twitter:description\u0026#34; content=\u0026#34;\u0026#34;\u0026gt;\u0026lt;link rel=\u0026#34;alternate\u0026#34; type=\u0026#34;application/js on\u0026#34; href=\u0026#34;https://arlettebrook.github.io/search/index.json\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;shortcut icon\u0026#34; href=\u0026#34;/img/favicon.ico\u0026#34; /\u0026gt; stack主题提供了对OG协议的支持，只需要在网站根目录下的config/_default/params.en.yaml和config/_default/params.zh-cn.yaml配置文件中开启即可：\n1 2 3 4 5 6 7 opengraph: twitter: # Your Twitter username site: JinliCyou # Available values: summary, summary_large_image card: summary_large_image 这样，Hugo在生成和部署网站时就会在网页HTML文件中自动嵌入OG标签。\n参考：个人网站的建立过程（四）：网站的搜索引擎优化（SEO）\n# 额外的一些知识 gh-pages 是GitHub 所提供的一个服务，简单来讲就是可以让你不用花钱也可以部署一个静态网页作为展示用，因此对于前端工程师来讲就非常方便而且很实用，但是部署方式有很多。\ngh-pages是github-pages的缩写，可以用于个人博客和项目介绍的网站服务。\ngh-pages也是github特殊的分支，用来存放网站相关的一些资源，通常网站地址为username.github.io/仓库名\n项目名与username.github.io一样的话，可以省略仓库名，跟github个人资料页面一样，所以这个仓库是一个特殊的仓库，默认会自动开启gh-pages服务。别的需要手动。\n虽然gh-pages 是属于免费的服务，基本上只要你持有GitHub 帐号就可以使用，但是它基本上有几个重点可以稍微注意一下：\n只能放置纯静态网页，也就是说没有后端的网页，例如PHP、Node.js、Python 等等，只能是纯HTML、CSS、JavaScript 等等，因为它并没有运算能力。 gh-pages 是以储存库为单位，也就是说每个储存库都可以有一个gh-pages 分支，但是每个储存库只能有一个gh-pages 分支，因此如果你想要部署多个网页，那么你就需要建立多个储存库。 gh-pages 的容量是有限制的，每个储存库的容量是1GB，如果你的网页超过这个容量，那么就无法部署。 gh-pages 的流量为每月100GB gh-pages 每小时只能部署10 次，如果是使用自己写的GitHub Actions 就没有这个限制（毕竟要花钱）。 免费的ssh 凭证 预设的网域是https://\u0026lt;username\u0026gt;.github.io/\u0026lt;repository\u0026gt;，如果你想要使用自己的网域，那么你就需要花钱购买网域，并且设定DNS 最后要稍微注意一下gh-pages 虽然是免费提供的静态网页托管服务，但是它并不能拿来作为商业用途或是违法用途，否则你的帐号可能会被封锁\n简单说一下如何查看一个仓库是否启用gh-pages：进入项目settings-pages查看即可，有绿色钩就启动成功，没有需要指定分支和根目录，保存，稍等一会就行。\n# 用gh-pages分支展示自己的项目 我们只需要将网页资源上传至gh-pages分支即可\n搭建项目网站：将项目网站资源推送到gh-pages分支上,静态资源必须提交了才会成功\n1 git subtree push --prefix=dist origin gh-pages # dist为项目网站的目录 拉取指定分支\n1 2 3 4 5 6 7 8 git fetch origin # 获取origin仓库的信息 git checkout -b aaa origin/aaa # 创建并检出分支 # git clone之后也也可以检出分支 git checkout gh-page # 失败用上面办法 # 在git clone 的时候可以指定分支-b选项 git clone -b url 如果要项目中不含自己网站的源码，可以忽略public目录，将public目录创建为一个私有仓库的子目录，然后将子目录作为，项目的gh-pages分支。\n# 通过Actions自动部署gh-pages 执行Actions需要git账户认证，方式是SSH秘钥认证。\n所以需要设置ssh秘钥。\n生成秘钥：在bash中运行ssh-keygen,秘钥类型默认为rsa。可以给这个秘钥设置备注加-C选项，参数一般为拥有者邮箱，一直回车就行。秘钥保存位置：默认用户主目录下的.ssh。公钥就是id_rsa.pub\n建议将生成的这个秘钥对与本机认证的ssh秘钥对分开，保存到另外的一个地方。回车的时候修改位置就行。 设置公钥：\ngithub账户Settings-\u0026gt;SSH and GPG keys-\u0026gt;New SSH key将公钥复制粘贴保存就行。这种方式，只有有私钥，就能操作所有仓库，不推荐使用。 (自动构建之后)选择要推送的仓库Settings-\u0026gt;Deploy keys-\u0026gt;Add deploy key将公钥复制粘贴保存就行。title随意。注意勾选Allow write access。只针对该仓库有权限。推荐使用。 设置私钥：\n进入Actions所在的仓库Settings-\u0026gt;Secrets and variables-\u0026gt;Actions-\u0026gt;New repository secret。秘钥名称为ACTIONS_DEPLOY_KEY，值为私钥id_rsa的文件内容。最后保存就行。 添加workflows配置文件\n在构建仓库的根目录下创建.github/workflows目录，然后创建auto-deploy-gh-pages.yaml文件，内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 name: Deploy github pages on: push: branches: - main # main 更新触发 # Allows you to run this workflow manually from the Actions tab workflow_dispatch: jobs: auto-deploy-github-pages: runs-on: ubuntu-latest steps: - name: Checkout code uses: actions/checkout@v4 with: submodules: true # clone submodules fetch-depth: 0 # 克隆所有历史信息 - name: Setup Hugo uses: peaceiris/actions-hugo@v3 with: hugo-version: \u0026#34;0.125.4\u0026#34; # Hugo 版本 extended: true # hugo插件版 Stack主题 必须启用 - name: Cache resources # 缓存 resource 文件加快生成速度 uses: actions/cache@v4 with: path: resources # 检查照片文件变化 key: ${{ runner.os }}-hugocache-${{ hashFiles(\u0026#39;content/**/*\u0026#39;) }} restore-keys: ${{ runner.os }}-hugocache- - name: Build # 生成网页 删除无用 resource 文件 削减空行 run: hugo --minify --gc - name: Deploy # 部署到 GitHub Page uses: peaceiris/actions-gh-pages@v3 with: # 如果在同一个仓库下使用请使用 github_token 并注释 deploy_key # github_token: ${{ secrets.GITHUB_TOKEN }} deploy_key: ${{ secrets.ACTIONS_DEPLOY_KEY }} # 如果在同一个仓库请注释 external_repository: arlettebrook/arlettebrook.github.io # 你的 GitHub page 仓库 example/example.github.io publish_branch: main # 默认gh-pages # cname: blog.trojan123.top # 自定义域名 publish_dir: ./public user_name: \u0026#34;github-actions[bot]\u0026#34; user_email: \u0026#34;github-actions[bot]@users.noreply.github.com\u0026#34; # full_commit_message: Deploy from ${{ github.repository }}@${{ github.sha }} 🚀 # commit_message: ${{ github.event.head_commit.message }} full_commit_message: ${{ github.event.head_commit.message }} 🚀 From ${{ github.repository }}@${{ github.sha }} 注意你要将external_repository项里的arlettebrook/arlettebrook.github.io改为你要推送的仓库。cname为你绑定的自定义域名。\n忽略不必要的文件\n在构建项目根目录下创建.gitignore文件，内容如下：\n1 2 3 4 public resources assets/jsconfig.json .hugo_build.lock 最后将构建项目推送到远程就行，这样每次推送构建项目的main分支到远程，就会自动构建并推送到指定仓库。\n查看是否构建成功：进入构建项目的Actions选项里面即可查看。\n参考：（2）部署你的Hugo博客\n","date":"2024-04-22T16:12:26+08:00","image":"https://arlettebrook.github.io/p/%E5%9F%BA%E4%BA%8Ehugo%E5%92%8Cgh-pages%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99/hugo_hu45a5e3ad5e058da6a00650ed8fd40bea_15530_120x120_fill_q75_box_smart1.jpg","permalink":"https://arlettebrook.github.io/en/p/%E5%9F%BA%E4%BA%8Ehugo%E5%92%8Cgh-pages%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99/","title":"基于Hugo和gh-pages快速搭建静态网站"}]