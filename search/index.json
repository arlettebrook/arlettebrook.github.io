[{"content":" # Go代码约定 Go代码约定是@unknwon为 Go 编程语言制定的 100% 固执己见和偏执的代码约定。它可能与Go 代码审查注释或任何其他指南兼容，也可能不兼容。\n总之，以下介绍的的约定，在大部分Go开源项目中都遵循。\n# 版权声明 作为开源项目，必须有相应的开源许可证才能算是真正的开源。在选择了一个开源许可证之后，需要在源文件中进行相应的版权声明才能生效。以下分别以 Apache License, Version 2.0 和 MIT 授权许可为例。\n# Apache License, Version 2.0 该许可证要求在所有的源文件中的头部放置以下内容才能算协议对该文件有效：\n1 2 3 4 5 6 7 8 9 10 11 12 13 // Copyright [yyyy] [name of copyright owner] [\u0026lt;联系方式\u0026gt;] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;): you may // not use this file except in compliance with the License. You may obtain // a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, WITHOUT // WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the // License for the specific language governing permissions and limitations // under the License. 其中，[yyyy] 表示该源文件创建的年份。紧随其后的是 [name of copyright owner]，即版权所有者。如果为个人项目，就写个人名称；若为团队项目，则宜写团队名称。[\u0026lt;联系方式\u0026gt;]：联系方式，通常为邮箱。\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 // Copyright 2013-2023 The Cobra Authors // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. # MIT License 一般使用 MIT 授权的项目，需在源文件头部增加以下内容：\n1 2 3 // Copyright [yyyy] [name of copyright owner] [\u0026lt;联系方式\u0026gt;]. All rights reserved. // Use of this source code is governed by a MIT-style // license that can be found in the LICENSE file. 其中，年份、版权所有者的名称以及联系方式填写规则与 Apache License, Version 2.0 的一样。\n示例:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /* Copyright © 2024 arlettebrook \u0026lt;arlettebrook@proton.me\u0026gt; Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \u0026#34;Software\u0026#34;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \u0026#34;AS IS\u0026#34;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */ package main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello, world!\u0026#34;) } # 其它说明 其它类型的开源许可证基本上都可参照以上两种方案。\n如果存在不同作者或组织对同个源文件的修改，在协议兼容的情况下，可将首行变为多行，按照先后次序排放：\n1 2 // Copyright 2011 Gary Burd // Copyright 2013 Unknwon 在 README 文件最后中需要说明项目所采用的开源许可证：\n1 2 3 ## 授权许可 本项目采用 MIT 开源授权许可证，完整的授权说明已放置在 [LICENSE](LICENSE) 文件中。 开源协议介绍参考.\n# 项目结构 以下为一般项目结构，根据不同的 Web 框架习惯，可使用括号内的文字替换；根据不同的项目类型和需求，可自由增删某些结构：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 - templates (views) # 模板文件 - public (static) # 静态文件 - css - fonts - img - js - routes # 路由逻辑处理 - models\t# 数据逻辑层 - pkg # 子模块 - setting # 应用配置存取 - cmd # 命令行程序命令 - conf # 默认配置 - locale # i18n 本地化文件 - custom # 自定义配置 - data # 应用生成数据文件 - log # 应用生成日志文件 # 命令行应用 当应用类型为命令行应用时，需要将命令相关文件存放于 /cmd 目录下，并为每个命令创建一个单独的源文件：\n1 2 3 4 5 6 /cmd dump.go fix.go serve.go update.go web.go # 导入标准库、第三方或其它包 除标准库外，Go 语言的导入路径基本上依赖代码托管平台上的 URL 路径，因此一个源文件需要导入的包有 4 种分类：标准库、第三方包、组织内其它包和当前包的子包。\n基本规则：\n如果同时存在 2 种及以上，则需要使用分组来导入。每个分类使用一个分组，采用空行作为分区之间的分割。 在非测试文件（*_test.go）中，禁止使用 . 来简化导入包的对象调用。 禁止使用相对路径导入（./subpackage），所有导入路径必须符合 go get 标准。 下面是一个完整的示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import ( \u0026#34;fmt\u0026#34; \u0026#34;html/template\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;os\u0026#34; \u0026#34;github.com/codegangsta/cli\u0026#34; \u0026#34;gopkg.in/macaron.v1\u0026#34; \u0026#34;github.com/gogits/git\u0026#34; \u0026#34;github.com/gogits/gfm\u0026#34; \u0026#34;github.com/gogits/gogs/routers\u0026#34; \u0026#34;github.com/gogits/gogs/routers/repo\u0026#34; \u0026#34;github.com/gogits/gogs/routers/user\u0026#34; ) 通常我们都不需要关注，包是如何分组的。只需要运行goimports命令，即可自动导入，自动分组。\n在许多ide中，建议不要使用自带的导入。它们分组不是很准确，建议使用goimports。如：在GoLand中，我们只需要在File Watchers中勾选goimports命令，即可实现自动导入、分组。\n# 注释规范 所有导出对象都需要注释说明其用途；非导出对象根据情况进行注释。 如果对象可数且无明确指定数量的情况下，一律使用单数形式和一般进行时描述；否则使用复数形式。 包、函数、方法和类型的注释说明都是一个完整的句子。 句子类型的注释首字母均需大写；短语类型的注释首字母需小写。 注释的单行长度不能超过 80 个字符。 # 包级别 包级别的注释就是对包的介绍，只需在同个包的任一源文件中说明即可有效。\n对于 main 包，一般只有一行简短的注释用以说明包的用途，且以项目名称开头：\n1 2 // Gogs (Go Git Service) is a painless self-hosted Git Service. package main 对于一个复杂项目的子包，一般情况下不需要包级别注释，除非是代表某个特定功能的模块。\n对于简单的非 main 包，也可用一行注释概括。\n对于相对功能复杂的非 main 包，一般都会增加一些使用示例或基本说明，且以 Package \u0026lt;name\u0026gt; 开头：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /* Package regexp implements a simple library for regular expressions. The syntax of the regular expressions accepted is: regexp: concatenation { \u0026#39;|\u0026#39; concatenation } concatenation: { closure } closure: term [ \u0026#39;*\u0026#39; | \u0026#39;+\u0026#39; | \u0026#39;?\u0026#39; ] term: \u0026#39;^\u0026#39; \u0026#39;$\u0026#39; \u0026#39;.\u0026#39; character \u0026#39;[\u0026#39; [ \u0026#39;^\u0026#39; ] character-ranges \u0026#39;]\u0026#39; \u0026#39;(\u0026#39; regexp \u0026#39;)\u0026#39; */ package regexp 特别复杂的包说明，可单独创建 文件来加以说明。\ndoc.go专门书写该go文件所在包的文档介绍。 # 结构、接口及其它类型 类型的定义一般都以单数形式描述：\n1 2 // Request represents a request to run a command. type Request struct { ... 如果为接口，则一般以以下形式描述：\n1 2 // FileInfo is the interface that describes a file and is returned by Stat and Lstat. type FileInfo interface { ... # 函数与方法 函数与方法的注释需以函数或方法的名称作为开头：\n1 // Post returns *BeegoHttpRequest with POST method. 如果一句话不足以说明全部问题，则可换行继续进行更加细致的描述：\n1 2 // Copy copies file from source to target path. // It returns false and error when error occurs in underlying function calls. 若函数或方法为判断类型（返回值主要为 bool 类型），则以 \u0026lt;name\u0026gt; returns true if 开头：\n1 2 // HasPrefix returns true if name has any string in given slice as prefix. func HasPrefix(name string, prefixes []string) bool { ... # 其它说明 当某个部分等待完成时，可用 TODO: 开头的注释来提醒维护人员。\n当某个部分存在已知问题进行需要修复或改进时，可用 FIXME: 开头的注释来提醒维护人员。\n当需要特别说明某个问题时，可用 NOTE: 开头的注释：\n1 2 3 // NOTE: os.Chmod and os.Chtimes don\u0026#39;t recognize symbolic link, // which will lead \u0026#34;no such file or directory\u0026#34; error. return os.Symlink(target, dest) 注意：NOTE:部分ide不支持高亮。\n# 命名规则 # 文件名 整个应用或包的主入口文件应当是 main.go 或与应用名称简写相同。例如：Gogs 的主入口文件名为 gogs.go。 # 函数或方法 若函数或方法为判断类型（返回值主要为 bool 类型），则名称应以 Has, Is, Can 或 Allow 等判断性动词开头：\n1 2 3 4 func HasPrefix(name string, prefixes []string) bool { ... } func IsEntry(name string, entries []string) bool { ... } func CanManage(name string) bool { ... } func AllowGitHook() bool { ... } # 常量 常量均需使用全部大写字母组成，并使用下划线分词：\n1 const APP_VER = \u0026#34;0.7.0.1110 Beta\u0026#34; 如果是枚举类型的常量，需要先创建相应类型：\n1 2 3 4 5 6 type Scheme string const ( HTTP Scheme = \u0026#34;http\u0026#34; HTTPS Scheme = \u0026#34;https\u0026#34; ) 如果模块的功能较为复杂、常量名称容易混淆的情况下，为了更好地区分枚举类型，可以使用完整的前缀：\n1 2 3 4 5 6 7 type PullRequestStatus int const ( PULL_REQUEST_STATUS_CONFLICT PullRequestStatus = iota PULL_REQUEST_STATUS_CHECKING PULL_REQUEST_STATUS_MERGEABLE ) # 变量 变量命名基本上遵循相应的英文表达或简写。\n在相对简单的环境（对象数量少、针对性强）中，可以将一些名称由完整单词简写为单个字母，例如：\nuser 可以简写为 u userID 可以简写 uid 若变量类型为 bool 类型，则名称应以 Has, Is, Can 或 Allow 开头：\n1 2 3 4 var isExist bool var hasConflict bool var canManage bool var allowGitHook bool 上面的规则也适用于结构体字段定义：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // Webhook represents a web hook object. type Webhook struct { ID int64 `xorm:\u0026#34;pk autoincr\u0026#34;` RepoID int64 OrgID int64 URL string `xorm:\u0026#34;url TEXT\u0026#34;` ContentType HookContentType Secret string `xorm:\u0026#34;TEXT\u0026#34;` Events string `xorm:\u0026#34;TEXT\u0026#34;` *HookEvent `xorm:\u0026#34;-\u0026#34;` IsSSL bool `xorm:\u0026#34;is_ssl\u0026#34;` IsActive bool HookTaskType HookTaskType Meta string `xorm:\u0026#34;TEXT\u0026#34;` // store hook-specific attributes LastStatus HookStatus // Last delivery status Created time.Time `xorm:\u0026#34;CREATED\u0026#34;` Updated time.Time `xorm:\u0026#34;UPDATED\u0026#34;` } # 变量命名惯例 变量名称一般遵循驼峰法，但遇到特有名词时，需要遵循以下规则：\n如果变量为私有，且特有名词为首个单词，则使用小写，如 apiClient。 其它情况都应当使用该名词原有的写法，如 APIClient、GET、UserID。 下面列举了一些常见的特有名词：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // A GonicMapper that contains a list of common initialisms taken from golang/lint var LintGonicMapper = GonicMapper{ \u0026#34;API\u0026#34;: true, \u0026#34;ASCII\u0026#34;: true, \u0026#34;CPU\u0026#34;: true, \u0026#34;CSS\u0026#34;: true, \u0026#34;DNS\u0026#34;: true, \u0026#34;EOF\u0026#34;: true, \u0026#34;GUID\u0026#34;: true, \u0026#34;HTML\u0026#34;: true, \u0026#34;HTTP\u0026#34;: true, \u0026#34;HTTPS\u0026#34;: true, \u0026#34;ID\u0026#34;: true, \u0026#34;IP\u0026#34;: true, \u0026#34;JSON\u0026#34;: true, \u0026#34;LHS\u0026#34;: true, \u0026#34;QPS\u0026#34;: true, \u0026#34;RAM\u0026#34;: true, \u0026#34;RHS\u0026#34;: true, \u0026#34;RPC\u0026#34;: true, \u0026#34;SLA\u0026#34;: true, \u0026#34;SMTP\u0026#34;: true, \u0026#34;SSH\u0026#34;: true, \u0026#34;TLS\u0026#34;: true, \u0026#34;TTL\u0026#34;: true, \u0026#34;UI\u0026#34;: true, \u0026#34;UID\u0026#34;: true, \u0026#34;UUID\u0026#34;: true, \u0026#34;URI\u0026#34;: true, \u0026#34;URL\u0026#34;: true, \u0026#34;UTF8\u0026#34;: true, \u0026#34;VM\u0026#34;: true, \u0026#34;XML\u0026#34;: true, \u0026#34;XSRF\u0026#34;: true, \u0026#34;XSS\u0026#34;: true, } # 声明语句 # 函数或方法 函数或方法的参数排列顺序遵循以下几点原则（从左到右）：\n参数的重要程度与逻辑顺序 简单类型优先于复杂类型 尽可能将同种类型的参数放在相邻位置，则只需写一次类型 示例:\n以下声明语句，User 类型要复杂于 string 类型，但由于 Repository 是 User 的附属品，首先确定 User 才能继而确定 Repository。因此，User 的顺序要优先于 repoName。\n1 func IsRepositoryExist(user *User, repoName string) (bool, error) { ... ​\n# 代码指导 # 基本约束 所有应用的 main 包需要有 APP_VER 常量表示版本，格式为 X.Y.Z.Date [Status]，例如：0.7.6.1112 Beta。\n单独的库需要有函数 Version 返回库版本号的字符串，格式为 X.Y.Z[.Date]。\n当单行代码超过 80 个字符时，就要考虑分行。分行的规则是以参数为单位将从较长的参数开始换行，以此类推直到每行长度合适：\n1 2 3 So(z.ExtractTo( path.Join(os.TempDir(), \u0026#34;testdata/test2\u0026#34;), \u0026#34;dir/\u0026#34;, \u0026#34;dir/bar\u0026#34;, \u0026#34;readonly\u0026#34;), ShouldBeNil) 当单行声明语句超过 80 个字符时，就要考虑分行。分行的规则是将参数按类型分组，紧接着的声明语句的是一个空行，以便和函数体区别：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // NewNode initializes and returns a new Node representation. func NewNode( importPath, downloadUrl string, tp RevisionType, val string, isGetDeps bool) *Node { n := \u0026amp;Node{ Pkg: Pkg{ ImportPath: importPath, RootPath: GetRootPath(importPath), Type: tp, Value: val, }, DownloadURL: downloadUrl, IsGetDeps: isGetDeps, } n.InstallPath = path.Join(setting.InstallRepoPath, n.RootPath) + n.ValSuffix() return n } 分组声明一般需要按照功能来区分，而不是将所有类型都分在一组：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const ( // Default section name. DEFAULT_SECTION = \u0026#34;DEFAULT\u0026#34; // Maximum allowed depth when recursively substituing variable names. _DEPTH_VALUES = 200 ) type ParseError int const ( ERR_SECTION_NOT_FOUND ParseError = iota + 1 ERR_KEY_NOT_FOUND ERR_BLANK_SECTION_NAME ERR_COULD_NOT_PARSE ) 当一个源文件中存在多个相对独立的部分时，为方便区分，需使用由 ASCII Generator 提供的句型字符标注（示例：Comment）：\n1 2 3 4 5 6 // _________ __ // \\_ ___ \\ ____ _____ _____ ____ _____/ |_ // / \\ \\/ / _ \\ / \\ / \\_/ __ \\ / \\ __\\ // \\ \\___( \u0026lt;_\u0026gt; ) Y Y \\ Y Y \\ ___/| | \\ | // \\______ /\\____/|__|_| /__|_| /\\___ \u0026gt;___| /__| // \\/ \\/ \\/ \\/ \\/ 函数或方法的顺序一般需要按照依赖关系由浅入深由上至下排序，即最底层的函数出现在最前面。例如，下方的代码，函数 ExecCmdDirBytes 属于最底层的函数，它被 ExecCmdDir 函数调用，而 ExecCmdDir 又被 ExecCmd 调用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // ExecCmdDirBytes executes system command in given directory // and return stdout, stderr in bytes type, along with possible error. func ExecCmdDirBytes(dir, cmdName string, args ...string) ([]byte, []byte, error) { ... } // ExecCmdDir executes system command in given directory // and return stdout, stderr in string type, along with possible error. func ExecCmdDir(dir, cmdName string, args ...string) (string, string, error) { bufOut, bufErr, err := ExecCmdDirBytes(dir, cmdName, args...) return string(bufOut), string(bufErr), err } // ExecCmd executes system command // and return stdout, stderr in string type, along with possible error. func ExecCmd(cmdName string, args ...string) (string, string, error) { return ExecCmdDir(\u0026#34;\u0026#34;, cmdName, args...) } 结构附带的方法应置于结构定义之后，按照所对应操作的字段顺序摆放方法：\n1 2 3 4 type Webhook struct { ... } func (w *Webhook) GetEvent() { ... } func (w *Webhook) SaveEvent() error { ... } func (w *Webhook) HasPushEvent() bool { ... } 如果一个结构拥有对应操作函数，大体上按照 CRUD 的顺序放置结构定义之后：\n1 2 3 4 func CreateWebhook(w *Webhook) error { ... } func GetWebhookById(hookId int64) (*Webhook, error) { ... } func UpdateWebhook(w *Webhook) error { ... } func DeleteWebhook(hookId int64) error { ... } 如果一个结构拥有以 Has、Is、Can 或 Allow 开头的函数或方法，则应将它们至于所有其它函数及方法之前；这些函数或方法以 Has、Is、Can、Allow 的顺序排序。\n变量的定义要放置在相关函数之前：\n1 2 3 4 5 6 7 8 var CmdDump = cli.Command{ Name: \u0026#34;dump\u0026#34;, ... Action: runDump, Flags: []cli.Flag{}, } func runDump(*cli.Context) { ... 在初始化结构时，尽可能使用一一对应方式：\n1 2 3 4 5 6 7 AddHookTask(\u0026amp;HookTask{ Type: HTT_WEBHOOK, Url: w.Url, Payload: p, ContentType: w.ContentType, IsSsl: w.IsSsl, }) # 测试用例 单元测试都必须使用 GoConvey 编写，且辅助包覆盖率必须在 80% 以上。 # 使用示例 为辅助包书写使用示例的时，文件名均命名为 example_test.go。 测试用例的函数名称必须以 Test_ 开头，例如：Test_Logger。 如果为方法书写测试用例，则需要以 Text_\u0026lt;Struct\u0026gt;_\u0026lt;Method\u0026gt; 的形式命名，例如：Test_Macaron_Run。 或者用驼峰命名。 # 更多go代码风格指南 Effective Go Go Common Mistakes Go Code Review Comments The Uber Go Style Guide # 总结 本文简单介绍了在编写go程序时，应该遵循的一些风格、约定。尽管内容有很多，不过我们也不必着急，目前许多go的IDE都会帮我们检查这些规范。\n# 参考 原作者：go-code-convention ","date":"2024-05-21T14:48:21+08:00","permalink":"https://arlettebrook.github.io/p/go-code-guide-introduction/","title":"Go Code Guide Introduction"},{"content":" # 简介 go-ini是 Go 语言中用于操作 ini 文件的第三方库。\n本文介绍go-ini库的使用。\n# ini配置文件介绍 ini 是 Windows 上常用的配置文件格式。MySQL 的 Windows 版就是使用 ini 格式存储配置的。\n.ini文件是Initialization File的缩写，即初始化文件，ini文件格式：[节/section/分区/表/段]+键=值。\n节可以为空，但参数（key=value）就需要写在开头。因为一个section没有明显的结束标识符，一个section的开始就是上一个section的结束，或者是文件结束。 所有的section名称都是独占一行，并且section名字都被方括号包围着（[和]）。 ini文件不支持多个方括号嵌套。有的就不以ini配置文件格式读取。 ini配置文件后缀不一定是.ini，也可以是.cfg、.conf或者是.txt。 节名区分大小写，建议用_连接。 所有的参数都是以section为单位结合在一起的。可以有多个参数，但一个参数独占一行。 在section声明后的所有parameters都属于该section。 区分大小写，建议用_连接。 注释（comments）使用分号表示（;）或者#号，在分号、#号后面的文字，直到该行结尾都全部为注释。\n1 2 3 4 5 # app=name app_name = awesome web [mysql] ip = 127.0.0.1 ; database=mysql .ini文件是windows的系统配置文件，统管windows的各项配置，最重要的就是“System.ini”、“System32.ini”和“Win.ini”。该文件主要存放用户所做的选择以及系统的各种参数。用户可以通过修改INI文件，来改变应用程序和系统的很多配置。一般用户就用windows提供的各项图形化管理界面就可实现相同的配置了，但在某些情况，还是要直接编辑.ini才方便，一般只有很熟悉windows才能去直接编辑。\n在Windows系统中，注册表的出现，让INI文件在Windows系统的地位就开始不断下滑，因为注册表独特优点，使应用程序和系统都把许多参数和初始化信息存放进了注册表中。但在某些场合，INI文件还拥有不可替代的地位。 在ini配置文件中，可以使用占位符%(name)s表示用之前已定义的键name的值来替换，这里的s表示值为字符串类型。4\n在section名称中可以用.来表示两个或多个分区之间的父子关系。 1 2 3 4 5 6 7 8 NAME = ini VERSION = v1 IMPORT_PATH = gopkg.in/%(NAME)s.%(VERSION)s [package] CLONE_URL = https://%(IMPORT_PATH)s [package.sub] package的没有父分区。\n如果某个键在子分区中不存在，则会在它的父分区中再次查找，直到没有父分区为止。 ini文件键值如果存在多行用\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;包裹。\n一行写不下可以使用\\，另起一行。\nIgnoreContinuation可以忽略连续行。 # 快速使用 go-ini 是第三方库，使用前需要安装[推荐】：\n1 $ go get -u gopkg.in/ini.v1 也可以使用 GitHub 上的仓库：\n1 $ go get -u github.com/go-ini/ini 为什么推荐gopkg.in,参考文章：gopkg.in介绍\n首先，创建一个my.ini配置文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 app_name = awesome web ; 这是注释 # possible values: DEBUG, INFO, WARNING, ERROR, FATAL log_level = DEBUG # 这也是注释 ; database=mysql [mysql] ip = 127.0.0.1 port = 3306 user = root password = 123456 database = awesome [redis] ip = 127.0.0.1 port = 6381 使用 go-ini 库读取：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;gopkg.in/ini.v1\u0026#34; ) func main() { cfg, err := ini.Load(\u0026#34;my.ini\u0026#34;) if err != nil { log.Fatal(\u0026#34;Fail to read file: \u0026#34;, err) } fmt.Println(\u0026#34;App Name:\u0026#34;, cfg.Section(\u0026#34;\u0026#34;).Key(\u0026#34;app_name\u0026#34;).String()) fmt.Println(\u0026#34;Log Level:\u0026#34;, cfg.Section(\u0026#34;\u0026#34;).Key(\u0026#34;log_level\u0026#34;).String()) fmt.Println(\u0026#34;MySQL IP:\u0026#34;, cfg.Section(\u0026#34;mysql\u0026#34;).Key(\u0026#34;ip\u0026#34;).String()) mysqlPort, err := cfg.Section(\u0026#34;mysql\u0026#34;).Key(\u0026#34;port\u0026#34;).Int() if err != nil { log.Fatal(err) } fmt.Println(\u0026#34;MySQL Port:\u0026#34;, mysqlPort) fmt.Println(\u0026#34;MySQL User:\u0026#34;, cfg.Section(\u0026#34;mysql\u0026#34;).Key(\u0026#34;user\u0026#34;).String()) fmt.Println(\u0026#34;MySQL Password:\u0026#34;, cfg.Section(\u0026#34;mysql\u0026#34;).Key(\u0026#34;password\u0026#34;).String()) fmt.Println(\u0026#34;MySQL Database:\u0026#34;, cfg.Section(\u0026#34;mysql\u0026#34;).Key(\u0026#34;database\u0026#34;).String()) fmt.Println(\u0026#34;Redis IP:\u0026#34;, cfg.Section(\u0026#34;redis\u0026#34;).Key(\u0026#34;ip\u0026#34;).String()) redisPort, err := cfg.Section(\u0026#34;redis\u0026#34;).Key(\u0026#34;port\u0026#34;).Int() if err != nil { log.Fatal(err) } fmt.Println(\u0026#34;Redis Port:\u0026#34;, redisPort) } 在 ini 文件中，每个键值对占用一行，中间使用=隔开，可以有空格，但不是必须得。以#开头的内容为注释。ini 文件是以分区（section）组织的。 分区以[name]开始，在下一个分区前结束。所有分区前的内容属于默认分区，如my.ini文件中的app_name和log_level。\n使用go-ini读取配置文件的步骤如下：\n首先调用ini.Load加载文件，得到配置对象cfg； 然后以分区名调用配置对象的Section方法得到对应的分区对象section，默认分区的名字为\u0026quot;\u0026quot;，也可以使用ini.DefaultSection； 以键名调用分区对象的Key方法得到对应的配置项key对象； 由于文件中读取出来的都是字符串，key对象需根据类型调用对应的方法返回具体类型的值使用，如上面的String、MustInt方法。 运行以下程序，得到输出：\n1 2 3 4 5 6 7 8 9 10 $ go run main.go App Name: awesome web Log Level: DEBUG MySQL IP: 127.0.0.1 MySQL Port: 3306 MySQL User: root MySQL Password: 123456 MySQL Database: awesome Redis IP: 127.0.0.1 Redis Port: 6381 配置文件中存储的都是字符串，所以类型为字符串的配置项不会出现类型转换失败的，故String()方法只返回一个值。 但如果类型为Int/Uint/Float64这些时，转换可能失败。所以Int()/Uint()/Float64()返回一个值和一个错误。\n要留意这种不一致！如果我们将配置中 redis 端口改成非法的数字 x6381，那么运行程序将报错：\n1 2 2024/05/16 11:45:00 strconv.ParseInt: parsing \u0026#34;x6381\u0026#34;: invalid syntax exit status 1 # Must*便捷方法 如果每次取值都需要进行错误判断，那么代码写起来会非常繁琐。为此，go-ini也提供对应的MustType（Type 为Init/Uint/Float64等）方法，这个方法只返回一个值。 同时它接受可变参数，如果类型无法转换，取参数中第一个值返回，并且该参数设置为这个配置的值，下次调用返回这个值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;gopkg.in/ini.v1\u0026#34; ) func main() { cfg, err := ini.Load(\u0026#34;my.ini\u0026#34;) if err != nil { log.Fatal(\u0026#34;Fail to read file: \u0026#34;, err) } redisPort, err := cfg.Section(\u0026#34;redis\u0026#34;).Key(\u0026#34;port\u0026#34;).Int() if err != nil { fmt.Println(\u0026#34;before must, get redis port error:\u0026#34;, err) } else { fmt.Println(\u0026#34;before must, get redis port:\u0026#34;, redisPort) } fmt.Println(\u0026#34;redis Port:\u0026#34;, cfg.Section(\u0026#34;redis\u0026#34;).Key(\u0026#34;port\u0026#34;).MustInt(6381)) redisPort, err = cfg.Section(\u0026#34;redis\u0026#34;).Key(\u0026#34;port\u0026#34;).Int() if err != nil { fmt.Println(\u0026#34;after must, get redis port error:\u0026#34;, err) } else { fmt.Println(\u0026#34;after must, get redis port:\u0026#34;, redisPort) } } 配置文件还是 redis 端口为非数字 x6381 时的状态，运行程序：\n1 2 3 4 $ go run main.go before must, get redis port error: strconv.ParseInt: parsing \u0026#34;x6381\u0026#34;: invalid syntax redis Port: 6381 after must, get redis port: 6381 我们看到第一次调用Int返回错误，以 6381 为参数调用MustInt之后，再次调用Int，成功返回 6381。MustInt源码也比较简单：\n1 2 3 4 5 6 7 8 9 10 11 12 13 func (k *Key) MustInt(defaultVal ...int) int { val, err := k.Int() if len(defaultVal) \u0026gt; 0 \u0026amp;\u0026amp; err != nil { k.value = strconv.FormatInt(int64(defaultVal[0]), 10) return defaultVal[0] } return val } func (k *Key) Int() (int, error) { v, err := strconv.ParseInt(k.String(), 0, 64) return int(v), err } # 加载ini文件对象 go-ini支持从多个数据源加载ini配置文件。\n数据源 可以是 []byte 类型的原始数据，string 类型的文件路径或 io.ReadCloser。可以加载这三个 任意多个 数据，如果是其他的类型会返回错误。调用Load(source interface{}, others ...interface{})函数。\n当创建好ini文件对象之后，我们还可以往里面添加数据源。调用func (f *File) Append(source interface{}, others ...interface{})方法。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 package main import ( \u0026#34;bytes\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;log\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;github.com/go-ini/ini\u0026#34; ) func main() { raw := []byte(`raw=原始数据`) noClose := strings.NewReader(\u0026#34;string=noClose\u0026#34;) cfg, err := ini.Load(raw, \u0026#34;./my.cfg\u0026#34;, io.NopCloser(noClose), io.NopCloser(bytes.NewBufferString(\u0026#34;close=have closer\u0026#34;)), ) if err != nil { log.Fatal(\u0026#34;Load error:\u0026#34;, err) } fmt.Println(cfg.Section(\u0026#34;\u0026#34;).Key(\u0026#34;raw\u0026#34;).String()) fmt.Println(cfg.Section(\u0026#34;\u0026#34;).Key(\u0026#34;username\u0026#34;).String()) fmt.Println(cfg.Section(\u0026#34;\u0026#34;).Key(\u0026#34;string\u0026#34;).String()) fmt.Println(cfg.Section(\u0026#34;\u0026#34;).Key(\u0026#34;close\u0026#34;).String()) err = cfg.Append(io.NopCloser(bytes.NewReader([]byte(\u0026#34;append=append\u0026#34;)))) if err != nil { log.Fatal(\u0026#34;Append error:\u0026#34;, err) } fmt.Println(cfg.Section(\u0026#34;\u0026#34;).Key(\u0026#34;append\u0026#34;).String()) } io.NopCloser函数（no optiontion closer）是将没有Close方法的Reader添加Close方法（转换成实现ReadCloser接口的Reader），只不过是为了防止向bytes.NewReader、strings.NewReader这样的Reader没有Close方法，底层在自动关闭的时候出错。没有关闭操作的Reader，关闭时没任何操作，有的调用自身的Close方法。\n运行程序输出：\n1 2 3 4 5 6 $ go run main.go 原始数据 arlettebrook noClose have closer append 还可以创建一个没有任何数据源的文件对象。调用Empty函数。\n1 cfg := ini.Empty() 调用用LooseLoad的函数加载文件对象，若指定的文件不存在，不会返回错误。Load会返回错误。\n更牛逼的是，当那些之前不存在的文件在重新调用 Reload() 方法的时候突然出现了，那么它们会被正常加载。\n源码是：创建文件对象的时候会加载一次，创建完毕之后又会加载一次。 1 cfg, err := ini.LooseLoad(\u0026#34;filename\u0026#34;, \u0026#34;filename_404\u0026#34;) 默认情况下，当多个数据源中有相同的键时，后面的数据源会覆盖前面的数据源。\n调用 ShadowLoad函数，创建的数据源不会覆盖存在的值。 # 自定义加载ini文件对象 实现上调用Load、LooseLoad、InsensitiveLoad（后面会介绍）、ShadowLoad加载不同配置的文件对象，底层都是调用LoadSources(opts LoadOptions, source interface{}, others ...interface{})函数实现的。不同的配置是通过LoadOptions配置的。后面的参数都是数据源，默认必须有一个数据源：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func Load(source interface{}, others ...interface{}) (*File, error) { return LoadSources(LoadOptions{}, source, others...) } func LooseLoad(source interface{}, others ...interface{}) (*File, error) { return LoadSources(LoadOptions{Loose: true}, source, others...) } func InsensitiveLoad(source interface{}, others ...interface{}) (*File, error) { return LoadSources(LoadOptions{Insensitive: true}, source, others...) } func ShadowLoad(source interface{}, others ...interface{}) (*File, error) { return LoadSources(LoadOptions{AllowShadows: true}, source, others...) } 为了方便使用，都将不同的配置封装到了不同的函数。\n所以利用LoadSources我们可以实现自定义加载不同配置的文件对象。\n加载选项LoadOptions常用的属性：\nLoose：是否忽略文件路径不存在的错误。\nInsensitive：是否启用不敏感加载，作用：忽略键名的大小写。底层是将键都转换为小写。键名包括分区名。\nAllowShadows：是否不覆盖存在键的值。开启不覆盖之后，可以调用ValueWithShadows方法，获取指定分区下所有的重复键的值。\nUnescapeValueDoubleQuotes：是否强制忽略键值两端的双引号。用在多个双引号的值中。\nSkipUnrecognizableLines：是否跳过无法识别的行。默认无法识别就会报错。\nIgnoreContinuation：是否忽略连续换行。就是键值不支持换换行写\\。\nUnparseableSections：标记一个分区为无法解析。当获取无法解析的分区时，调用Body方法会获取该分区的原始数据，未标记无法获取，同时未标记一个无法解析的分区，解析会报错。除非开跳过无法解析的行。\nAllowBooleanKeys: 是否开启布尔键。开启允许只有一个键，而没有值。解析不会报错。值永远为true。保存时也只有键。\nAllowPythonMultilineValues：是否允许解析多行值，用于解析换行之后对齐的字符串。\n1 2 3 4 5 str = --- a b c --- 开启后类似上面的字符串都可以解析。\nIgnoreInlineComment：忽略行内注释。\nSpaceBeforeInlineComment：要求注释符号前必须带有一个空格\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 cfg, err := ini.LoadSources(ini.LoadOptions{ Loose: true, Insensitive: true, UnescapeValueDoubleQuotes: true, AllowShadows: true, IgnoreContinuation: true, SkipUnrecognizableLines: true, UnparseableSections: []string{\u0026#34;COMMENTS\u0026#34;}, }, \u0026#34;my.cfg\u0026#34;, \u0026#34;my.ini\u0026#34;) if err != nil { log.Fatal(err) } body := cfg.Section(\u0026#34;COMMENTS\u0026#34;).Body() fmt.Println(body) // \u0026lt;1\u0026gt;\u0026lt;L.Slide#2\u0026gt; This slide has the fuel listed in the wrong units \u0026lt;e.1\u0026gt; my.cfg:\n1 2 [COMMENTS] \u0026lt;1\u0026gt;\u0026lt;L.Slide#2\u0026gt; This slide has the fuel listed in the wrong units \u0026lt;e.1\u0026gt; # 注意事项 默认情况下，本库会在您进行读写操作时采用锁机制来确保数据时间。但在某些情况下，您非常确定只进行读操作。此时，您可以通过设置 cfg.BlockMode = false 来将读操作提升大约 50-70% 的性能。\n# 操作分区（Section） # 获取分区 在加载配置之后，可以通过Sections方法获取所有分区对象，是切片类型的*Section对象，SectionStrings()方法获取所有分区名。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;gopkg.in/ini.v1\u0026#34; ) func main() { cfg, err := ini.Load(\u0026#34;my.ini\u0026#34;) if err != nil { log.Fatal(\u0026#34;Fail to read file: \u0026#34;, err) } sections := cfg.Sections() sectionStrings := cfg.SectionStrings() for k, v := range sections { fmt.Printf(\u0026#34;section%v: %s\\n\u0026#34;, k+1, v.Name()) } fmt.Print(\u0026#34;sections:\u0026#34;, sectionStrings) } 运行输出 3 个分区：\n1 2 3 4 5 $ go run main.go section1: DEFAULT section2: mysql section3: redis sections:[DEFAULT mysql redis] 调用GetSection(name)获取指定分区，如果分区不存在，会返回错误信息。返回的分区为nil。\n但调用Section(name)会获取指定分区，如果该分区不存在，则会自动创建指定空分区并返回：\n示例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;gopkg.in/ini.v1\u0026#34; ) func main() { cfg, err := ini.Load(\u0026#34;my.ini\u0026#34;) if err != nil { log.Fatal(\u0026#34;Fail to read file: \u0026#34;, err) } newSection, err := cfg.GetSection(\u0026#34;new\u0026#34;) if err != nil { fmt.Println(err) } fmt.Println(newSection) fmt.Println(cfg.SectionStrings()) newSection = cfg.Section(\u0026#34;new\u0026#34;) fmt.Println(newSection) fmt.Println(cfg.SectionStrings()) } 创建之后调用SectionStrings方法，新分区也会返回：\n1 2 3 4 5 6 $ go run main.go section \u0026#34;new\u0026#34; does not exist \u0026lt;nil\u0026gt; [DEFAULT mysql redis] \u0026amp;{0xc000152000 new map[] [] map[] false } [DEFAULT mysql redis new] 也可以手动创建一个新分区，如果分区已存在，则返回存在的分区：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;gopkg.in/ini.v1\u0026#34; ) func main() { cfg, err := ini.Load(\u0026#34;my.ini\u0026#34;) if err != nil { log.Fatal(\u0026#34;Fail to read file: \u0026#34;, err) } fmt.Println(cfg.SectionStrings()) mysqlSection, err := cfg.NewSection(\u0026#34;mysql\u0026#34;) if err != nil { fmt.Println(err) } fmt.Println(mysqlSection.Keys()) fmt.Println(cfg.SectionStrings()) newSection, err := cfg.NewSection(\u0026#34;new\u0026#34;) if err != nil { fmt.Println(err) } fmt.Println(newSection.Keys()) fmt.Println(cfg.SectionStrings()) } 运行输出：\n1 2 3 4 5 6 $ go run main.go [DEFAULT mysql redis] [127.0.0.1 3306 root 123456 awesome] [DEFAULT mysql redis] [] [DEFAULT mysql redis new] # 读取父子分区 # 递归读取键值 在获取所有键值的过程中，特殊语法 %(\u0026lt;name\u0026gt;)s 会被应用，其中 \u0026lt;name\u0026gt; 可以是相同分区或者默认分区下的键名。字符串 %(\u0026lt;name\u0026gt;)s 会被相应的键值所替代，如果指定的键不存在，则会用空字符串替代（我测试是保留字符串）。您可以最多使用 99 层的递归嵌套。\n在ini配置文件中，可以使用占位符%(name)s表示用之前已定义的键name的值来替换，这里的s表示值为字符串类型：\n1 2 3 4 5 6 7 8 9 10 # parent_child.ini NAME = ini VERSION = v1 IMPORT_PATH = gopkg.in/%(NAME)s.%(VERSION)s USERNAME = arlettebrook [package] CLONE_URL = https://%(IMPORT_PATH)s [package.sub] 上面在默认分区中设置IMPORT_PATH的值时，使用了前面定义的NAME和VERSION。 在package分区中设置CLONE_URL的值时，使用了默认分区中定义的IMPORT_PATH。\n我们还可以在分区名中使用.表示两个或多个分区之间的父子关系，例如package.sub的父分区为package，package没有父分区。 如果某个键在子分区中不存在，则会在它的父分区中再次查找，直到没有父分区为止：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;gopkg.in/ini.v1\u0026#34; ) func main() { cfg, err := ini.Load(\u0026#34;parent_child.ini\u0026#34;) if err != nil { log.Fatal(\u0026#34;Fail to read file: \u0026#34;, err) } fmt.Println(\u0026#34;Clone url from package.sub:\u0026#34;, cfg.Section(\u0026#34;package.sub\u0026#34;).Key(\u0026#34;CLONE_URL\u0026#34;).String()) fmt.Println(\u0026#34;package没有父分区:\u0026#34;, cfg.Section(\u0026#34;package\u0026#34;).Key(\u0026#34;USERNAME\u0026#34;).String() == \u0026#34;\u0026#34;) } 运行程序输出：\n1 2 3 $ go run main.go Clone url from package.sub: https://gopkg.in/ini.v1 package没有父分区: true 子分区中package.sub中没有键CLONE_URL，返回了父分区package中的值。\npackage分区中没有USERNAME,它并没有父分区，所以返回空字符串。（调用Key方法如果键不存在，会创建该键，值为空字符串。）后面会介绍。\n​\n# 操作键（Key） # 获取键 在指定分区调用GetKey方法，可以获取指定的键。如果键不存在，会返回Error对象和nil。 和分区一样，也可以直接获取键而忽略错误处理，调用Key方法获取指定的键，如果键不存在，会创建该键，值为空字符串。 示例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;gopkg.in/ini.v1\u0026#34; ) func main() { cfg, err := ini.Load(\u0026#34;my.ini\u0026#34;) if err != nil { log.Fatal(\u0026#34;Fail to read file: \u0026#34;, err) } key, err := cfg.Section(ini.DefaultSection).GetKey(\u0026#34;app_name123\u0026#34;) if err != nil { fmt.Println(err) } fmt.Println(key) nothingness := cfg.Section(\u0026#34;mysql\u0026#34;).Key(\u0026#34;app_name123\u0026#34;) fmt.Println(nothingness.String() == \u0026#34;\u0026#34;) } 运行程序输出：\n1 2 3 4 $ go run main.go error when getting key of section \u0026#34;DEFAULT\u0026#34;: key \u0026#34;app_name123\u0026#34; not exists \u0026lt;nil\u0026gt; true 默认分区中，不存在app_name123所以GetKy返回Error和nil。而Key方法返回值为空字符串的*Key类型。\n# 键的其他操作 在某个分区下，调用HasKey方法，能判断该键是否存在。\n在某个分区下，调用NewKey方法，能够在指定分区下创建键，有两个参数，第一个：键名，第二个：值。\n这与创建分区不一样，分区如果存在，会返回存在的分区。 键如果存在，会覆盖值。 在某个分区下，调用Keys方法，能够获取指定分区下所有的*Key对象，是[]*Key类型。\n与SectionStrings方法差不多，调用KeyStrings方法，能够获取所有的键名，是[]string类型。 在某分区下，调用KeysHash方法，能够获取该分区下的所有键值对的map集合。键和值的类型都为string。\n示例如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;gopkg.in/ini.v1\u0026#34; ) func main() { cfg, err := ini.Load(\u0026#34;my.ini\u0026#34;) if err != nil { log.Fatal(\u0026#34;Fail to read file: \u0026#34;, err) } key := cfg.Section(ini.DefaultSection).HasKey(\u0026#34;app_name\u0026#34;) if key { fmt.Println(cfg.Section(ini.DefaultSection).Key(\u0026#34;app_name\u0026#34;).String()) } newKey, err := cfg.Section(ini.DefaultSection).NewKey(\u0026#34;app_name\u0026#34;, \u0026#34;awesome go\u0026#34;) if err != nil { log.Fatal(err) } fmt.Println(newKey.String()) fmt.Printf(\u0026#34;%#v\\n\u0026#34;, cfg.Section(\u0026#34;\u0026#34;).Keys()) fmt.Println(cfg.Section(\u0026#34;\u0026#34;).KeyStrings()) keysHash := cfg.Section(\u0026#34;\u0026#34;).KeysHash() for k, v := range keysHash { fmt.Printf(\u0026#34;%s=%s\\n\u0026#34;, k, v) } } 运行程序输出：\n1 2 3 4 5 6 7 $ go run main.go awesome web awesome go []*ini.Key{(*ini.Key)(0xc00010a690), (*ini.Key)(0xc00010a700)} [app_name log_level] app_name=awesome go log_level=DEBUG 获取上级父分区下所有的键对象。\n1 cfg.Section(\u0026#34;package.sub\u0026#34;).ParentKeys() 当键名为-表示自增键名，在程序中是从#1开始，#number表示，分区之间是相互独立的。\n1 2 3 4 [features] -: Support read/write comments of keys and sections -: Support auto-increment of key names -: Support load multiple files to overwrite key values 1 cfg.Section(\u0026#34;features\u0026#34;).KeyStrings() // []{\u0026#34;#1\u0026#34;, \u0026#34;#2\u0026#34;, \u0026#34;#3\u0026#34;} # 忽略键名的大小写 默认情况下分区名和键名都区分大小写，当调用ini.InsensitiveLoad方法加载配置文件时，能够将所有分区和键名在读取里强制转换为小写，这样当在获取分区或者键的时候，所指定的分区名或键名不区分大小写：\n1 2 3 4 5 6 7 8 9 10 cfg, err := ini.InsensitiveLoad(\u0026#34;filename\u0026#34;) //... // sec1 和 sec2 指向同一个分区对象 sec1, err := cfg.GetSection(\u0026#34;Section\u0026#34;) sec2, err := cfg.GetSection(\u0026#34;SecTIOn\u0026#34;) // key1 和 key2 指向同一个键对象 key1, err := sec1.GetKey(\u0026#34;Key\u0026#34;) key2, err := sec2.GetKey(\u0026#34;KeY\u0026#34;) 为什么在加载的时候开启转换为小写，在调用的时候就能忽略大小？ 因为在调用的时候会判断是否开启转换为小写，是会将查询的分区名或键名强制转换为小写。都转换为小写了，也就能够获取了。 ​\n# 操作键值（Value） 获取一个类型为字符串（string）的值：\n1 val := cfg.Section(\u0026#34;\u0026#34;).Key(\u0026#34;key name\u0026#34;).String() 获取值的同时通过自定义函数进行处理验证：\n1 2 3 4 5 6 val := cfg.Section(\u0026#34;\u0026#34;).Key(\u0026#34;key name\u0026#34;).Validate(func(in string) string { if len(in) == 0 { return \u0026#34;default\u0026#34; } return in }) 如果您不需要任何对值的自动转变功能（例如递归读取），可以直接获取原值（这种方式性能最佳）：\n1 val := cfg.Section(\u0026#34;\u0026#34;).Key(\u0026#34;key name\u0026#34;).Value() 判断某个原值是否存在：\n1 yes := cfg.Section(\u0026#34;\u0026#34;).HasValue(\u0026#34;test value\u0026#34;) 获取其它类型的值调用对应类型的方法。返回值带有Error信息，如果不需要Error信息可以调用MustXxx方法。该方法可以指定默认值，用于转换失败的默认值。没有指定默认值为对应类型的零值。\n1 2 3 4 5 6 7 8 v, err = cfg.Section(\u0026#34;\u0026#34;).Key(\u0026#34;INT\u0026#34;).Int() v, err = cfg.Section(\u0026#34;\u0026#34;).Key(\u0026#34;TIME\u0026#34;).TimeFormat(time.RFC3339) v, err = cfg.Section(\u0026#34;\u0026#34;).Key(\u0026#34;TIME\u0026#34;).Time() // RFC3339 v = cfg.Section(\u0026#34;\u0026#34;).Key(\u0026#34;INT\u0026#34;).MustInt() v = cfg.Section(\u0026#34;\u0026#34;).Key(\u0026#34;INT\u0026#34;).MustInt(10) v = cfg.Section(\u0026#34;\u0026#34;).Key(\u0026#34;TIME\u0026#34;).MustTimeFormat(time.RFC3339, time.Now()) v = cfg.Section(\u0026#34;\u0026#34;).Key(\u0026#34;TIME\u0026#34;).MustTime(time.Now()) // RFC3339 \u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;包裹的多行字符串跟普通的获取方式一样。\n\\：一行写不下换行写，也是跟普通的获取方式一样，只不过属性IgnoreContinuation，可以忽略连续换行。就是\\不起作用。\n默认情况下字符串中只有两端有引号，无论是单、双、三，都会自动剔除。但当字符串里面有与两端相同的引号，那么引号都会保留。\nUnescapeValueDoubleQuotes属性会移除两端的双引号，只能是双引号。 获取值的时候我们还可以指定候选。如果配置文件中的值不是候选中的值，那么将选用默认值，默认值可以不是候选里面的值。string类型是In方法，其他的是InXxx方法\n1 2 v := cfg.Section(\u0026#34;\u0026#34;).Key(\u0026#34;STRING\u0026#34;).In(\u0026#34;default\u0026#34;, []string{\u0026#34;str\u0026#34;, \u0026#34;arr\u0026#34;, \u0026#34;types\u0026#34;}) v = cfg.Section(\u0026#34;\u0026#34;).Key(\u0026#34;INT\u0026#34;).InInt(10, []int{10, 20, 30}) 验证获取的值是否在指定范围内：有三个参数：第一个：没有在范围内的默认值。第二个：最小值。第三个：最大值。string类型没有范围。\n1 2 3 4 vals = cfg.Section(\u0026#34;\u0026#34;).Key(\u0026#34;FLOAT64\u0026#34;).RangeFloat64(0.0, 1.1, 2.2) vals = cfg.Section(\u0026#34;\u0026#34;).Key(\u0026#34;INT\u0026#34;).RangeInt(0, 10, 20) vals = cfg.Section(\u0026#34;\u0026#34;).Key(\u0026#34;TIME\u0026#34;).RangeTimeFormat(time.RFC3339, time.Now(), minTime, maxTime) vals = cfg.Section(\u0026#34;\u0026#34;).Key(\u0026#34;TIME\u0026#34;).RangeTime(time.Now(), minTime, maxTime) // RFC3339 自动分割键值到切片（slice）。作用：获取一个键的多个值。方法是对应类型加s，并指定分隔符。\n当存在无效输入时，使用零值代替。 注意分隔符不能为空字符串，会出现死循环。可以为空格。 当在前面加上ValidXxxs，存在无效输入时，会忽略掉。 当在前面加上StrictXxxs，存在无效输入时，直接返回错误。 1 2 3 vals = cfg.Section(\u0026#34;\u0026#34;).Key(\u0026#34;INTS\u0026#34;).Ints(\u0026#34;,\u0026#34;) vals = cfg.Section(\u0026#34;\u0026#34;).Key(\u0026#34;INTS\u0026#34;).ValidInts(\u0026#34;,\u0026#34;) vals = cfg.Section(\u0026#34;\u0026#34;).Key(\u0026#34;INTS\u0026#34;).StrictInts(\u0026#34;,\u0026#34;) 修改键的值，调用SetValue方法。\n1 2 username := cfg.Section(\u0026#34;\u0026#34;).Key(\u0026#34;username\u0026#34;) username.SetValue(\u0026#34;Mark\u0026#34;) 在某分区下调用NewBooleanKey方法，会创建布尔键，值永远为true。保存时只有键名。解析时注意要开启AllowBooleanKeys，否则会报错。\n1 key, err := sec.NewBooleanKey(\u0026#34;skip-host-cache\u0026#34;) 默认情况下后面出现的键会覆盖前面存在的键，当开启AllowShadows配置选项时，就是调用ShadowLoad加载数据源。后出现的键不会覆盖前面的值。还可以通过ValueWithShadows方法获取指定分区下重复键的所有值。\n​\n# 操作注释（Comment） 下述几种情况的内容将被视为注释：\n所有以 # 或 ; 开头的行 所有在 # 或 ; 之后的内容 分区标签后的文字 (即 [分区名] 之后的内容) 如果你希望使用包含 # 或 ; 的值，请使用 ``` 或 \u0026quot;\u0026quot;\u0026quot; 进行包覆。\n除此之外，您还可以通过 LoadOptions 完全忽略行内注释：\n1 2 3 cfg, err := ini.LoadSources(ini.LoadOptions{ IgnoreInlineComment: true, }, \u0026#34;app.ini\u0026#34;) 或要求注释符号前必须带有一个空格：\n1 2 3 cfg, err := ini.LoadSources(ini.LoadOptions{ SpaceBeforeInlineComment: true, }, \u0026#34;app.ini\u0026#34;) 在分区或者键上调用Comment属性，会获取该分区或者键的所有注释（能获取头上和后边的）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;gopkg.in/ini.v1\u0026#34; ) func main() { cfg, _ := ini.Load(\u0026#34;my.ini\u0026#34;) c1 := cfg.Section(\u0026#34;mysql\u0026#34;).Comment fmt.Println(c1) fmt.Println() c2 := cfg.Section(\u0026#34;\u0026#34;).Key(\u0026#34;log_level\u0026#34;).Comment fmt.Println(c2) } 运行程序输出：\n1 2 3 4 5 $ go run main.go ; database=mysql # possible values: DEBUG, INFO, WARNING, ERROR, FATAL # 这也是注释 # 保存配置 将配置保存到某个文件，调用SaveTo或SaveToIndent，第二个方法多一个参数，用于指定分区下键的缩进（除默认分区），可以是\\t等：\n1 2 3 // ... err = cfg.SaveTo(\u0026#34;my.ini\u0026#34;) err = cfg.SaveToIndent(\u0026#34;my.ini\u0026#34;, \u0026#34;\\t\u0026#34;) 还可以写入到任何实现 io.Writer 接口的对象中，也是提供了两个方法WriteTo、WriteToIndent：第二个可以指定分区下键的缩进（除默认分区）：\n1 2 3 // ... cfg.WriteTo(writer) cfg.WriteToIndent(writer, \u0026#34;\\t\u0026#34;) 默认情况下，空格将被用于对齐键值之间的等号以美化输出结果，以下代码可以禁用该功能：\n1 ini.PrettyFormat = false 下面我们通过程序生成前面使用的配置文件my.ini并保存：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;gopkg.in/ini.v1\u0026#34; ) func main() { cfg := ini.Empty() defaultSection := cfg.Section(\u0026#34;\u0026#34;) defaultSection.NewKey(\u0026#34;app_name\u0026#34;, \u0026#34;awesome web\u0026#34;) defaultSection.NewKey(\u0026#34;log_level\u0026#34;, \u0026#34;DEBUG\u0026#34;) mysqlSection, err := cfg.NewSection(\u0026#34;mysql\u0026#34;) if err != nil { fmt.Println(\u0026#34;new mysql section failed:\u0026#34;, err) return } mysqlSection.NewKey(\u0026#34;ip\u0026#34;, \u0026#34;127.0.0.1\u0026#34;) mysqlSection.NewKey(\u0026#34;port\u0026#34;, \u0026#34;3306\u0026#34;) mysqlSection.NewKey(\u0026#34;user\u0026#34;, \u0026#34;root\u0026#34;) mysqlSection.NewKey(\u0026#34;password\u0026#34;, \u0026#34;123456\u0026#34;) mysqlSection.NewKey(\u0026#34;database\u0026#34;, \u0026#34;awesome\u0026#34;) redisSection, err := cfg.NewSection(\u0026#34;redis\u0026#34;) if err != nil { fmt.Println(\u0026#34;new redis section failed:\u0026#34;, err) return } redisSection.NewKey(\u0026#34;ip\u0026#34;, \u0026#34;127.0.0.1\u0026#34;) redisSection.NewKey(\u0026#34;port\u0026#34;, \u0026#34;6381\u0026#34;) err = cfg.SaveTo(\u0026#34;my.ini\u0026#34;) if err != nil { fmt.Println(\u0026#34;SaveTo failed: \u0026#34;, err) } err = cfg.SaveToIndent(\u0026#34;my-pretty.ini\u0026#34;, \u0026#34;\\t\u0026#34;) if err != nil { fmt.Println(\u0026#34;SaveToIndent failed: \u0026#34;, err) } cfg.WriteTo(os.Stdout) fmt.Println() cfg.WriteToIndent(os.Stdout, \u0026#34;\\t\u0026#34;) } 运行程序，生成两个文件my.ini和my-pretty.ini，同时控制台输出文件内容。\nmy.ini：\n1 2 3 4 5 6 7 8 9 10 11 12 13 app_name = awesome web log_level = DEBUG [mysql] ip = 127.0.0.1 port = 3306 user = root password = 123456 database = awesome [redis] ip = 127.0.0.1 port = 6381 my-pretty.ini：\n1 2 3 4 5 6 7 8 9 10 11 12 13 app_name = awesome web log_level = DEBUG [mysql] ip = 127.0.0.1 port = 3306 user = root password = 123456 database = awesome [redis] ip = 127.0.0.1 port = 6381 *Indent方法会对默认分区以外分区下的键增加缩进，看起来美观一点。\n# 分区与结构体字段映射 # 映射到结构体 调用MapTo函数或者方法，可以将文件对象映射到结构体。\n当MapTo为方法时，对象是文件对象或分区，参数是要映射的结构体。 为了使用方便，直接将MapTo封装成了函数，该函数接收两个参数，第一个参数：结构体。第二个：数据源。 当对象为分区时，映射到一个分区 创建结构体的时候可以指定默认值，如果数据源没有或类型解析错误将使用默认值 示例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;gopkg.in/ini.v1\u0026#34; ) type Config struct { AppName string `ini:\u0026#34;app_name\u0026#34;` LogLevel string `ini:\u0026#34;log_level\u0026#34;` MySQL MySQLConfig `ini:\u0026#34;mysql\u0026#34;` Redis RedisConfig `ini:\u0026#34;redis\u0026#34;` } type MySQLConfig struct { IP string `ini:\u0026#34;ip\u0026#34;` Port int `ini:\u0026#34;port\u0026#34;` User string `ini:\u0026#34;user\u0026#34;` Password string `ini:\u0026#34;password\u0026#34;` Database string `ini:\u0026#34;database\u0026#34;` } type RedisConfig struct { IP string `ini:\u0026#34;ip\u0026#34;` Port int `ini:\u0026#34;port\u0026#34;` } func main() { cfg, err := ini.Load(\u0026#34;my.ini\u0026#34;) if err != nil { log.Fatal(\u0026#34;load my.ini failed: \u0026#34;, err) } assertMapToError := func(e error) { if e != nil { log.Fatal(\u0026#34;MapTo error:\u0026#34;, err) } } c1 := new(Config) err = cfg.MapTo(\u0026amp;c1) assertMapToError(err) fmt.Println(c1) c2 := new(Config) err = ini.MapTo(c2, \u0026#34;my.ini\u0026#34;) assertMapToError(err) fmt.Println(c2) m := \u0026amp;MySQLConfig{ IP: \u0026#34;localhost\u0026#34;, } err = cfg.Section(\u0026#34;mysql\u0026#34;).MapTo(m) assertMapToError(err) fmt.Println(m) } MapTo内部使用了反射，所以结构体字段必须都是导出的。如果键名与字段名不相同，那么需要在结构标签中指定对应的键名。 这一点与 Go 标准库encoding/json和encoding/xml不同。标准库json/xml解析时可以将键名app_name对应到字段名AppName。而go-ini需要[自定义键名映射器](#键名映射器（Name Mapper）)才能实现这种效果。\n运行程序输出：\n1 2 3 4 $ go run main.go \u0026amp;{awesome web DEBUG {127.0.0.1 3306 root 123456 awesome} {127.0.0.1 6381}} \u0026amp;{awesome web DEBUG {127.0.0.1 3306 root 123456 awesome} {127.0.0.1 6381}} \u0026amp;{127.0.0.1 3306 root 123456 awesome} # 从结构体反射 我们可以调用ReflectFrom函数或方法，将结构体反射成文件对象。\n当为方法时，对象是反射到的文件对象或分区，参数是结构体。\n为了使用方便，将其封装成了函数，接收两个参数。第一个：反射到的文件对象，第二个：结构体 当对象为分区时，反射到分区。\n注意当结构体字段与配置键不同名时需要用结构体标签指定。\n支持的标签：\nini：指定键名，或者分区名。\n有第二个参数omitempty，用，分隔开。值为空时，省略掉，不写入文件对象。\n有第三参数allowshadow，如果不需要前两个标签规则，可以使用 ini:\u0026quot;,,allowshadow\u0026quot; 进行简写。\n作用：将一个键的不同值分行保存，不用分隔符分开。 1 2 3 4 [IP] value = 192.168.31.201 value = 192.168.31.211 value = 192.168.31.221 1 2 3 type IP struct { Value []string `ini:\u0026#34;value,omitempty,allowshadow\u0026#34;` } comment：指定注释，保存到配置注释会在键的头上。\ndelim：指定分隔符。一个键存在多个值的情况，需要指定分隔符。\n1 2 3 4 5 6 7 8 9 10 11 12 13 type Embeded struct { Dates []time.Time `delim:\u0026#34;|\u0026#34; comment:\u0026#34;Time data\u0026#34;` Places []string `ini:\u0026#34;places,omitempty\u0026#34;` None []int `ini:\u0026#34;,omitempty\u0026#34;` } ... Embeded{ []time.Time{time.Now(), time.Now()}, []string{\u0026#34;HangZhou\u0026#34;, \u0026#34;Boston\u0026#34;}, []int{}, } ... 1 2 3 4 5 ; Embeded section [Embeded] ; Time data Dates = 2015-08-07T22:14:22+08:00|2015-08-07T22:14:22+08:00 places = HangZhou,Boston 示例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;gopkg.in/ini.v1\u0026#34; ) type Config struct { AppName string `ini:\u0026#34;app_name\u0026#34;` LogLevel string `ini:\u0026#34;log_level\u0026#34;` MySQL MySQLConfig `ini:\u0026#34;mysql\u0026#34;` Redis RedisConfig `ini:\u0026#34;redis\u0026#34;` } type MySQLConfig struct { IP string `ini:\u0026#34;ip\u0026#34;` Port int `ini:\u0026#34;port\u0026#34;` User string `ini:\u0026#34;user\u0026#34;` Password string `ini:\u0026#34;password\u0026#34;` Database string `ini:\u0026#34;database\u0026#34;` } type RedisConfig struct { IP string `ini:\u0026#34;ip\u0026#34;` Port int `ini:\u0026#34;port\u0026#34;` } func main() { cfg1 := ini.Empty() c1 := Config{ AppName: \u0026#34;awesome web\u0026#34;, LogLevel: \u0026#34;DEBUG\u0026#34;, MySQL: MySQLConfig{ IP: \u0026#34;127.0.0.1\u0026#34;, Port: 3306, User: \u0026#34;root\u0026#34;, Password: \u0026#34;123456\u0026#34;, Database: \u0026#34;awesome\u0026#34;, }, Redis: RedisConfig{ IP: \u0026#34;127.0.0.1\u0026#34;, Port: 6381, }, } assertReflectError := func(e error) { if e != nil { log.Fatal(\u0026#34;Reflect error:\u0026#34;, e) } } err := ini.ReflectFrom(cfg1, \u0026amp;c1) assertReflectError(err) fmt.Println(cfg1.Section(\u0026#34;\u0026#34;).Key(\u0026#34;app_name\u0026#34;).String()) c2 := Config{ AppName: \u0026#34;awesome go\u0026#34;, } cfg2 := ini.Empty() err = cfg2.ReflectFrom(\u0026amp;c2) assertReflectError(err) fmt.Println(cfg2.Section(\u0026#34;\u0026#34;).Key(\u0026#34;app_name\u0026#34;).String()) m := MySQLConfig{ IP: \u0026#34;localhost\u0026#34;, } cfg3 := ini.Empty() err = cfg3.Section(\u0026#34;mysql\u0026#34;).ReflectFrom(\u0026amp;m) assertReflectError(err) fmt.Println(cfg3.Section(\u0026#34;mysql\u0026#34;).Key(\u0026#34;ip\u0026#34;).String()) } 运行程序输出：\n1 2 3 4 $ go run main.go awesome web awesome go localhost # 映射/反射的其它说明 任何嵌入的结构都会被默认认作一个不同的分区，并且不会自动产生所谓的父子分区关联：\n1 2 3 4 5 6 7 8 9 10 11 12 13 type Child struct { Age string } type Parent struct { Name string Child } type Config struct { City string Parent } 示例配置文件：\n1 2 3 4 5 6 7 City = Boston [Parent] Name = Unknwon [Child] Age = 21 如果需要指定嵌入结构体是同一个分区，需要指定标签指定分区名如：ini:\u0026ldquo;Parent\u0026rdquo;。示例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 type Child struct { Age string } type Parent struct { Name string Child `ini:\u0026#34;Parent\u0026#34;` } type Config struct { City string Parent } 示例配置文件：\n1 2 3 4 5 City = Boston [Parent] Name = Unknwon Age = 21 # 自定义键名和键值映射器 # 键名映射器（Name Mapper） 当我们利用结构体标签指定键名时，会觉得太麻烦。为了节省时间并简化代码，go-ini库支持类型为 NameMapper 的名称映射器，该映射器负责结构字段名与分区名和键名之间的映射。\n目前有 2 款内置的映射器：\nAllCapsUnderscore：该映射器将字段名转换至格式 ALL_CAPS_UNDERSCORE 后再去匹配分区名和键名。 TitleUnderscore：该映射器将字段名转换至格式 title_underscore 后再去匹配分区名和键名。 使用方法：只需要将映射MapTo、反射ReflectFrom函数后面加上WithMapper，传惨时，传入对应映射器即可。或者给指定的文件对象指定映射器。属性是 NameMapper，示例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 type Info struct { PackageName string } func main() { err = ini.MapToWithMapper(\u0026amp;Info{}, ini.TitleUnderscore, []byte(\u0026#34;package_name=ini\u0026#34;)) // ... cfg, err := ini.Load([]byte(\u0026#34;PACKAGE_NAME=ini\u0026#34;)) // ... info := new(Info) cfg.NameMapper = ini.AllCapsUnderscore err = cfg.MapTo(info) // ... err = ini.ReflectFromWithMapper(cfg, \u0026amp;Info{}, ini.TitleUnderscore) } # 键值映射器（Value Mapper） 值映射器允许使用一个自定义函数自动展开值的具体内容，例如在运行时获取环境变量：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;gopkg.in/ini.v1\u0026#34; ) type Env struct { Foo string `ini:\u0026#34;foo\u0026#34;` } func main() { cfg, _ := ini.Load([]byte(\u0026#34;[env]\\nfoo = ${USERNAME}\\n\u0026#34;)) cfg.ValueMapper = os.ExpandEnv env := \u0026amp;Env{} _ = cfg.Section(\u0026#34;env\u0026#34;).MapTo(env) fmt.Println(env) } 运行程序输出：\n1 2 $ go run main.go \u0026amp;{Lenovo} 会输出你电脑的用户名。\n# 总结 本文简单介绍了ini配置文件格式，内容来自互联网，仅供参考。还介绍了go-ini库，基本上参考的是其官方文档，官方文档写的非常详细，推荐去看，而且有中文。 作者是无闻，相信做 Go 开发的都不陌生。\n# 参考 ini配置文件格式 go-ini GitHub 仓库 go-ini 官方文档 Go 每日一库之 go-ini ","date":"2024-05-15T22:26:10+08:00","permalink":"https://arlettebrook.github.io/p/go-ini-introduction/","title":"Go-ini Introduction"},{"content":" # 简介 一线开发人员每天都要使用日期和时间相关的功能，各种定时器，活动时间处理等。标准库time使用起来不太灵活，特别是日期时间的创建和运算。carbon库是一个时间扩展库，基于 PHP 的carbon库编写。提供易于使用的接口。Go社区还有另外一个同名库carbon，我称之为增强版，本文就来介绍一下这两个库，主要介绍低配版，二者差不多，会了低配版，增强版也就会了。增强版用的人更多，推荐使用增强版。\n# 快速使用 第三方库需要先安装：\n1 $ go get -u github.com/uniplaces/carbon 后使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/uniplaces/carbon\u0026#34; ) func main() { fmt.Printf(\u0026#34;Right now is %s\\n\u0026#34;, carbon.Now().DateTimeString()) today, _ := carbon.NowInLocation(\u0026#34;Japan\u0026#34;) fmt.Printf(\u0026#34;Right now in Japan is %s\\n\u0026#34;, today) fmt.Printf(\u0026#34;Tomorrow is %s\\n\u0026#34;, carbon.Now().AddDay()) fmt.Printf(\u0026#34;Last week is %s\\n\u0026#34;, carbon.Now().SubWeek()) nextOlympics, _ := carbon.CreateFromDate(2016, time.August, 5, \u0026#34;Europe/London\u0026#34;) nextOlympics = nextOlympics.AddYears(4) fmt.Printf(\u0026#34;Next olympics are in %d\\n\u0026#34;, nextOlympics.Year()) if carbon.Now().IsWeekend() { fmt.Printf(\u0026#34;Happy time!\u0026#34;) } } carbon库的使用很便捷，首先它完全兼容标准库的time.Time类型，实际上该库的日期时间类型Carbon直接将time.Time内嵌到结构中（继承了time.Time结构体），所以time.Time的方法可直接调用：\n1 2 3 4 5 6 7 8 9 // github.com/uniplaces/carbon/carbon.go type Carbon struct { time.Time weekStartsAt time.Weekday weekEndsAt time.Weekday weekendDays []time.Weekday stringFormat string Translator *Translator } 其次，简化了创建操作。标准库time创建一个Time对象，如果不是本地或 UTC 时区，需要自己先调用LoadLocation加载对应时区。然后将该时区对象传给time.Time.In或者time.Date方法创建。carbon可以直接传时区名字。底层其实也是用原始方法创建的，carbon帮我们封装到了NowInLocation方法中。只需要传入时区，就能获取指定时区当前时间。\ncarbon还提供了很多方法做日期运算，如例子中的AddDay，SubWeek，Addyears等。没有s默认+1，有s指定加多少，注意单位，都是见名知义的。\n（上面的源码很简单，看不懂的话，建议去看一下源码）\nCreateFromDate方法，用于指定日期、时区创建Carbon对象。时间部分默认是当前时间。如果没有指定时区(为空字符串），默认为UTC时区。字符串为Local,为本地时区。\n一点点源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 // github.com\\uniplaces\\carbon\\carbon.go func CreateFromDate(y int, mon time.Month, d int, location string) (*Carbon, error) { h, m, s := Now().Clock() ns := Now().Nanosecond() return Create(y, mon, d, h, m, s, ns, location) func Create(y int, mon time.Month, d, h, m, s, ns int, location string) (*Carbon, error) { l, err := time.LoadLocation(location) if err != nil { return nil, err } return create(y, mon, d, h, m, s, ns, l), nil } // time\\zoneinfo.go func LoadLocation(name string) (*Location, error) { if name == \u0026#34;\u0026#34; || name == \u0026#34;UTC\u0026#34; { return UTC, nil } if name == \u0026#34;Local\u0026#34; { return Local, nil } ... // time\\time.go func Now() Time { sec, nsec, mono := now() mono -= startNano sec += unixToInternal - minWall if uint64(sec)\u0026gt;\u0026gt;33 != 0 { // Seconds field overflowed the 33 bits available when // storing a monotonic time. This will be true after // March 16, 2157. return Time{uint64(nsec), sec + minWall, Local} } return Time{hasMonotonic | uint64(sec)\u0026lt;\u0026lt;nsecShift | uint64(nsec), mono, Local} // 这里用本地时区。 } 总结：没有指定时区时，默认本地区时区，当要指定时区时，默认UTC时区。（底层源码目前看不懂😁😁😁）\n# 时区 在介绍其它内容之前，我们先说一说这个时区的问题。以下引用维基百科的描述：\n时区是地球上的区域使用同一个时间定义。以前，人们通过观察太阳的位置（时角）决定时间，这就使得不同经度的地方的时间有所不同（地方时）。1863年，首次使用时区的概念。时区通过设立一个区域的标准时间部分地解决了这个问题。 世界各国位于地球不同位置上，因此不同国家，特别是东西跨度大的国家日出、日落时间必定有所偏差。这些偏差就是所谓的时差。\n例如，日本东京位于东九区，北京位于东八区，所以日本比中国快一个小时，日本14:00的时候中国13:00。\n在 Linux 中，时区一般存放在类似/usr/share/zoneinfo这样的目录。这个目录中有很多文件，每个时区一个文件。时区文件是二进制文件，可以执行info tzfile查看具体格式。\n时区名称的一般格式为city，或country/city，或continent/city。即要么就是一个城市名，要么是国家名+/+城市名，要么是洲名+/+城市名。\n例如上海时区为Asia/Shanghai(在时区文件中表示东八区的时区，即北京时间），香港时区为Asia/Hong_Kong或者Hongkong（常识：中国标准时间（CST)为东八区时间,范围中国全境（大陆、港澳、台湾））意味着香港时间与北京时间一样，注意北京时间并不是北京的地方时，东八区在东经120°的地方，北京在东经116.4°。故东经120度地方时比北京的地方时早约14分半钟(了解）。还有CST,可能为其他地区的标准时间，如美国中部标准时间（Central Standard Time），使用的时候要注意上下文。\n也有一些特殊的，如 UTC，Local等。\nGo 语言为了可移植性，在安装包中提供了时区文件，在Go安装目录下的lib/time/zoneinfo.zip文件，大家可以执行解压看看😀。\n使用 Go 标准库time创建某个时区的时间，需要先加载时区：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;time\u0026#34; ) func main() { loc, err := time.LoadLocation(\u0026#34;Japan\u0026#34;) if err != nil { log.Fatal(\u0026#34;failed to load location: \u0026#34;, err) } //t := time.Now().In(loc) // 这里演示指定日期时间创建Time对象 d := time.Date(2020, time.July, 24, 20, 0, 0, 0, loc) fmt.Printf(\u0026#34;The opening ceremony of next olympics will start at %s in Japan\\n\u0026#34;, d) } 使用carbon就不用这么麻烦：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/uniplaces/carbon\u0026#34; ) func main() { c, err := carbon.Create(2020, time.July, 24, 20, 0, 0, 0, \u0026#34;Japan\u0026#34;) if err != nil { log.Fatal(err) } fmt.Printf(\u0026#34;The opening ceremony of next olympics will start at %s in Japan\\n\u0026#34;, c) } # 创建对象 创建Carbon对象，可以通过：\nNow方法，返回本地时区的当前时间对象。\nNewCarbon方法，返回指定时间的本地时区时间对象。Now方法是基于它创建的。\nCreateFromDate方法，用于指定日期、时区创建Carbon对象。时间部分默认是当前时间。如果没有指定时区(为空字符串），默认为UTC时区。字符串为Local,为本地时区。\nCrreateFromTime方法一样，只不过是指定时间。 注意，创建的日期，默认为当前日期。虽然没有指定，但不会没有。 Create方法，返回根据日期、时间、时区创建的时间对象\nParse方法，返回根据日期时间格式、指定的时间、时区解析的时间对象。\n示例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/uniplaces/carbon\u0026#34; ) func main() { now := carbon.NewCarbon(time.Now()) fmt.Printf(\u0026#34;New carbon from time instance: %s\\n\u0026#34;, now) now = carbon.Now() fmt.Printf(\u0026#34;New carbon from Now function: %s\\n\u0026#34;, now) fromDate, _ := carbon.CreateFromDate(2000, 1, 1, \u0026#34;Europe/London\u0026#34;) fmt.Printf(\u0026#34;Created from date: %s\\n\u0026#34;, fromDate) fromTime, _ := carbon.CreateFromTime(9, 16, 11, 0, \u0026#34;Europe/Madrid\u0026#34;) fmt.Printf(\u0026#34;Created from time: %s\\n\u0026#34;, fromTime) create, _ := carbon.Create(2024, 5, 14, 15, 3, 3, 3, \u0026#34;Local\u0026#34;) fmt.Println(create) parsed, _ := carbon.Parse(carbon.DateFormat, \u0026#34;2000-08-20\u0026#34;, \u0026#34;Europe/Berlin\u0026#34;) fmt.Printf(\u0026#34;Parsed time: %s\\n\u0026#34;, parsed) parse, _ := carbon.Parse(time.DateTime, \u0026#34;2024-05-14 22:10:22\u0026#34;, \u0026#34;Local\u0026#34;) fmt.Println(parse) timestamp, _ := carbon.CreateFromTimestamp(-1, \u0026#34;Local\u0026#34;) fmt.Println(timestamp) // 1970-01-01 07:59:59 } 后面会介绍时间格式化。\n# 时间运算 使用标准库time的时间运算需要先定义一个time.Duration对象，time库预定义的只有纳秒到小时的精度：\n1 2 3 4 5 6 7 8 const ( Nanosecond Duration = 1 Microsecond = 1000 * Nanosecond Millisecond = 1000 * Microsecond Second = 1000 * Millisecond Minute = 60 * Second Hour = 60 * Minute ) 其它的时长就需要自己使用time.ParseDuration构造了，而且time.ParseDuration不能构造其它精度的时间。 如果想要增加/减少年月日，就需要使用time.Time的AddDate方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;time\u0026#34; ) func main() { now := time.Now() fmt.Println(\u0026#34;now is:\u0026#34;, now) fmt.Println(\u0026#34;one second later is:\u0026#34;, now.Add(time.Second)) fmt.Println(\u0026#34;one minute later is:\u0026#34;, now.Add(time.Minute)) fmt.Println(\u0026#34;one hour later is:\u0026#34;, now.Add(time.Hour)) d, err := time.ParseDuration(\u0026#34;3m20s\u0026#34;) if err != nil { log.Fatal(err) } fmt.Println(\u0026#34;3 minutes and 20 seconds later is:\u0026#34;, now.Add(d)) d, err = time.ParseDuration(\u0026#34;2h30m\u0026#34;) if err != nil { log.Fatal(err) } fmt.Println(\u0026#34;2 hours and 30 minutes later is:\u0026#34;, now.Add(d)) fmt.Println(\u0026#34;3 days and 2 hours later is:\u0026#34;, now.AddDate(0, 0, 3).Add(time.Hour*2)) } 需要注意的是，时间操作都是返回一个新的对象，原对象不会修改。carbon库也是如此。Go 的标准库也建议我们不要使用time.Time的指针。 当然carbon库也能使用上面的方法，它还提供了多种粒度的方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/uniplaces/carbon\u0026#34; ) func main() { now := carbon.Now() fmt.Println(\u0026#34;now is:\u0026#34;, now) fmt.Println(\u0026#34;one second later is:\u0026#34;, now.AddSecond()) fmt.Println(\u0026#34;one minute later is:\u0026#34;, now.AddMinute()) fmt.Println(\u0026#34;one hour later is:\u0026#34;, now.AddHour()) fmt.Println(\u0026#34;3 minutes and 20 seconds later is:\u0026#34;, now.AddMinutes(3).AddSeconds(20)) fmt.Println(\u0026#34;2 hours and 30 minutes later is:\u0026#34;, now.AddHours(2).AddMinutes(30)) fmt.Println(\u0026#34;3 days and 2 hours later is:\u0026#34;, now.AddDays(3).AddHours(2)) } carbon还提供了：\n增加季度的方法：AddQuarters/AddQuarter，复数形式介绍一个表示倍数的参数，单数形式倍数为1； 增加世纪的方法：AddCenturies/AddCentury； 增加工作日的方法：AddWeekdays/AddWeekday，这个方法会跳过非工作日； 增加周的方法：AddWeeks/AddWeek。 其实给上面方法传入负数就表示减少，另外carbon也提供了对应的Sub*方法。\n# 时间比较 注意：时间比较的是快慢。\n标准库time可以使用time.Time对象的Before/After/Equal判断是否在另一个时间对象前，后，或相等。carbon库也可以使用上面的方法比较时间。除此之外，它还提供了多组方法，每个方法提供一个简短名，一个详细名：\nEq/EqualTo：是否相等；不同时区的日期时间不同，但时间可能会相等。如 6:00 +0200 and 4:00 UTC are Equal. Ne/NotEqualTo：是否不等； Gt/GreaterThan：是否在之后； Gte/GreaterThanOrEqualTo:快或者相等。 Lt/LessThan：是否在之前； Lte/LessThanOrEqualTo：是否相同或在之前； Between：是否在两个时间之间。 另外carbon提供了：\n判断当前时间是周几的方法：IsMonday/IsTuesday/.../IsSunday； 是否是工作日，周末，闰年，过去时间还是未来时间：IsWeekday/IsWeekend/IsLeapYear/IsPast/IsFuture。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/uniplaces/carbon\u0026#34; ) func main() { t1, _ := carbon.CreateFromDate(2010, 10, 1, \u0026#34;Asia/Shanghai\u0026#34;) t2, _ := carbon.CreateFromDate(2011, 10, 20, \u0026#34;Asia/Shanghai\u0026#34;) fmt.Printf(\u0026#34;t1 equal to t2: %t\\n\u0026#34;, t1.Eq(t2)) fmt.Printf(\u0026#34;t1 not equal to t2: %t\\n\u0026#34;, t1.Ne(t2)) fmt.Printf(\u0026#34;t1 greater than t2: %t\\n\u0026#34;, t1.Gt(t2)) fmt.Printf(\u0026#34;t1 less than t2: %t\\n\u0026#34;, t1.Lt(t2)) fmt.Printf(\u0026#34;t1 greater than or equal: %t\u0026#34;, t1.Gte(t2)) t3, _ := carbon.CreateFromDate(2011, 1, 20, \u0026#34;Asia/Shanghai\u0026#34;) fmt.Printf(\u0026#34;t3 between t1 and t2: %t\\n\u0026#34;, t3.Between(t1, t2, true)) now := carbon.Now() fmt.Printf(\u0026#34;Weekday? %t\\n\u0026#34;, now.IsWeekday()) fmt.Printf(\u0026#34;Weekend? %t\\n\u0026#34;, now.IsWeekend()) fmt.Printf(\u0026#34;LeapYear? %t\\n\u0026#34;, now.IsLeapYear()) fmt.Printf(\u0026#34;Past? %t\\n\u0026#34;, now.IsPast()) fmt.Printf(\u0026#34;Future? %t\\n\u0026#34;, now.IsFuture()) } # 时间差 我们还可以使用carbon计算两个日期之间相差多少秒、分、小时、天。\n用到的方法是func (c *Carbon) DiffInXXX(carb *Carbon, abs bool),表示的是相对于对象c快了还慢了多少XXX。正数表示c慢了，负数表示c快了。原理：\n1 diff := carb.Timestamp() - c.Timestamp() abs表示是否启用绝对值。\n示例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/uniplaces/carbon\u0026#34; ) func main() { cst, _ := carbon.Today(\u0026#34;Asia/Shanghai\u0026#34;) hongKong, _ := carbon.Today(\u0026#34;Hongkong\u0026#34;) Japan, _ := carbon.Today(\u0026#34;Japan\u0026#34;) fmt.Println(cst.DiffInSeconds(hongKong, true)) // 0 fmt.Println(cst.DiffInHours(Japan, false)) // 0 Beijing, _ := carbon.CreateFromDate(2000, 1, 1, \u0026#34;Asia/Shanghai\u0026#34;) Tokyo, _ := carbon.CreateFromDate(2000, 1, 1, \u0026#34;Japan\u0026#34;) fmt.Println(Beijing.DiffInHours(Tokyo, true)) // 1 fmt.Println(Beijing.DiffInHours(Tokyo, false)) // -1 fmt.Println(Tokyo.DiffInHours(Beijing, false)) // 1 t, _ := carbon.CreateFromDate(2012, 1, 1, \u0026#34;UTC\u0026#34;) fmt.Println(t.DiffInDays(t.Copy().AddMonth(), false)) // 31 fmt.Println(t.DiffInDays(t.Copy().SubMonth(), false)) // -31 t, _ = carbon.CreateFromDate(2012, 4, 30, \u0026#34;UTC\u0026#34;) fmt.Println(t.DiffInDays(t.Copy().AddMonth(), false)) // 30 fmt.Println(t.DiffInDays(t.Copy().AddWeek(), false)) // 7 t, _ = carbon.CreateFromTime(10, 1, 1, 0, \u0026#34;UTC\u0026#34;) fmt.Println(t.DiffInMinutes(t.Copy().AddSeconds(59), true)) // 0 fmt.Println(t.DiffInMinutes(t.Copy().AddSeconds(60), true)) // 1 fmt.Println(t.DiffInMinutes(t.Copy().AddSeconds(119), true)) // 1 fmt.Println(t.DiffInMinutes(t.Copy().AddSeconds(120), true)) // 2 fmt.Println(t.DiffInHours(t.Copy().AddMinutes(59), false)) // 0 fmt.Println(t.DiffInHours(t.Copy().AddMinutes(60), false)) // 1 fmt.Println(t.DiffInHours(t.Copy().AddHours(2).AddMinutes(60), false)) // 3 } 注意：\n上面输出完全正确。 不理解是因为： 正数表示c慢了，负数表示c快了。 当北京时间和东京时间数字相同时，其实北京时间要快一个小时。即相同数字的北京时间和东京时间，北京时间的时间戳要大一点。因为实际北京时间比东京时间慢一个小时。 # 格式化 我们知道time.Time提供了一个Format方法，相比于其他编程语言使用格式化符来描述格式（需要记忆%d/%m/%h等的含义），Go 提供了一个一种更简单、直观的方式——使用 layout。即我们传入一个日期字符串，表示我们想要格式化成什么样子。Go 会用当前的时间替换字符串中的对应部分：\n1 2 3 4 5 6 7 8 9 10 11 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { t := time.Now() fmt.Println(t.Format(\u0026#34;2006-01-02 15:04:05\u0026#34;)) } 上面我们只需要传入一个2006-01-02 15:04:05表示我们想要的格式为yyyy-mm-dd hh:mm:ss，省去了我们需要记忆的麻烦。\n为了使用方便，Go 内置了一些标准的时间格式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // time/format.go const ( Layout = \u0026#34;01/02 03:04:05PM \u0026#39;06 -0700\u0026#34; // The reference time, in numerical order. ANSIC = \u0026#34;Mon Jan _2 15:04:05 2006\u0026#34; UnixDate = \u0026#34;Mon Jan _2 15:04:05 MST 2006\u0026#34; RubyDate = \u0026#34;Mon Jan 02 15:04:05 -0700 2006\u0026#34; RFC822 = \u0026#34;02 Jan 06 15:04 MST\u0026#34; RFC822Z = \u0026#34;02 Jan 06 15:04 -0700\u0026#34; // RFC822 with numeric zone RFC850 = \u0026#34;Monday, 02-Jan-06 15:04:05 MST\u0026#34; RFC1123 = \u0026#34;Mon, 02 Jan 2006 15:04:05 MST\u0026#34; RFC1123Z = \u0026#34;Mon, 02 Jan 2006 15:04:05 -0700\u0026#34; // RFC1123 with numeric zone RFC3339 = \u0026#34;2006-01-02T15:04:05Z07:00\u0026#34; RFC3339Nano = \u0026#34;2006-01-02T15:04:05.999999999Z07:00\u0026#34; Kitchen = \u0026#34;3:04PM\u0026#34; // Handy time stamps. Stamp = \u0026#34;Jan _2 15:04:05\u0026#34; StampMilli = \u0026#34;Jan _2 15:04:05.000\u0026#34; StampMicro = \u0026#34;Jan _2 15:04:05.000000\u0026#34; StampNano = \u0026#34;Jan _2 15:04:05.000000000\u0026#34; DateTime = \u0026#34;2006-01-02 15:04:05\u0026#34; DateOnly = \u0026#34;2006-01-02\u0026#34; TimeOnly = \u0026#34;15:04:05\u0026#34; ) 后面三个是在后面版本加上进的。\n除了上面这些格式，carbon还提供了其他一些格式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // github.com/uniplaces/carbon const ( DefaultFormat = \u0026#34;2006-01-02 15:04:05\u0026#34; DateFormat = \u0026#34;2006-01-02\u0026#34; FormattedDateFormat = \u0026#34;Jan 2, 2006\u0026#34; TimeFormat = \u0026#34;15:04:05\u0026#34; HourMinuteFormat = \u0026#34;15:04\u0026#34; HourFormat = \u0026#34;15\u0026#34; DayDateTimeFormat = \u0026#34;Mon, Jan 2, 2006 3:04 PM\u0026#34; CookieFormat = \u0026#34;Monday, 02-Jan-2006 15:04:05 MST\u0026#34; RFC822Format = \u0026#34;Mon, 02 Jan 06 15:04:05 -0700\u0026#34; RFC1036Format = \u0026#34;Mon, 02 Jan 06 15:04:05 -0700\u0026#34; RFC2822Format = \u0026#34;Mon, 02 Jan 2006 15:04:05 -0700\u0026#34; RFC3339Format = \u0026#34;2006-01-02T15:04:05-07:00\u0026#34; RSSFormat = \u0026#34;Mon, 02 Jan 2006 15:04:05 -0700\u0026#34; ) 注意一点，time库默认使用2006-01-02 15:04:05.999999999 -0700 MST格式，有点复杂了，carbon库默认使用更简洁的2006-01-02 15:04:05。\n使用只需要调func (t Time) Format(layout string)方法，layout为上面提供的格式化字符串。\ncarbon为了进一步方便使用，都将Fomat方法封装到了指定XxxString方法中.\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/uniplaces/carbon\u0026#34; ) func main() { now := carbon.Now() fmt.Println(now.Format(time.DateTime)) fmt.Println(now.Format(carbon.DefaultFormat), \u0026#34;=\u0026#34;, now.DateTimeString()) fmt.Println(now.Format(time.RFC3339)) fmt.Println(now.Format(carbon.RFC3339Format), \u0026#34;=\u0026#34;, now.RFC3339String()) fmt.Println(now.Format(carbon.DateFormat), \u0026#34;=\u0026#34;, now.DateString()) } 运行输出：\n1 2 3 4 5 6 $ go run main.go 2024-05-14 11:23:01 2024-05-14 11:23:01 = 2024-05-14 11:23:01 2024-05-14T11:23:01+08:00 2024-05-14T11:23:01+08:00 = 2024-05-14T11:23:01+08:00 2024-05-14 = 2024-05-14 # 高级特性 # 修饰器 # Boundary：边界 所谓修饰器（modifier）就是对一些特定的时间操作，获取开始和结束时间。如当天、月、季度、年、十年、世纪、周的开始和结束时间，还能获得上一个周二、下一个周一、下一个工作日的时间等等：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/uniplaces/carbon\u0026#34; ) func main() { t := carbon.Now() fmt.Printf(\u0026#34;Start of day:%s\\n\u0026#34;, t.StartOfDay()) fmt.Printf(\u0026#34;End of day:%s\\n\u0026#34;, t.EndOfDay()) fmt.Printf(\u0026#34;Start of month:%s\\n\u0026#34;, t.StartOfMonth()) fmt.Printf(\u0026#34;End of month:%s\\n\u0026#34;, t.EndOfMonth()) fmt.Printf(\u0026#34;Start of year:%s\\n\u0026#34;, t.StartOfYear()) fmt.Printf(\u0026#34;End of year:%s\\n\u0026#34;, t.EndOfYear()) fmt.Printf(\u0026#34;Start of decade:%s\\n\u0026#34;, t.StartOfDecade()) fmt.Printf(\u0026#34;End of decade:%s\\n\u0026#34;, t.EndOfDecade()) fmt.Printf(\u0026#34;Start of century:%s\\n\u0026#34;, t.StartOfCentury()) fmt.Printf(\u0026#34;End of century:%s\\n\u0026#34;, t.EndOfCentury()) fmt.Printf(\u0026#34;Start of week:%s\\n\u0026#34;, t.StartOfWeek()) fmt.Printf(\u0026#34;End of week:%s\\n\u0026#34;, t.EndOfWeek()) fmt.Printf(\u0026#34;Next:%s\\n\u0026#34;, t.Next(time.Wednesday)) fmt.Printf(\u0026#34;Previous:%s\\n\u0026#34;, t.Previous(time.Wednesday)) } # 自定义工作日和周末 有些地区每周的开始、周末和我们的不一样。Carbon默认是\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 func NewCarbon(t time.Time) *Carbon { wds := []time.Weekday{ time.Saturday, time.Sunday, } return \u0026amp;Carbon{ Time: t, weekStartsAt: time.Monday, weekEndsAt: time.Sunday, weekendDays: wds, stringFormat: DefaultFormat, Translator: translator(), } } 例如，在美国周日是新的一周开始。没关系，carbon可以自定义每周的开始和周末：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/uniplaces/carbon\u0026#34; ) func main() { t, err := carbon.Create(2020, 02, 11, 0, 0, 0, 0, \u0026#34;Asia/Shanghai\u0026#34;) if err != nil { log.Fatal(err) } t.SetWeekStartsAt(time.Sunday) t.SetWeekEndsAt(time.Saturday) t.SetWeekendDays([]time.Weekday{time.Monday, time.Tuesday, time.Wednesday}) fmt.Printf(\u0026#34;Today is %s, weekend? %t\\n\u0026#34;, t.Weekday(), t.IsWeekend()) } 这个库一般默认就行。\n# 批量生成日期 利用Period方法，可以批量生成日期，接收三个参数。\n第一个：开始的时间。 第二个：日期间隔。 第三个：结束的时间。 返回值是一个时间对象切片。 效果为：从开始时间每隔多少天创建一个时间对象，直到结束日期。\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/uniplaces/carbon\u0026#34; ) func main() { t1, _ := carbon.Create(2012, 1, 1, 12, 0, 0, 0, \u0026#34;UTC\u0026#34;) t2, _ := carbon.Create(2012, 1, 31, 12, 0, 0, 0, \u0026#34;UTC\u0026#34;) days := 7 periods, err := carbon.Period(t1, days, t2) if err != nil { return } for _, val := range periods { fmt.Println(val) } } 运行输出：\n1 2 3 4 5 6 $ go run main.go 2012-01-01 12:00:00 2012-01-08 12:00:00 2012-01-15 12:00:00 2012-01-22 12:00:00 2012-01-29 12:00:00 （不常用）\n# 增强版介绍 下载：\n1 2 # 增强版 $ go get -u github.com/golang-module/carbon/v2 # 增强版创建对象 创建时间对象与低配版不一样。\n增强版的Now函数，参数是时区，为可选参数，默认为本地时区。增强版的时区，没有指定，一律为本地时区。\n低配版直接通过NewCarbon指定时间创建时间对象，而高配版还需要调CreateXxx方法指定时间才能完成创建。\n并且低配版如果只创建日期，那么时间为当前时间。而高配版只创建日期，时间为0:0:0.\n当只创建时间时，二者的日期都是为当前日期。 高配版移除了Create方法，创建了更多CreateXxx方法。用于指定时间或日期创建对象。\n对Parse方法进行了增强，并且还提供了另外两个方法，进行创建对象。这几个方法的时区都可选的，默认为本地时区。\n增强版Parse方法只能指定要解析的字符串和时区（可选）创建对象。如果没有指定时区，默认本地时区。时间布局任意。底层会遍历所有支持的布局模板（增强版叫Layout）。\nParseByLayout方法在Parse方法的基础上增加了一个布局模板参数。\nParseByFormat方法在Parse方法的基础上增加了一个格式模版参数。\n布局模板以Layout结尾，就是原来的Format方法的参数。\n1 DateLayout = \u0026#34;2006-01-02\u0026#34; 格式模版以format结尾，增强版新加的，由日期时间的格式化字符组成的字符串\n1 DateTimeFormat = \u0026#34;Y-m-d H:i:s\u0026#34; 注意carbon包的内部错误，都封装到了时间对象的Error属性下。\n如果有多个错误发生，只返回第一个错误，前一个错误排除后才返回下一个错误\n1 2 3 4 5 6 7 c := carbon.SetTimezone(\u0026#34;xxx\u0026#34;).Parse(\u0026#34;2020-08-05\u0026#34;) if c.Error != nil { // 错误处理 log.Fatal(c.Error) } // 输出 invalid timezone \u0026#34;xxx\u0026#34;, please see the file \u0026#34;$GOROOT/lib/time/zoneinfo.zip\u0026#34; for all valid timezones 实例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;github.com/golang-module/carbon/v2\u0026#34; ) func main() { now := carbon.Now() now = carbon.NewCarbon().Now() fmt.Println(now) // stdTime := carbon.CreateFromStdTime(time.Now()) fmt.Println(stdTime) // fromDate := carbon.CreateFromDate(2024, 5, 14) fromDate = carbon.NewCarbon().CreateFromDate(2024, 5, 14) fmt.Println(fromDate) // 2024-05-14 00:00:00 dateTime := carbon.CreateFromDateTime(2024, 5, 14, 10, 22, 33) dateTime = carbon.NewCarbon().CreateFromDateTime(2024, 5, 14, 10, 22, 33) fmt.Println(dateTime) // 2024-05-14 10:22:33 assertErr := func(carbon carbon.Carbon) { if carbon.Error != nil { log.Fatal(carbon.Error) } } parse := carbon.Parse(\u0026#34;2024-05-20 10:22:33\u0026#34;) assertErr(parse) fmt.Println(parse) // 2024-05-20 10:22:33 parse = carbon.ParseByLayout(\u0026#34;2024-05-20\u0026#34;, carbon.DateLayout) assertErr(parse) fmt.Println(parse) // 2024-05-20 00:00:00 parse = carbon.ParseByFormat(\u0026#34;2024-05-20 10:22:33\u0026#34;, carbon.DateTimeFormat) assertErr(parse) fmt.Println(parse) // 2024-05-20 10:22:33 toString := carbon.CreateFromTimestamp(-1) fmt.Println(toString) // 1970-01-01 07:59:59 } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // Create a Carbon instance from a given hour, minute and second carbon.CreateFromTime(13, 14, 15).ToString() // 2020-08-05 13:14:15 +0800 CST // Create a Carbon instance from a given hour, minute and second with millisecond carbon.CreateFromTimeMilli(13, 14, 15, 999).ToString() // 2020-08-05 13:14:15.999 +0800 CST // Create a Carbon instance from a given hour, minute and second with microsecond carbon.CreateFromTimeMicro(13, 14, 15, 999999).ToString() // 2020-08-05 13:14:15.999999 +0800 CST // Create a Carbon instance from a given hour, minute and second with nanosecond carbon.CreateFromTimeNano(13, 14, 15, 999999999).ToString() // 2020-08-05 13:14:15.999999999 +0800 CST carbon.Parse(\u0026#34;now\u0026#34;).ToString() // 2020-08-05 13:14:15 +0800 CST carbon.Parse(\u0026#34;yesterday\u0026#34;).ToString() // 2020-08-04 13:14:15 +0800 CST carbon.Parse(\u0026#34;tomorrow\u0026#34;).ToString() // 2020-08-06 13:14:15 +0800 CST carbon.Parse(\u0026#34;2020\u0026#34;).ToString() // 2020-01-01 00:00:00 +0800 CST carbon.Parse(\u0026#34;2020-8\u0026#34;).ToString() // 2020-08-01 00:00:00 +0800 CST carbon.ParseByFormat(\u0026#34;2020|08|05 13|14|15\u0026#34;, \u0026#34;Y|m|d H|i|s\u0026#34;).ToDateTimeString() // 2020-08-05 13:14:15 carbon.ParseByFormat(\u0026#34;It is 2020-08-05 13:14:15\u0026#34;, \u0026#34;\\\\I\\\\t \\\\i\\\\s Y-m-d H:i:s\u0026#34;).ToDateTimeString() // 2020-08-05 13:14:15 carbon.ParseByFormat(\u0026#34;今天是 2020年08月05日13时14分15秒\u0026#34;, \u0026#34;今天是 Y年m月d日H时i分s秒\u0026#34;).ToDateTimeString() // 2020-08-05 13:14:15 carbon.ParseByLayout(\u0026#34;2020|08|05 13|14|15\u0026#34;, \u0026#34;2006|01|02 15|04|05\u0026#34;).ToDateTimeString() // 2020-08-05 13:14:15 carbon.ParseByLayout(\u0026#34;It is 2020-08-05 13:14:15\u0026#34;, \u0026#34;It is 2006-01-02 15:04:05\u0026#34;).ToDateTimeString() // 2020-08-05 13:14:15 carbon.ParseByLayout(\u0026#34;今天是 2020年08月05日13时14分15秒\u0026#34;, \u0026#34;今天是 2006年01月02日15时04分05秒\u0026#34;).ToDateTimeString() // 2020-08-05 13:14:15 # 一些默认值 增强版创建的时间对象的默认值：\n时间格式与低配版一直，名字改成carbon.DateTimeLayout。 时区默认都为本地时区。 工作日开始是在Sunday，低配版是在星期一。 默认的语言区域是en。支持的语言在github.com\\golang-module\\carbon\\lang目录下。 这些属性可以通过func SetDefault(d Default)方法修改。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/golang-module/carbon/v2\u0026#34; ) func main() { now := carbon.Now() fmt.Println(now) carbon.SetDefault(carbon.Default{Layout: carbon.RFC3339Layout, Timezone: carbon.Local, WeekStartsAt: carbon.Monday, Locale: \u0026#34;zh-CN\u0026#34;}) fmt.Println(now) } 官方建议在main.go等入口文件中修改默认值。\n# 对象互转 增强版可以实现time.Time对象与Carbon对象相互转换。\n示例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/golang-module/carbon/v2\u0026#34; ) func main() { carbonTime := carbon.CreateFromTime(22, 22, 22) stdTime := carbonTime.StdTime() fmt.Println(stdTime) // 2024-05-14 22:22:22 +0800 CST stdTime = time.Date(2024, 5, 14, 22, 22, 22, 0, time.Local) carbonTime = carbon.CreateFromStdTime(stdTime) fmt.Println(carbonTime) // 2024-05-14 22:22:22 } # 更多细节的增强 # 对象转字符串 增强版提供了更多时间对象转字符串的方法。除了String方法外，添加了ToXxxString方法：\n1 2 3 4 5 6 7 8 9 carbon.Now().String() // 2020-08-05 13:14:15 carbon.Now().ToString() // 2020-08-05 13:14:15 +0800 CST carbon.Now().ToDateTimeString() // 2020-08-05 13:14:15 // Return date of today carbon.Now().ToDateString() // 2020-08-05 // Return time of today carbon.Now().ToTimeString() // 13:14:15 // Return datetime of today in a given timezone carbon.Now(Carbon.NewYork).ToDateTimeString() // 2020-08-05 14:14:15 注意：增强版有一个坑：当我们直接输出Carbon对象时，会自动调用String方法，这个String方法会将时区改成本地。若不希望修改时区，请不要调用String方法，用别的转字符串的方法，如ToDateTimeString。\n更多内容参考时间输出\n# 对象转时间戳 通过增强版，我们可以方便的将Carbon对象转换成指定单位的时间戳：\n1 2 3 4 5 6 7 8 9 carbon.Now(Carbon.NewYork).ToDateTimeString() // 2020-08-05 14:14:15 // Return timestamp with second of today carbon.Now().Timestamp() // 1596604455 // Return timestamp with millisecond of today carbon.Now().TimestampMilli() // 1596604455999 // Return timestamp with microsecond of today carbon.Now().TimestampMicro() // 1596604455999999 // Return timestamp with nanosecond of today carbon.Now().TimestampNano() // 1596604455999999999 # 获取昨天、明天的对象 增强版，不仅能够获取当前的时间对象，还能获取昨天或者明天的时间：\n1 2 3 4 5 6 7 8 fmt.Printf(\u0026#34;%s\u0026#34;, carbon.Yesterday()) // 2020-08-04 13:14:15 carbon.Yesterday().String() // 2020-08-04 13:14:15 carbon.Yesterday().ToString() // 2020-08-04 13:14:15 +0800 CST carbon.Yesterday(Carbon.NewYork).ToDateTimeString() // 2020-08-04 13:14:15 carbon.Tomorrow().String() // 2020-08-06 13:14:15 carbon.Tomorrow().ToString() // 2020-08-06 13:14:15 +0800 CST carbon.Tomorrow().ToDateTimeString() // 2020-08-06 13:14:15 # 增强时间戳创建对象 低配版只能通过CreateFromTimestamp和CreateFromTimestampUTC函数创建对象，增强版提供了毫秒、微秒、纳秒时间戳创建对象。时区默认本地时区。\n1 2 3 4 5 6 7 8 carbon.CreateFromTimestamp(1649735755).ToString() // 2022-04-12 11:55:55 +0800 CST // Create a Carbon instance from a given timestamp with millisecond carbon.CreateFromTimestampMilli(1649735755981).ToString() // 2022-04-12 11:55:55.981 +0800 CST // Create a Carbon instance from a given timestamp with microsecond carbon.CreateFromTimestampMicro(1649735755981566).ToString() // 2022-04-12 11:55:55.981566 +0800 CST // Create a Carbon instance from a given timestamp with nanosecond carbon.CreateFromTimestampNano(1649735755981566000).ToString() // 2022-04-12 11:55:55.981566 +0800 CST carbon.CreateFromTimestampNano(1649735755981566000, \u0026#34;Japan\u0026#34;).ToString() // 2022-04-12 12:55:55.981566 +0900 JST 快一个小时。 其他创建对象增强\n# 时间的边界 与低配版一模一样。详情请看修饰器。\n# 增强时间运算 支持链式调用，对应时间的运算，增加了不会溢出的方法。\n默认低配版和高配版进行时间运算时，当为2月29的时候，即闰年的时候，计算到不是闰年，都没有29号，那么时间默认会溢出，变成3月1号。增强版提供了AddXxxNoOverflow、SubXxxNoOverflow方法（低配版部分有，高配版基本都有），让时间不会溢出，为2月28。（闰年比公历年多1天。）\n增强版还增强了别的单位进行运算,如XxxDecades十年、XxxDuration根据片段进行运算。还更小单位的运算，如SubMillisecond、SubNanossecond\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 三个年代后 carbon.Parse(\u0026#34;2020-02-29 13:14:15\u0026#34;).AddDecades(3).ToDateTimeString() // 2050-03-01 13:14:15 // 三个年代后(月份不溢出) carbon.Parse(\u0026#34;2020-02-29 13:14:15\u0026#34;).AddDecadesNoOverflow(3).ToDateTimeString() // 2050-02-28 13:14:15 // 一个年代后 carbon.Parse(\u0026#34;2020-02-29 13:14:15\u0026#34;).AddDecade().ToDateTimeString() // 2030-03-01 13:14:15 // 一个年代后(月份不溢出) carbon.Parse(\u0026#34;2020-02-29 13:14:15\u0026#34;).AddDecadeNoOverflow().ToDateTimeString() // 2030-02-28 13:14:15 // 二小时半前 carbon.Parse(\u0026#34;2020-08-05 13:14:15\u0026#34;).SubDuration(\u0026#34;2.5h\u0026#34;).ToDateTimeString() // 2020-08-05 10:44:15 carbon.Parse(\u0026#34;2020-08-05 13:14:15\u0026#34;).SubDuration(\u0026#34;2h30m\u0026#34;).ToDateTimeString() // 2020-08-05 10:44:15 // 三微秒后 carbon.Parse(\u0026#34;2020-08-05 13:14:15.222222222\u0026#34;).AddMicroseconds(3).ToString() // 2020-08-05 13:14:15.222225222 +0800 CST // 一微秒后 carbon.Parse(\u0026#34;2020-08-05 13:14:15.222222222\u0026#34;).AddMicrosecond().ToString() // 2020-08-05 13:14:15.222223222 +0800 CST 其他的与低配版一直。\n# 增强时间差 增强版移除了是否取绝对值参数，封装到了DiffAbsInXxx方法中。 原理差不多，后面-前面。快为负数，慢为正数（相对调用的时间对象）。 其他相差多少分、小时、年、与低配版时间差一直 新增时间差的字符串表示，用DiffInString方法获取，默认参数为当前时间。 同样提供了绝对值方法DiffAbsInString 需要注意的是：目前时间差的字符串表示只能表示差里面的最大时间单位。 如差2分30秒，结果为差2分钟。差3月22天，结果为差3个月 该方法支持国际化。 新增相差时长（片段）字符串表示。用DiffInDuration方法获取，默认参数为当前时间。 同样提供了绝对值方法DiffAbsInDuration 需要注意的是：这个方法会具体到相差多少时差。当最大单位为小时。 该方法同样支持国际化。 新增对人类友好的可读格式时间差。用DiffForHumans方法获取，默认参数为当前时间。 该方法人类可读，移除了绝对值方法。能够直观的看见参数时间对象是前（负数）还是后（正数）。 需要注意的是该方法，与DiffInString一样，只能表示最大的时间单位。 同样支持国际化。 示例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/golang-module/carbon/v2\u0026#34; ) func main() { carbon.SetDefault(carbon.Default{ Layout: carbon.DateTimeLayout, Timezone: carbon.Local, WeekStartsAt: carbon.Monday, Locale: \u0026#34;zh-CN\u0026#34;, }) inString := carbon.Now().DiffInString(carbon.Now().AddDays(22).AddMinutes(22)) fmt.Println(inString) // 3 周 diffInString := carbon.Now().AddHours(22).AddMinutes(22).DiffInString() fmt.Println(diffInString) // -22 小时 diffAbsInDuration := carbon.Now().AddYears(2).AddMinutes(22).AddMicroseconds(22).DiffAbsInDuration() fmt.Println(diffAbsInDuration) // 17520h22m0.000022s inString = carbon.Now().DiffForHumans(carbon.Now().AddDays(22).AddMinutes(22)) fmt.Println(inString) // 3 周前 diffInString = carbon.Now().AddHours(22).AddMinutes(22).DiffForHumans() fmt.Println(diffInString) // 22 小时后 } # 获取时间极值 低配版只提供了Closest和Farthest获取距对象最近或最远的时间对象，低配版和高配版都只能传递两个时间对象。\n高配版增强版新增两个方法Max和``Min`，获取多个时间里面的最大或最小，参数为至少一个时间对象。\n示例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 c0 := carbon.Parse(\u0026#34;2023-04-01\u0026#34;) c1 := carbon.Parse(\u0026#34;2023-03-28\u0026#34;) c2 := carbon.Parse(\u0026#34;2023-04-16\u0026#34;) // 返回最近的 Carbon 实例 c0.Closest(c1, c2) // c1 // 返回最远的 Carbon 实例 c0.Farthest(c1, c2) // c2 yesterday := carbon.Yesterday() today := carbon.Now() tomorrow := carbon.Tomorrow() // 返回最大的 Carbon 实例 carbon.Max(yesterday, today, tomorrow) // tomorrow // 返回最小的 Carbon 实例 carbon.Min(yesterday, today, tomorrow) // yesterday # 增强时间判断 增强版新增判断时间是否有效：IsValid、IsInvalid\n原理是时间戳大于0，就有效。当为0或者为空或者Error属性不为nil时，该时间无效。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 是否是有效时间 func (c Carbon) IsValid() bool { if c.Error != nil { return false } if c.time.IsZero() { return false } // 大于零值时间 if c.StdTime().Unix() \u0026gt; -62135596800 { return true } return false } 新增更多的时间判断：\n判断是否是早上、下午、当前、未来、过去、闰年、长年、几月、星期几、工作日、周末、昨天、今天、明天、同一世纪、同一年代、同一年、同一季节、同一月、同一天、同一小时、同一分钟、同一秒。方法名是IsXxx。 需要注意的是：增强版移除了自定义周末。周末默认都为星期6、星期天。只保留了设置一周开始的日期。\n新增星座判断，方法为IsXxx\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // 获取星座 carbon.Parse(\u0026#34;2020-08-05 13:14:15\u0026#34;).Constellation() // Leo // 是否是白羊座 carbon.Parse(\u0026#34;2020-08-05 13:14:15\u0026#34;).IsAries() // false // 是否是金牛座 carbon.Parse(\u0026#34;2020-08-05 13:14:15\u0026#34;).IsTaurus() // false // 是否是双子座 carbon.Parse(\u0026#34;2020-08-05 13:14:15\u0026#34;).IsGemini() // false // 是否是巨蟹座 carbon.Parse(\u0026#34;2020-08-05 13:14:15\u0026#34;).IsCancer() // false // 是否是狮子座 carbon.Parse(\u0026#34;2020-08-05 13:14:15\u0026#34;).IsLeo() // true // 是否是处女座 carbon.Parse(\u0026#34;2020-08-05 13:14:15\u0026#34;).IsVirgo() // false // 是否是天秤座 carbon.Parse(\u0026#34;2020-08-05 13:14:15\u0026#34;).IsLibra() // false // 是否是天蝎座 carbon.Parse(\u0026#34;2020-08-05 13:14:15\u0026#34;).IsScorpio() // false // 是否是射手座 carbon.Parse(\u0026#34;2020-08-05 13:14:15\u0026#34;).IsSagittarius() // false // 是否是摩羯座 carbon.Parse(\u0026#34;2020-08-05 13:14:15\u0026#34;).IsCapricorn() // false // 是否是水瓶座 carbon.Parse(\u0026#34;2020-08-05 13:14:15\u0026#34;).IsAquarius() // false // 是否是双鱼座 carbon.Parse(\u0026#34;2020-08-05 13:14:15\u0026#34;).IsPisces() // false 新增季节判断：按照气象划分，即3-5月为春季，6-8月为夏季，9-11月为秋季，12-2月为冬季\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 获取季节 carbon.Parse(\u0026#34;2020-08-05 13:14:15\u0026#34;).Season() // Summer // 本季节开始时间 carbon.Parse(\u0026#34;2020-08-05 13:14:15\u0026#34;).StartOfSeason().ToDateTimeString() // 2020-06-01 00:00:00 // 本季节结束时间 carbon.Parse(\u0026#34;2020-08-05 13:14:15\u0026#34;).EndOfSeason().ToDateTimeString() // 2020-08-31 23:59:59 // 是否是春季 carbon.Parse(\u0026#34;2020-08-05 13:14:15\u0026#34;).IsSpring() // false // 是否是夏季 carbon.Parse(\u0026#34;2020-08-05 13:14:15\u0026#34;).IsSummer() // true // 是否是秋季 carbon.Parse(\u0026#34;2020-08-05 13:14:15\u0026#34;).IsAutumn() // false // 是否是冬季 carbon.Parse(\u0026#34;2020-08-05 13:14:15\u0026#34;).IsWinter() // false ​\n​\n# 增强时间比较 高配版保留了低配版的所有时间比较方法，同时新增判断是否在两个时间之间，包括两端的时间方法和比较方法Compare，该方法需要指定比较字符=,\u0026lt;=,!=,\u0026lt;\u0026gt;等（只能接收一个比较符，因为只能有一个时间参数比较）。示例如下：\n1 2 3 4 5 6 7 8 9 // 是否在两个时间之间(包括开始时间) carbon.Parse(\u0026#34;2020-08-05 13:14:15\u0026#34;).BetweenIncludedStart(carbon.Parse(\u0026#34;2020-08-05 13:14:15\u0026#34;), carbon.Parse(\u0026#34;2020-08-06 13:14:15\u0026#34;)) // true // 是否在两个时间之间(包括结束时间) carbon.Parse(\u0026#34;2020-08-05 13:14:15\u0026#34;).BetweenIncludedEnd(carbon.Parse(\u0026#34;2020-08-04 13:14:15\u0026#34;), carbon.Parse(\u0026#34;2020-08-05 13:14:15\u0026#34;)) // true // 是否在两个时间之间(包括这两个时间) carbon.Parse(\u0026#34;2020-08-05 13:14:15\u0026#34;).BetweenIncludedBoth(carbon.Parse(\u0026#34;2020-08-05 13:14:15\u0026#34;), carbon.Parse(\u0026#34;2020-08-06 13:14:15\u0026#34;)) // true carbon.Parse(\u0026#34;2020-08-05 13:14:15\u0026#34;).Compare(\u0026#34;\u0026gt;=\u0026#34;, carbon.Parse(\u0026#34;2020-08-05 13:14:15\u0026#34;)) // true carbon.Parse(\u0026#34;2020-08-05 13:14:15\u0026#34;).Compare(\u0026#34;\u0026lt;\u0026gt;\u0026#34;, carbon.Parse(\u0026#34;2020-08-05 13:14:15\u0026#34;)) // false 就是不等于 # 增强时间设置 可以设置时区、设置地区：func SetTimezone(name string)、func SetLocation(loc *time.Location)、func LoadLocation(name string)、func getLocationByTimezone(timezone string)\n时区与地区同名。关系是：地区与时区可以相互转换。可以划等号。 只要是时区文件里面没有的名称时区和地区都不能使用。虽然增强版将时区文件中的时区名都封装成了常量，方便调用。 可以设置区域（国际化设置）：SetLocale\n还可以修改年月日时分秒，用SetXxx方法\n示例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/golang-module/carbon/v2\u0026#34; ) func main() { Shanghai, _ := time.LoadLocation(carbon.Shanghai) Beijing := carbon.SetLocation(Shanghai).Now() BeijingStr := Beijing.ToDateTimeString() Japan := carbon.SetTimezone(carbon.Japan).Now() JapanStr := Japan.ToDateTimeString() fmt.Printf(\u0026#34;东京时间%s比北京时间%s快一个小时，但表示的是同一时刻\\n\u0026#34;, BeijingStr, JapanStr) Beijing = carbon.SetTimezone(carbon.HongKong).Now() BeijingStr = Beijing.ToDateTimeString() Tokyo, _ := time.LoadLocation(carbon.Tokyo) Japan = carbon.SetLocation(Tokyo).Now() JapanStr = Japan.ToDateTimeString() fmt.Printf(\u0026#34;东京时间%s比北京时间%s快一个小时，但表示的是同一时刻\\n\u0026#34;, BeijingStr, JapanStr) } 注意：增强版有一个坑：当我们直接输出Carbon对象时，会自动调用String方法，这个String方法会将时区改成本地。若不希望修改时区，请不要调用String方法，用别的转字符串的方法，如ToDateTimeString。\n1 2 3 4 5 6 7 // 设置年月日时分秒纳秒 carbon.Parse(\u0026#34;2020-01-01\u0026#34;).SetDateTimeNano(2019, 2, 2, 13, 14, 15, 999999999).ToString() // 2019-02-02 13:14:15.999999999 +0800 CST carbon.Parse(\u0026#34;2020-01-01\u0026#34;).SetDateTimeNano(2019, 2, 31, 13, 14, 15, 999999999).ToString() // 2019-03-03 13:14:15.999999999 +0800 CST // 单独设置纳秒 carbon.Parse(\u0026#34;2020-08-05 13:14:15\u0026#34;).SetNanosecond(100000000).Nanosecond() // 100000000 carbon.Parse(\u0026#34;2020-08-05 13:14:15\u0026#34;).SetNanosecond(999999999).Nanosecond() // 999999999 # 时间获取 一句话：直接调用你想获取的时间或日期，只要你想到的都能获取，如获取本年总天数DaysInYear、获取本月总天数DaysInMonth、获取本年第几天、 获取本周第几天：DayOfXxx、获取具体日期或时间DateTime、获取当前世纪Century、获取当前年代Decade十年未一个年代、年月日时分秒毫米微秒纳秒、时间戳就不说了。获取时区Timezone、获取位置Location、获取距离UTC时区的偏移量，单位秒Offset、获取当前区域Locale、 获取当前星座Constellation、获取当前季节Season\n获取年龄Age。（你就说强不强大~）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // 获取年龄 carbon.Parse(\u0026#34;2002-01-01 13:14:15\u0026#34;).Age() // 17 // 获取当前星座 carbon.Now().SetLocale(\u0026#34;en\u0026#34;).Constellation() // Leo carbon.Now().SetLocale(\u0026#34;zh-CN\u0026#34;).Constellation() // 狮子座 // 获取时区 carbon.SetTimezone(carbon.PRC).Timezone() // CST carbon.SetTimezone(carbon.Tokyo).Timezone() // JST // 获取位置 carbon.SetTimezone(carbon.PRC).Location() // PRC carbon.SetTimezone(carbon.Tokyo).Location() // Asia/Tokyo // 获取距离UTC时区的偏移量，单位秒 carbon.SetTimezone(carbon.PRC).Offset() // 28800 carbon.SetTimezone(carbon.Tokyo).Offset() // 32400 // 获取当前区域 carbon.Now().Locale() // en carbon.Now().SetLocale(\u0026#34;zh-CN\u0026#34;).Locale() // zh-CN // 获取本月第几天 carbon.Parse(\u0026#34;2020-08-05 13:14:15\u0026#34;).DayOfMonth() // 5 // 获取本月第几周 carbon.Parse(\u0026#34;2020-08-05 13:14:15\u0026#34;).WeekOfMonth() // 1 更多示例参考\n# 时间输出 时间输出是ToXxxString方法。（你能想到的格式都能输出😂）\n注意：增强版有一个坑：当我们直接输出Carbon对象时，会自动调用String方法，这个String方法会将时区改成本地。若不希望修改时区，请不要调用String方法，用别的转字符串的方法，如ToDateTimeString。\nToString方法为输出time包的默认格式。\n输出指定布局的字符串Layout\n输出指定格式的字符串(如果使用的字母与格式化字符冲突时，请使用\\符号转义该字符Format\n示例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // 输出简写日期字符串 carbon.Parse(\u0026#34;2020-08-05 13:14:15.999999999\u0026#34;).ToShortDateString() // 20200805 // 输出简写时间字符串 carbon.Parse(\u0026#34;2020-08-05 13:14:15.999999999\u0026#34;).ToShortTimeString() // 131415 // 输出简写时间字符串，包含毫秒 carbon.Parse(\u0026#34;2020-08-05 13:14:15.999999999\u0026#34;).ToShortTimeMilliString() // 131415.999 // 输出简写时间字符串，包含微秒 carbon.Parse(\u0026#34;2020-08-05 13:14:15.999999999\u0026#34;).ToShortTimeMicroString() // 131415.999999 // 输出简写时间字符串，包含纳秒 carbon.Parse(\u0026#34;2020-08-05 13:14:15.999999999\u0026#34;).ToShortTimeNanoString() // 131415.999999999 // 输出 UnixDate 格式字符串 carbon.Parse(\u0026#34;2020-08-05 13:14:15\u0026#34;).ToUnixDateString() // Wed Aug 5 13:14:15 CST 2020 // 输出 RFC3339 格式字符串 carbon.Parse(\u0026#34;2020-08-05T13:14:15.999999999+08:00\u0026#34;).ToRfc3339String() // 2020-08-05T13:14:15+08:00 // 输出\u0026#34;2006-01-02 15:04:05.999999999 -0700 MST\u0026#34;格式字符串 carbon.Parse(\u0026#34;2020-08-05 13:14:15\u0026#34;).ToString() // 2020-08-05 13:14:15.999999 +0800 CST // 输出 \u0026#34;Jan 2, 2006\u0026#34; 格式字符串 carbon.Parse(\u0026#34;2020-08-05 13:14:15\u0026#34;).ToFormattedDateString() // Aug 5, 2020 // 输出 \u0026#34;Mon, Jan 2, 2006\u0026#34; 格式字符串 carbon.Parse(\u0026#34;2020-08-05 13:14:15\u0026#34;).ToFormattedDayDateString() // Wed, Aug 5, 2020 // 输出指定布局的字符串 carbon.Parse(\u0026#34;2020-08-05 13:14:15\u0026#34;).Layout(carbon.ISO8601Layout) // 2020-08-05T13:14:15+08:00 carbon.Parse(\u0026#34;2020-08-05 13:14:15\u0026#34;).Layout(\u0026#34;20060102150405\u0026#34;) // 20200805131415 carbon.Parse(\u0026#34;2020-08-05 13:14:15\u0026#34;).Layout(\u0026#34;2006年01月02日 15时04分05秒\u0026#34;) // 2020年08月05日 13时14分15秒 carbon.Parse(\u0026#34;2020-08-05 13:14:15\u0026#34;).Layout(\u0026#34;It is 2006-01-02 15:04:05\u0026#34;) // It is 2020-08-05 13:14:15 // 输出指定格式的字符串(如果使用的字母与格式化字符冲突时，请使用\\符号转义该字符) carbon.Parse(\u0026#34;2020-08-05 13:14:15\u0026#34;).Format(\u0026#34;YmdHis\u0026#34;) // 20200805131415 carbon.Parse(\u0026#34;2020-08-05 13:14:15\u0026#34;).Format(\u0026#34;Y年m月d日 H时i分s秒\u0026#34;) // 2020年08月05日 13时14分15秒 carbon.Parse(\u0026#34;2020-08-05 13:14:15\u0026#34;).Format(\u0026#34;l jS \\\\o\\\\f F Y h:i:s A\u0026#34;) // Wednesday 5th of August 2020 01:14:15 PM carbon.Parse(\u0026#34;2020-08-05 13:14:15\u0026#34;).Format(\u0026#34;\\\\I\\\\t \\\\i\\\\s Y-m-d H:i:s\u0026#34;) // It is 2020-08-05 13:14:15 更多示例参考\n更多格式化输出符号请查看附录 格式化符号表\n# 输出结构体 时间输出不仅能够输出指定字符串ToXxxString，还能输出到指定的结构体类型ToXxxStruct，用与序列化与反序列化指定日期时间格式。只不过输出的结构体类型只有Date和Time组合的。\n示例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 package main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;github.com/golang-module/carbon/v2\u0026#34; ) type Student struct { Birthday1 carbon.DateTime `json:\u0026#34;birthday1\u0026#34;` Birthday2 carbon.Date `json:\u0026#34;birthday2\u0026#34;` } func main() { s := Student{ Birthday1: carbon.Now().SubYears(5).ToDateTimeStruct(), Birthday2: carbon.Now().SubYears(10).ToDateStruct(), } marshal, err := json.Marshal(s) if err != nil { log.Fatal(err) } println(string(marshal)) // {\u0026#34;birthday1\u0026#34;:\u0026#34;2019-05-15 14:57:07\u0026#34;,\u0026#34;birthday2\u0026#34;:\u0026#34;2014-05-15\u0026#34;} s2 := new(Student) err = json.Unmarshal(marshal, s2) if err != nil { log.Fatal(err) } fmt.Println(s2.Birthday1) // 2019-05-15 15:00:27 fmt.Println(s2.Birthday2) // 2014-05-15 } # 总结 carbon提供了很多的实用方法，另外time的方法它也能使用，使得它的功能非常强大。时间其实是一个非常复杂的问题，考虑到时区、闰秒、各地的夏令时等，自己处理起来简直是火葬场。幸好有这些库(┬＿┬)\n# 参考 carbon GitHub 仓库： https://github.com/uniplaces/carbon 增强版carbon GitHub 仓库： https://github.com/golang-module/carbon Go 每日一库之 carbon ","date":"2024-05-13T10:19:13+08:00","permalink":"https://arlettebrook.github.io/p/carbon-introduction/","title":"Carbon Introduction"},{"content":" # 简介 twelve-factor应用提倡将配置存储在环境变量中。任何从开发环境切换到生产环境时需要修改的东西都从代码抽取到环境变量里。 但是在实际开发中，如果同一台机器运行多个项目，设置环境变量容易冲突，不实用。godotenv库从.env文件中读取配置， 然后存储到程序的环境变量中。在代码中可以使用读取非常方便。godotenv源于一个 Ruby 的开源项目dotenv。\n# 快速使用 第三方库需要先安装：\n1 $ go get -u github.com/joho/godotenv 后使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;github.com/joho/godotenv\u0026#34; ) func main() { err := godotenv.Load() if err != nil { log.Fatal(err) } fmt.Println(\u0026#34;name：\u0026#34;, os.Getenv(\u0026#34;name\u0026#34;)) fmt.Println(\u0026#34;age：\u0026#34;, os.Getenv(\u0026#34;AGE\u0026#34;)) } 然后在可执行程序相同目录下，添加一个.env文件（可以给ide安装插件，检查.env文件语法，安装用的人多的。如GoLand：.env files support）：\n1 2 NAME=arlettebrook AGE=18 运行程序，输出：\n1 2 3 $ go run main.go name： arlettebrook age： 18 可见，使用非常方便。默认情况下，godotenv读取项目根目录下的.env文件，文件中使用key=value的格式，每行一个键值对。 调用godotenv.Load()即可加载，可直接调用os.Getenv(\u0026quot;key\u0026quot;)读取,os.Getenv是用来读取环境变量的：windows上不区分大小写，但环境变量通常都是大写，建议用大写。没找到返回空字符串。\n1 2 3 4 5 6 7 8 9 10 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { fmt.Println(os.Getenv(\u0026#34;GOPATH\u0026#34;)) // 会返回GOPAHT环境变量的值 } # 基本使用 # 自动加载 如果你有程序员的优良传统——懒，你可能连Load方法都不想自己调用。没关系，godotenv给你懒的权力！\n导入github.com/joho/godotenv/autoload，配置会自动读取：\n1 2 3 4 5 6 7 8 9 10 11 12 13 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; _ \u0026#34;github.com/joho/godotenv/autoload\u0026#34; ) func main() { fmt.Println(\u0026#34;name: \u0026#34;, os.Getenv(\u0026#34;NAME\u0026#34;)) fmt.Println(\u0026#34;age: \u0026#34;, os.Getenv(\u0026#34;AGE\u0026#34;)) } 注意，由于代码中没有显式用到godotenv库，需要使用空导入，即导入时包名前添加一个_。作用：自动调用init函数。\n看autoload包的源码，其实就是库帮你调用了Load方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package autoload /* You can just read the .env file on import just by doing import _ \u0026#34;github.com/joho/godotenv/autoload\u0026#34; And bob\u0026#39;s your mother\u0026#39;s brother */ import \u0026#34;github.com/joho/godotenv\u0026#34; func init() { godotenv.Load() } 仔细看注释，程序员的恶趣味😂！\n# 加载自定义文件 默认情况下，加载的是项目根目录下的.env文件。当然我们可以加载任意名称的文件，文件也不必以.env为后缀：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;github.com/joho/godotenv\u0026#34; ) func main() { err := godotenv.Load(\u0026#34;common\u0026#34;, \u0026#34;.env.production\u0026#34;, \u0026#34;.env.development\u0026#34;) if err != nil { log.Fatal(err) } fmt.Println(\u0026#34;name: \u0026#34;, os.Getenv(\u0026#34;NAME\u0026#34;)) fmt.Println(\u0026#34;version: \u0026#34;, os.Getenv(\u0026#34;VERSION\u0026#34;)) fmt.Println(\u0026#34;database: \u0026#34;, os.Getenv(\u0026#34;DATABASE\u0026#34;)) } common文件内容：\n1 2 NAME=awesome web VERSION=0.0.1 .env.development：\n1 DATABASE=sqlite .env.production：\n1 DATABASE=mysql 运行输出：\n1 2 3 4 $ go run main.go name: awesome web version: 0.0.1 database: mysql 注意事项：\nLoad接收多个文件名作为参数，如果不传入文件名，默认读取.env文件的内容。 当指定了环境变量文件，默认的.env文件会失效，除非你加进去。 如果多个文件中存在同一个键，那么先出现的优先，后出现的不生效。所以，上面输出的database是mysql。 原因：先出现的已经加载到环境变量中了，默认不会覆盖环境变量中的值。 使用Load方法加载的环境变量不会覆盖默认的环境变量，要覆盖请用Overload方法。 使用这个加载，上面输出的database是sqlite。不信你可以试试\u0026hellip; 以上两种方法都会对环境变量的副本，进行添加或修改。后面会介绍，不存入环境变量。 # 注释 .env文件中可以添加注释，注释以#开始，直到该行结束。\n1 2 3 4 # app name NAME=awesome web # current version VERSION=0.0.1 # YAML .env文件还可以使用 YAML 格式：\n1 2 NAME: \u0026#39;awesome web\u0026#39; VERSION: 0.0.1 1 2 3 4 5 6 7 8 9 10 11 12 13 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; _ \u0026#34;github.com/joho/godotenv/autoload\u0026#34; ) func main() { fmt.Println(\u0026#34;name: \u0026#34;, os.Getenv(\u0026#34;NAME\u0026#34;)) fmt.Println(\u0026#34;version: \u0026#34;, os.Getenv(\u0026#34;VERSION\u0026#34;)) } 运行输出：\n1 2 3 $ go run main.go name: awesome web version: 0.0.1 注意：yaml格式不支持嵌套。官方解释：支持 YAML(ish) 风格。\n# 不存入环境变量 # 从文件读取 godotenv允许不将.env文件内容存入环境变量，使用godotenv.Read()返回一个map[string]string，可直接使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;github.com/joho/godotenv\u0026#34; ) func main() { myEnv, err := godotenv.Read() if err != nil { log.Fatal(err) } fmt.Println(\u0026#34;name: \u0026#34;, myEnv[\u0026#34;NAME\u0026#34;]) fmt.Println(\u0026#34;version: \u0026#34;, myEnv[\u0026#34;VERSION\u0026#34;]) } 注意：\n环境配置文件中的键值对，会保存在返回的map[string]string中，键名与配置键必须同名。 直接操作map，简单直接！ 这样就不会将环境配置文件中的变量存入环境变量。 Read可以接收文件路径，用于指定配置文件。默认./.env,与Load一致。 # 从string, byte中读取配置 除了读取文件，还可以从string中读取配置，它不会修改环境：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;github.com/joho/godotenv\u0026#34; ) func main() { stringContent := ` name: awesome web version: 0.0.1 ` byteContent := []byte(` name: awesome web byte version: 1.0.1`) myEnvWithString, err := godotenv.Unmarshal(stringContent) myEnvWithByte, err := godotenv.UnmarshalBytes(byteContent) if err != nil { log.Fatal(err) } fmt.Println(\u0026#34;name: \u0026#34;, myEnvWithString[\u0026#34;name\u0026#34;]) fmt.Println(\u0026#34;version: \u0026#34;, myEnvWithString[\u0026#34;version\u0026#34;]) fmt.Println(\u0026#34;--------UnmarshalBytes--------\u0026#34;) fmt.Println(\u0026#34;name: \u0026#34;, myEnvWithByte[\u0026#34;name\u0026#34;]) fmt.Println(\u0026#34;version: \u0026#34;, myEnvWithByte[\u0026#34;version\u0026#34;]) } 通过Unmarshal方法，可以从字符串中读取env文件。存储在返回值map[string]string类型中。 通过UnmarshalBytes方法，可以从字节切片中读取env文件。也是存储在map中。 运行输出：\n1 2 3 4 5 6 $ go run main.go name: awesome web version: 0.0.1 --------UnmarshalBytes-------- name: awesome web byte version: 1.0.1 # 从io.Reader获取配置 除了以上方法外，还可以从io.Reader中读取env文件。这个也不会修改环境。\n只要实现了io.Reader接口，就能作为数据源。可以从文件（os.File），网络（net.Conn），bytes.Buffer等多种来源读取：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package main import ( \u0026#34;bytes\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;github.com/joho/godotenv\u0026#34; ) func main() { file, _ := os.Open(\u0026#34;.env\u0026#34;) myEnv, err := godotenv.Parse(file) if err != nil { log.Fatal(err) } fmt.Println(\u0026#34;name: \u0026#34;, myEnv[\u0026#34;NAME\u0026#34;]) fmt.Println(\u0026#34;version: \u0026#34;, myEnv[\u0026#34;VERSION\u0026#34;]) buf := bytes.NewBuffer([]byte{}) buf.WriteString(\u0026#34;name: awesome web @buffer\u0026#34;) buf.Write([]byte{\u0026#39;\\n\u0026#39;}) buf.WriteString(\u0026#34;version: 0.0.1 @buffer\u0026#34;) myEnv, err = godotenv.Parse(buf) if err != nil { log.Fatal(err) } fmt.Println(\u0026#34;name: \u0026#34;, myEnv[\u0026#34;name\u0026#34;]) fmt.Println(\u0026#34;version: \u0026#34;, myEnv[\u0026#34;version\u0026#34;]) } 通过Parse方法，可以中io中读取env文件。从字符串中读取是Unmarshal方法，二者不一样。 读取的配置都保存在map中，没有存入环境变量。map键与配置键必须同名。通过os.Getenv指定的可以不区分大小写，但建议大写。 运行输出：\n1 2 3 4 5 $ go run main.go name: awesome web version: 0.0.1 name: awesome web @buffer version: 0.0.1 @buffer # 生成.env文件or字符串 可以通过程序生成一个.env文件的内容，可以直接写入到文件中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import ( \u0026#34;bytes\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;github.com/joho/godotenv\u0026#34; ) func main() { buf := bytes.NewBuffer([]byte{}) buf.WriteString(\u0026#34;NAME=awesome web @write\u0026#34;) buf.WriteByte(\u0026#39;\\n\u0026#39;) buf.WriteString(\u0026#34;VERSION=0.0.1 @write\u0026#34;) envMap, err := godotenv.Parse(buf) if err != nil { log.Fatal(err) } err = godotenv.Write(envMap, \u0026#34;./write.env\u0026#34;) stringEnv, err := godotenv.Marshal(envMap) if err != nil { log.Fatal(err) } fmt.Println(stringEnv) } 通过Write方法，可以将map中的环境变量，写入到指定文件中。 通过Marshal方法，可以将map中的环境变量，序列化成字符串 运行会在当前目录下生成write.env文件：\n1 2 NAME=\u0026#34;awesome web @write\u0026#34; VERSION=\u0026#34;0.0.1 @write\u0026#34; TTY输出：\n1 2 3 $ go run main.go NAME=\u0026#34;awesome web @write\u0026#34; VERSION=\u0026#34;0.0.1 @write\u0026#34; # 命令行模式 godotenv还提供了一个命令行的模式。要使用它，先要确保命令安装到$GOPATH/bin目录下：\n1 $ go install github.com/joho/godotenv/cmd/godotenv@latest 这个命令行程序，源码很简单，在github.com/joho/godotenv/cmd/godotenv路径下,用flag库解析的命令行参数。作用是读取env文件，写入环境变量中，不用在程序中调用godotenv。最后是通过Exec方法调用Load方法实现的。感兴趣的可以自己去看一下。\n安装后之后可以查看帮助信息，大致为：\n1 2 $ godotenv -h godotenv [-o] [-f ENV_FILE_PATHS] COMMAND_ARGS -o：是否覆盖环境变量，默认false -f：字段env文件，默认./.env 剩余参数：启动的程序 示例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { fmt.Println(os.Getenv(\u0026#34;NAME\u0026#34;)) fmt.Println(os.Getenv(\u0026#34;VERSION\u0026#34;)) fmt.Println(os.Getenv(\u0026#34;USERNAME\u0026#34;)) } ./.env文件：\n1 2 3 NAME: \u0026#39;awesome web\u0026#39; VERSION: 0.0.1 USERNAME: arlettebrook 使用godotenv命令启动程序,演示如下：\n1 2 3 4 5 6 7 8 9 $ godotenv go run main.go awesome web 0.0.1 Lenovo $ godotenv -o go run main.go awesome web 0.0.1 arlettebrook 第一次没有覆盖USERNAME,第二次覆盖了。\n通过godotenv命令行程序，我们可以不用再自己的程序中调用godotenv读取env文件。\n# 指定环境启动 实践中，一般会根据APP_ENV环境变量的值加载不同的文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;github.com/joho/godotenv\u0026#34; ) func main() { env := os.Getenv(\u0026#34;LEARN_ENV\u0026#34;) if env == \u0026#34;\u0026#34; { env = \u0026#34;development\u0026#34; } err := godotenv.Load(\u0026#34;.env.\u0026#34; + env) if err != nil { log.Fatal(err) } err = godotenv.Load() if err != nil { log.Fatal(err) } fmt.Println(\u0026#34;name: \u0026#34;, os.Getenv(\u0026#34;NAME\u0026#34;)) fmt.Println(\u0026#34;version: \u0026#34;, os.Getenv(\u0026#34;VERSION\u0026#34;)) fmt.Println(\u0026#34;database: \u0026#34;, os.Getenv(\u0026#34;DATABASE\u0026#34;)) } 我们先读取环境变量LEARN_ENV，然后读取对应的.env. + env，最后读取默认的.env文件。\n前面也提到过，先读取到的优先。我们可以在默认的.env文件中配置基础信息和一些默认的值， 如果在开发/测试/生产环境需要修改，那么在对应的.env.development/.env.test/.env.production文件中再配置一次即可。\n.env文件内容：\n1 2 3 NAME: \u0026#39;awesome web\u0026#39; VERSION: 0.0.1 DATABASE: mongodb .env.development：\n1 DATABASE=sqlite .env.production：\n1 DATABASE=mysql 运行输出演示：\n1 2 3 4 5 6 7 8 9 10 11 # 默认是开发环境 $ go run main.go name: awesome web version: 0.0.1 database: sqlite # 用Load不会覆盖，所以表示mongodb # 设置为生成环境 $ LEARN_ENV=production go run main.go name: awesome web version: 0.0.1 database: mysql # 一点源码 (其实你应该提前看一下源码~)\ngodotenv读取文件内容，为什么可以使用os.Getenv访问：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // github.com/joho/godotenv/godotenv.go func loadFile(filename string, overload bool) error { envMap, err := readFile(filename) if err != nil { return err } currentEnv := map[string]bool{} rawEnv := os.Environ() for _, rawEnvLine := range rawEnv { key := strings.Split(rawEnvLine, \u0026#34;=\u0026#34;)[0] currentEnv[key] = true } for key, value := range envMap { if !currentEnv[key] || overload { _ = os.Setenv(key, value) } } return nil } 因为godotenv调用os.Setenv将键值对设置到环境变量中了。就是在运行的时候修改了环境变量。\n# 总结 本文介绍了godotenv库的基础和高级用法。godotenv的源码也比较好读，有时间，有兴趣的童鞋建议一看~\n# 参考 godotenv GitHub 仓库： https://github.com/joho/godotenv 原文：Go 每日一库之 godotenv ","date":"2024-05-12T14:29:33+08:00","permalink":"https://arlettebrook.github.io/p/godotenv-introduction/","title":"Godotenv Introduction"},{"content":" # 介绍 今天我们再来介绍Steve Francia（spf13）大神的另一个库cast。cast是一个小巧、实用的类型转换库，用于将一个类型转为另一个类型。它提供了一套高效且安全的类型转换功能。 最初开发cast是用在hugo中的。\n# 快速使用 先安装：\n1 $ go get -u github.com/spf13/cast 后使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/spf13/cast\u0026#34; ) func main() { // ToString fmt.Println(cast.ToString(\u0026#34;apple\u0026#34;)) // apple fmt.Println(cast.ToString(8)) // 8 fmt.Println(cast.ToString(8.31)) // 8.31 fmt.Println(cast.ToString([]byte(\u0026#34;one time\u0026#34;))) // one time fmt.Println(cast.ToString(nil)) // \u0026#34;\u0026#34; var foo interface{} = \u0026#34;one more time\u0026#34; fmt.Println(cast.ToString(foo)) // one more time // ToInt fmt.Println(cast.ToInt(8)) // 8 fmt.Println(cast.ToInt(8.31)) // 8 fmt.Println(cast.ToInt(\u0026#34;8\u0026#34;)) // 8 fmt.Println(cast.ToInt(true)) // 1 fmt.Println(cast.ToInt(false)) // 0 var eight interface{} = 8 fmt.Println(cast.ToInt(eight)) // 8 fmt.Println(cast.ToInt(nil)) // 0 } 实际上，cast实现了多种常见类型之间的相互转换，返回最符合直觉的结果。例如：\nnil转为string的结果为\u0026quot;\u0026quot;，而不是\u0026quot;nil\u0026quot;； true转为string的结果为\u0026quot;true\u0026quot;，而true转为int的结果为1； interface{}转为其他类型，要看它里面存储的值类型。 这些类型包括所有的基本类型（整形、浮点型、布尔值和字符串）、空接口、nil，时间（time.Time）、时长（time.Duration）以及它们的切片类型， 还有map[string]Type（其中Type为前面提到的类型）：\n1 2 3 4 byte bool float32 float64 string int8 int16 int32 int64 int uint8 uint16 uint32 uint64 uint interface{} time.Time time.Duration nil # 基本使用 cast提供了两组函数：\nToType（其中Type可以为任何支持的类型），将参数转换为Type类型。如果无法转换，返回Type类型的零值或nil； ToTypeE以 E 结尾，返回转换后的值和一个error。这组函数可以区分参数中实际存储了零值，还是转换失败了。 # 源码分析： 实现上大部分代码都类似，ToType在内部调用ToTypeE函数，返回结果并忽略错误。ToType函数的实现在文件cast.go中， 而ToTypeE函数的实现在文件caste.go中。\n1 2 3 4 5 6 7 8 9 10 11 // cast/cast.go func ToBool(i interface{}) bool { v, _ := ToBoolE(i) return v } // ToDuration casts an interface to a time.Duration type. func ToDuration(i interface{}) time.Duration { v, _ := ToDurationE(i) return v } ToTypeE函数都接受任意类型的参数（interface{}），然后使用类型断言根据具体的类型来执行不同的转换。如果无法转换，返回错误。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 // cast/caste.go // ToBoolE casts an interface to a bool type. func ToBoolE(i interface{}) (bool, error) { i = indirect(i) switch b := i.(type) { case bool: return b, nil case nil: return false, nil case int: return b != 0, nil case int64: return b != 0, nil case int32: return b != 0, nil case int16: return b != 0, nil case int8: return b != 0, nil case uint: return b != 0, nil case uint64: return b != 0, nil case uint32: return b != 0, nil case uint16: return b != 0, nil case uint8: return b != 0, nil case float64: return b != 0, nil case float32: return b != 0, nil case time.Duration: return b != 0, nil case string: return strconv.ParseBool(i.(string)) case json.Number: v, err := ToInt64E(b) if err == nil { return v != 0, nil } return false, fmt.Errorf(\u0026#34;unable to cast %#v of type %T to bool\u0026#34;, i, i) default: return false, fmt.Errorf(\u0026#34;unable to cast %#v of type %T to bool\u0026#34;, i, i) } } 首先调用indirect函数将参数中可能的指针去掉（返回原始类型）。如果类型本身不是指针，那么直接返回。否则返回指针指向的值。 循环直到返回一个非指针的值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 func indirect(a interface{}) interface{} { if a == nil { return nil } if t := reflect.TypeOf(a); t.Kind() != reflect.Ptr { // Avoid creating a reflect.Value if it\u0026#39;s not a pointer. return a } v := reflect.ValueOf(a) for v.Kind() == reflect.Ptr \u0026amp;\u0026amp; !v.IsNil() { v = v.Elem() } return v.Interface() } 所以，下面代码输出都是 8：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/spf13/cast\u0026#34; ) func main() { /* 与make的区别： new创建指向该类型零值的指针 make创建指定的类型，并分配内存，用与引用类型 */ p := new(int) *p = 8 fmt.Println(cast.ToInt(p)) // 8 pp := \u0026amp;p fmt.Println(cast.ToInt(pp)) // 8 } # 时间和时长转换 时间类型的转换代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // cast/caste.go func ToTimeInDefaultLocationE(i interface{}, location *time.Location) (tim time.Time, err error) { i = indirect(i) switch v := i.(type) { case time.Time: return v, nil case string: return StringToDateInDefaultLocation(v, location) case json.Number: s, err1 := ToInt64E(v) if err1 != nil { return time.Time{}, fmt.Errorf(\u0026#34;unable to cast %#v of type %T to Time\u0026#34;, i, i) } return time.Unix(s, 0), nil case int: return time.Unix(int64(v), 0), nil case int64: return time.Unix(v, 0), nil case int32: return time.Unix(int64(v), 0), nil case uint: return time.Unix(int64(v), 0), nil case uint64: return time.Unix(int64(v), 0), nil case uint32: return time.Unix(int64(v), 0), nil default: return time.Time{}, fmt.Errorf(\u0026#34;unable to cast %#v of type %T to Time\u0026#34;, i, i) } } 根据传入的类型执行不同的处理：\n如果是time.Time，直接返回； 如果是整型，将参数作为时间戳（自 UTC 时间1970.01.01 00:00:00到现在的秒数）调用time.Unix生成时间。Unix接受两个参数，第一个参数指定秒，第二个参数指定纳秒； 如果是字符串，调用StringToDateInDefaultLocation函数依次尝试以下面这些时间格式调用time.Parse解析该字符串。如果某个格式解析成功，则返回获得的time.Time。否则解析失败，返回错误； 其他任何类型都无法转换为time.Time。 字符串转换为时间：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 // cast/caste.go var ( timeFormats = []timeFormat{ // Keep common formats at the top. {\u0026#34;2006-01-02\u0026#34;, timeFormatNoTimezone}, {time.RFC3339, timeFormatNumericTimezone}, {\u0026#34;2006-01-02T15:04:05\u0026#34;, timeFormatNoTimezone}, // iso8601 without timezone {time.RFC1123Z, timeFormatNumericTimezone}, {time.RFC1123, timeFormatNamedTimezone}, {time.RFC822Z, timeFormatNumericTimezone}, {time.RFC822, timeFormatNamedTimezone}, {time.RFC850, timeFormatNamedTimezone}, {\u0026#34;2006-01-02 15:04:05.999999999 -0700 MST\u0026#34;, timeFormatNumericAndNamedTimezone}, // Time.String() {\u0026#34;2006-01-02T15:04:05-0700\u0026#34;, timeFormatNumericTimezone}, // RFC3339 without timezone hh:mm colon {\u0026#34;2006-01-02 15:04:05Z0700\u0026#34;, timeFormatNumericTimezone}, // RFC3339 without T or timezone hh:mm colon {\u0026#34;2006-01-02 15:04:05\u0026#34;, timeFormatNoTimezone}, {time.ANSIC, timeFormatNoTimezone}, {time.UnixDate, timeFormatNamedTimezone}, {time.RubyDate, timeFormatNumericTimezone}, {\u0026#34;2006-01-02 15:04:05Z07:00\u0026#34;, timeFormatNumericTimezone}, {\u0026#34;02 Jan 2006\u0026#34;, timeFormatNoTimezone}, {\u0026#34;2006-01-02 15:04:05 -07:00\u0026#34;, timeFormatNumericTimezone}, {\u0026#34;2006-01-02 15:04:05 -0700\u0026#34;, timeFormatNumericTimezone}, {time.Kitchen, timeFormatTimeOnly}, {time.Stamp, timeFormatTimeOnly}, {time.StampMilli, timeFormatTimeOnly}, {time.StampMicro, timeFormatTimeOnly}, {time.StampNano, timeFormatTimeOnly}, } ) func StringToDateInDefaultLocation(s string, location *time.Location) (time.Time, error) { return parseDateWith(s, location, timeFormats) } func parseDateWith(s string, location *time.Location, formats []timeFormat) (d time.Time, e error) { for _, format := range formats { if d, e = time.Parse(format.format, s); e == nil { // Some time formats have a zone name, but no offset, so it gets // put in that zone name (not the default one passed in to us), but // without that zone\u0026#39;s offset. So set the location manually. if format.typ \u0026lt;= timeFormatNamedTimezone { if location == nil { location = time.Local } year, month, day := d.Date() hour, min, sec := d.Clock() d = time.Date(year, month, day, hour, min, sec, d.Nanosecond(), location) } return } } return d, fmt.Errorf(\u0026#34;unable to parse date: %s\u0026#34;, s) } 时长类型的转换代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // cast/caste.go func ToDurationE(i interface{}) (d time.Duration, err error) { i = indirect(i) switch s := i.(type) { case time.Duration: return s, nil case int, int64, int32, int16, int8, uint, uint64, uint32, uint16, uint8: d = time.Duration(ToInt64(s)) return case float32, float64: d = time.Duration(ToFloat64(s)) return case string: if strings.ContainsAny(s, \u0026#34;nsuµmh\u0026#34;) { d, err = time.ParseDuration(s) } else { d, err = time.ParseDuration(s + \u0026#34;ns\u0026#34;) } return case json.Number: var v float64 v, err = s.Float64() d = time.Duration(v) return default: err = fmt.Errorf(\u0026#34;unable to cast %#v of type %T to Duration\u0026#34;, i, i) return } } 根据传入的类型进行不同的处理：\n如果是time.Duration类型，直接返回； 如果是整型或浮点型，将其数值强制转换为time.Duration类型，单位默认为ns； 如果是字符串，分为两种情况：如果字符串中有时间单位符号nsuµmh，直接调用time.ParseDuration解析；否则在字符串后拼接ns再调用time.ParseDuration解析； 其他类型解析失败。 # 时间、时长示例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/spf13/cast\u0026#34; ) func main() { now := time.Now() timestamp := 1579615973 timeStr := \u0026#34;2020-01-21 22:13:48\u0026#34; fmt.Println(cast.ToTime(now)) // 2020-01-22 06:31:50.5068465 +0800 CST m=+0.000997701 fmt.Println(cast.ToTime(timestamp)) // 2020-01-21 22:12:53 +0800 CST fmt.Println(cast.ToTime(timeStr)) // 2020-01-21 22:13:48 +0000 UTC d, _ := time.ParseDuration(\u0026#34;1m30s\u0026#34;) ns := 30000 strWithS := \u0026#34;130s\u0026#34; strWithoutNs := \u0026#34;130\u0026#34; fmt.Println(cast.ToDuration(d)) // 1m30s fmt.Println(cast.ToDuration(ns)) // 30µs fmt.Println(cast.ToDuration(strWithS)) // 2m10s fmt.Println(cast.ToDuration(strWithoutNs)) // 130ns } # 转换为切片 实际上，这些函数的实现基本类似。使用类型断言判断类型。如果就是要返回的类型，直接返回。否则根据类型进行相应的转换。\n我们主要分析两个实现：ToIntSliceE和ToStringSliceE。ToBoolSliceE/ToDurationSliceE与ToIntSliceE基本相同。\n首先是ToIntSliceE：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 func ToIntSliceE(i interface{}) ([]int, error) { if i == nil { return []int{}, fmt.Errorf(\u0026#34;unable to cast %#v of type %T to []int\u0026#34;, i, i) } switch v := i.(type) { case []int: return v, nil } kind := reflect.TypeOf(i).Kind() switch kind { case reflect.Slice, reflect.Array: s := reflect.ValueOf(i) a := make([]int, s.Len()) for j := 0; j \u0026lt; s.Len(); j++ { val, err := ToIntE(s.Index(j).Interface()) if err != nil { return []int{}, fmt.Errorf(\u0026#34;unable to cast %#v of type %T to []int\u0026#34;, i, i) } a[j] = val } return a, nil default: return []int{}, fmt.Errorf(\u0026#34;unable to cast %#v of type %T to []int\u0026#34;, i, i) } } 根据传入参数的类型：\n如果是nil，直接返回错误； 如果是[]int，不用转换，直接返回； 如果传入类型为切片或数组，新建一个[]int，将切片或数组中的每个元素转为int放到该[]int中。最后返回这个[]int； 其他情况，不能转换。 ToStringSliceE：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 func ToStringSliceE(i interface{}) ([]string, error) { var a []string switch v := i.(type) { case []interface{}: for _, u := range v { a = append(a, ToString(u)) } return a, nil case []string: return v, nil case []int8: for _, u := range v { a = append(a, ToString(u)) } return a, nil case []int: for _, u := range v { a = append(a, ToString(u)) } return a, nil case []int32: for _, u := range v { a = append(a, ToString(u)) } return a, nil case []int64: for _, u := range v { a = append(a, ToString(u)) } return a, nil case []float32: for _, u := range v { a = append(a, ToString(u)) } return a, nil case []float64: for _, u := range v { a = append(a, ToString(u)) } return a, nil case string: return strings.Fields(v), nil case []error: for _, err := range i.([]error) { a = append(a, err.Error()) } return a, nil case interface{}: str, err := ToStringE(v) if err != nil { return a, fmt.Errorf(\u0026#34;unable to cast %#v of type %T to []string\u0026#34;, i, i) } return []string{str}, nil default: return a, fmt.Errorf(\u0026#34;unable to cast %#v of type %T to []string\u0026#34;, i, i) } } 根据传入的参数类型：\n如果是[]interface{}，将该参数中每个元素转为string，返回结果切片； 如果是[]string，不需要转换，直接返回； 如果是interface{}，将参数转为string，返回只包含这个值的切片； 如果是string，调用strings.Fields函数按空白符将参数拆分，返回拆分后的字符串切片； 其他情况，不能转换。 # 转换为切片示例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/spf13/cast\u0026#34; ) func main() { sliceOfInt := []int{1, 3, 7} arrayOfInt := [3]int{8, 12} // ToIntSlice fmt.Println(cast.ToIntSlice(sliceOfInt)) // [1 3 7] fmt.Println(cast.ToIntSlice(arrayOfInt)) // [8 12 0] sliceOfInterface := []interface{}{1, 2.0, \u0026#34;apple\u0026#34;} sliceOfString := []string{\u0026#34;abc\u0026#34;, \u0026#34;dj\u0026#34;, \u0026#34;banana\u0026#34;} stringFields := \u0026#34; abc def hij hah\u0026#34; common := interface{}(37) // ToStringSliceE fmt.Println(cast.ToStringSlice(sliceOfInterface)) // [1 2 apple] fmt.Println(cast.ToStringSlice(sliceOfString)) toStringFields := cast.ToStringSlice(stringFields) fmt.Println(toStringFields, len(toStringFields)) // [abc dj banana hah] 4 // [abc def hij] fmt.Println(cast.ToStringSlice(common)) // [37] // ToToDurationSlice stringDurationSlice := []string{\u0026#34;1m23s\u0026#34;, \u0026#34;22h\u0026#34;} intDurationArray := [3]int{222222222, 88383838888} fmt.Println(cast.ToDurationSlice(stringDurationSlice)) // [1m23s 22h0m0s] fmt.Println(cast.ToDurationSlice(intDurationArray)) // [222.222222ms 1m28.383838888s 0s] // stringBoolSlice := []string{\u0026#34;true\u0026#34;, \u0026#34;false\u0026#34;, \u0026#34;1\u0026#34;, \u0026#34;0\u0026#34;, \u0026#34;T\u0026#34;} intBoolArray := [3]int{1, 0, 22} fmt.Println(cast.ToBoolSlice(stringBoolSlice)) // /*[true false true false true]*/ fmt.Println(cast.ToBoolSlice(intBoolArray)) // [true false true] } # 转为map[string]Type类型 cast库能将传入的参数转为map[string]Type类型，Type为上面支持的类型。\n其实只需要分析一个ToStringMapStringE函数就可以了，其他的实现基本一样。ToStringMapStringE返回map[string]string类型的值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 func ToStringMapStringE(i interface{}) (map[string]string, error) { var m = map[string]string{} switch v := i.(type) { case map[string]string: return v, nil case map[string]interface{}: for k, val := range v { m[ToString(k)] = ToString(val) } return m, nil case map[interface{}]string: for k, val := range v { m[ToString(k)] = ToString(val) } return m, nil case map[interface{}]interface{}: for k, val := range v { m[ToString(k)] = ToString(val) } return m, nil case string: err := jsonStringToObject(v, \u0026amp;m) return m, err default: return m, fmt.Errorf(\u0026#34;unable to cast %#v of type %T to map[string]string\u0026#34;, i, i) } } 根据传入的参数类型：\n如果是map[string]string，不用转换，直接返回； 如果是map[string]interface{}，将每个值转为string存入新的 map，最后返回新的 map； 如果是map[interface{}]string，将每个键转为string存入新的 map，最后返回新的 map； 如果是map[interface{}]interface{}，将每个键和值都转为string存入新的 map，最后返回新的 map； 如果是string类型，cast将它看成一个 JSON 串，解析这个 JSON 到map[string]string，然后返回结果； 其他情况，返回错误。 转换为映射示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/spf13/cast\u0026#34; ) func main() { m1 := map[string]string{ \u0026#34;name\u0026#34;: \u0026#34;apple\u0026#34;, \u0026#34;job\u0026#34;: \u0026#34;developer\u0026#34;, } m2 := map[string]interface{}{ \u0026#34;name\u0026#34;: \u0026#34;banana\u0026#34;, \u0026#34;age\u0026#34;: 18, } m3 := map[interface{}]string{ \u0026#34;name\u0026#34;: \u0026#34;orange\u0026#34;, \u0026#34;job\u0026#34;: \u0026#34;designer\u0026#34;, } m4 := map[any]interface{}{ \u0026#34;name\u0026#34;: \u0026#34;strawberry\u0026#34;, \u0026#34;age\u0026#34;: 29, 18: \u0026#34;hi\u0026#34;, } jsonStr := `{\u0026#34;name\u0026#34;:\u0026#34;bibi\u0026#34;, \u0026#34;job\u0026#34;:\u0026#34;manager\u0026#34;}` fmt.Println(cast.ToStringMapString(m1)) // map[job:developer name:apple] fmt.Println(cast.ToStringMapString(m2)) // map[age:18 name:banana] fmt.Println(cast.ToStringMapString(m3)) // map[job:designer name:orange] fmt.Println(cast.ToStringMapString(m4)) // map[18:hi age:29 name:strawberry] fmt.Println(cast.ToStringMapString(jsonStr)) // map[job:manager name:bibi] } # 总结 cast库能在几乎所有常见类型之间转换，使用非常方便。代码量也很小，有时间建议读读源码。常用于解析配置数据。\n# 参考 cast GitHub 仓库 原作者：Go 每日一库之 cast ","date":"2024-05-11T18:45:59+08:00","permalink":"https://arlettebrook.github.io/p/cast-introduction/","title":"Cast Introduction"},{"content":" Logrus 是目前 GitHub 上 Star 数量最多的 Go 日志库。尽管目前 Logrus 处于维护模式，不再引入新功能，但这并不意味着它已经死了。Logrus 仍将继续维护，以确保安全性、错误修复和提高性能。作为 Go 社区中最受欢迎的日志库之一，Logrus 最大的贡献是推动了 Go 社区广泛使用结构化（如JSON格式)的日志记录。著名的 Docker 项目就在使用 Logrus 记录日志，这进一步证明了其在实际应用中的可靠性和实用性。\n# 特点 Logrus 具有如下特点：\n与 Go log 标准库 API 完全兼容，这意味着任何使用 log 标准库的代码都可以将日志库无缝切换到 Logrus。 支持七种日志级别：Trace、Debug、Info、Warn、Error、Fatal、Panic。 支持结构化日志记录（key-value 形式，容易被程序解析，如 JSON 格式），通过 Filed 机制进行结构化的日志记录。 支持自定义日志格式，内置两种格式 JSONFormatter（JSON 格式） 和 TextFormatter（文本格式），并允许用户通过实现 Formatter 接口来自定义日志格式。 支持可扩展的 Hooks 机制，可以为不同级别的日志添加 Hooks 将日志记录到不同位置，例如将 Error、Fatal 和 Panic 级别的错误日志发送到 logstash、kafka 等。 支持在控制台输出带有不同颜色的日志。 并发安全。 # 快速使用 第三方库需要先安装：\n1 $ go get -u github.com/sirupsen/logrus 后使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main import ( \u0026#34;github.com/sirupsen/logrus\u0026#34; ) func main() { logrus.SetLevel(logrus.TraceLevel) logrus.Trace(\u0026#34;trace msg\u0026#34;) logrus.Debug(\u0026#34;debug msg\u0026#34;) logrus.Info(\u0026#34;info msg\u0026#34;) logrus.Warn(\u0026#34;warn msg\u0026#34;) logrus.Error(\u0026#34;error msg\u0026#34;) logrus.Fatal(\u0026#34;fatal msg\u0026#34;) logrus.Panic(\u0026#34;panic msg\u0026#34;) } logrus的使用非常简单，与标准库log类似。logrus支持更多的日志级别：\nPanic：记录日志，然后panic。 Fatal：致命错误，出现错误时程序无法正常运转。输出日志后，程序退出； Error：错误日志，需要查看原因； Warn：警告信息，提醒程序员注意； Info：关键操作，核心流程的日志； Debug：一般程序中输出的调试信息； Trace：很细粒度的信息，一般用不到； 日志级别从上向下依次减小，Trace最小，Panic最大。logrus有一个日志级别，低于这个级别的日志不会输出。 默认的级别为InfoLevel。所以为了能看到Trace和Debug日志，我们在main函数第一行设置日志级别为TraceLevel。\n运行程序，非标准TTY输出：\n1 2 3 4 5 6 7 8 $ go run main.go time=\u0026#34;2024-05-09T11:31:42+08:00\u0026#34; level=trace msg=\u0026#34;trace msg\u0026#34; time=\u0026#34;2024-05-09T11:31:42+08:00\u0026#34; level=debug msg=\u0026#34;debug msg\u0026#34; time=\u0026#34;2024-05-09T11:31:42+08:00\u0026#34; level=info msg=\u0026#34;info msg\u0026#34; time=\u0026#34;2024-05-09T11:31:42+08:00\u0026#34; level=warning msg=\u0026#34;warn msg\u0026#34; time=\u0026#34;2024-05-09T11:31:42+08:00\u0026#34; level=error msg=\u0026#34;error msg\u0026#34; time=\u0026#34;2024-05-09T11:31:42+08:00\u0026#34; level=fatal msg=\u0026#34;fatal msg\u0026#34; exit status 1 logrus默认输出到标准错误。格式是文本格式，即默认的Formatter是TextFormatter。\n还有默认情况下，log.SetFormatter(\u0026amp;log.TextFormatter{})（即默认的TextFormatter）未连接 TTY 时，输出与 logfmt格式兼容（就是上面输出的格式）。当连接TTY时,会对输出的日志进行颜色编码，参考官方图片:\n为了确保即使连接了 TTY 也能实现不带颜色输出，请按如下方式设置格式化程序：\n1 2 3 logrus.SetFormatter(\u0026amp;log.TextFormatter{ DisableColors: true, }) 如果连接了TTY没有实现颜色输出（原因之一：非标准TTY、自定义的Formatter等)，需要颜色输出，请按如下方式设置格式化程序：\n1 2 3 4 logrus.SetFormatter(\u0026amp;logrus.TextFormatter{ ForceColors: true, // 强制输出颜色，原理：绕过TTY检查。 FullTimestamp: true, // 显示完整的时间戳 }) 当绕过TTY检查时会丢失日期时间，添加FullTimestamp: true,即可正常显示。\n后面会介绍更多格式化器。\n由于logrus.Fatal会导致程序退出，下面的logrus.Panic不会执行到。\n另外，我们观察到输出中有三个关键信息，time、level和msg：\ntime：输出日志的时间；为本地区标准时间。 补充：+08:00为北京标准时间，改为Z为UTC（世界标准时间，零时区时间） T为日期与时间的分隔符。是ISO定制的一种标准日期时间的表示方式。 level：日志级别； msg：日志信息。 # 使用 # 替代 Go log 标准库 在深入探究 Go log 标准库一文中举过一个使用 Go log 标准库的简单示例，现在可以将其无缝切换到 Logrus，只需要把 import \u0026quot;log\u0026quot; 改成 import log \u0026quot;github.com/sirupsen/logrus\u0026quot; 即可实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package main // 替代 import \u0026#34;log\u0026#34; import ( log \u0026#34;github.com/sirupsen/logrus\u0026#34; ) func main() { log.Print(\u0026#34;Print\u0026#34;) log.Printf(\u0026#34;Printf: %s\u0026#34;, \u0026#34;print\u0026#34;) log.Println(\u0026#34;Println\u0026#34;) log.Fatal(\u0026#34;Fatal\u0026#34;) log.Fatalf(\u0026#34;Fatalf: %s\u0026#34;, \u0026#34;fatal\u0026#34;) log.Fatalln(\u0026#34;Fatalln\u0026#34;) log.Panic(\u0026#34;Panic\u0026#34;) log.Panicf(\u0026#34;Panicf: %s\u0026#34;, \u0026#34;panic\u0026#34;) log.Panicln(\u0026#34;Panicln\u0026#34;) } 执行以上代码，得到如下输出：\n1 2 3 4 5 6 $ go run main.go time=\u0026#34;2024-05-09T14:13:43+08:00\u0026#34; level=info msg=Print time=\u0026#34;2024-05-09T14:13:43+08:00\u0026#34; level=info msg=\u0026#34;Printf: print\u0026#34; time=\u0026#34;2024-05-09T14:13:43+08:00\u0026#34; level=info msg=Println time=\u0026#34;2024-05-09T14:13:43+08:00\u0026#34; level=fatal msg=Fatal exit status 1 虽然输出格式与使用 Go log 标准库表现略有不同，但程序执行并不会报错，说明二者完全兼容。\n# 基本使用 # 修改日志级别 调用logrus.SetLevel(level Level)，就可以修改日志级别。\nlogrus默认的text记录器日志级别是InfoLevel。要想要输出info以下级别的日志，就必须修改。\n如\n1 logrus.SetLevel(logrus.TraceLevel) level可选择类型：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // logrus/logrus.go const ( // PanicLevel level, highest level of severity. Logs and then calls panic with the // message passed to Debug, Info, ... PanicLevel Level = iota // FatalLevel level. Logs and then calls `logger.Exit(1)`. It will exit even if the // logging level is set to Panic. FatalLevel // ErrorLevel level. Logs. Used for errors that should definitely be noted. // Commonly used for hooks to send errors to an error tracking service. ErrorLevel // WarnLevel level. Non-critical entries that deserve eyes. WarnLevel // InfoLevel level. General operational entries about what\u0026#39;s going on inside the // application. InfoLevel // DebugLevel level. Usually only enabled when debugging. Very verbose logging. DebugLevel // TraceLevel level. Designates finer-grained informational events than the Debug. TraceLevel ) # 输出调用信息 调用logrus.SetReportCaller(true)，会在输出日志中添加方法、文件以及行号信息：\n1 2 3 4 5 6 7 8 9 10 11 package main import ( \u0026#34;github.com/sirupsen/logrus\u0026#34; ) func main() { logrus.SetReportCaller(true) logrus.Info(\u0026#34;info msg\u0026#34;) } 输出多了两个字段：func为函数名，file为调用logrus相关方法的文件名以及行号：\n1 2 3 $ go run main.go time=\u0026#34;2024-05-09T14:26:00+08:00\u0026#34; level=info msg=\u0026#34;info msg\u0026#34; func=main.main file=\u0026#34;F:/GoProject/learn /main.go:10\u0026#34; # 添加字段 Logrus 鼓励用户通过日志字段记录结构化日志，可以使用 WithFields 和 WithField 两种形式，并且可以链式调用。\n尽量别用logrus.Fatalf(\u0026quot;Failed to send event %s to topic %s with key %d\u0026quot;) 这种纯文本形式，因为结构化日志有利于工具提取并分析日志。\n有时候需要在输出中添加一些字段，可以通过调用logrus.WithField（接收单个字段）和logrus.WithFields（接收多个字段）实现。 logrus.WithFields接受一个logrus.Fields类型的参数，其底层实际上为map[string]interface{}：\n1 2 // github.com/sirupsen/logrus/logrus.go type Fields map[string]interface{} 二者都可以链式调用，会返回一个指向Entry类型的结构体（日志条目logrus.Entry），该结构体绑定了各种级别的日志方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main import ( \u0026#34;github.com/sirupsen/logrus\u0026#34; ) func main() { logrus. WithField(\u0026#34;name\u0026#34;, \u0026#34;arlettebrook\u0026#34;). WithField(\u0026#34;age\u0026#34;, 18). Info(\u0026#34;WithFiled\u0026#34;) logrus.WithFields(logrus.Fields{ \u0026#34;name\u0026#34;: \u0026#34;arlettebrook\u0026#34;, \u0026#34;age\u0026#34;: 18, }).Info(\u0026#34;WithFields\u0026#34;) } 运行输出：\n1 2 3 $ go run main.go time=\u0026#34;2024-05-09T15:22:24+08:00\u0026#34; level=info msg=WithFiled age=18 name=arlettebrook time=\u0026#34;2024-05-09T15:22:24+08:00\u0026#34; level=info msg=WithFields age=18 name=arlettebrook 默认字段：如果在一个函数中的所有日志都需要添加某些字段，可以使用WithFields的返回的*Entry替换logrus。这样后续输出都会包含指定字段：\n1 2 3 4 5 6 7 8 9 10 11 12 package main import \u0026#34;github.com/sirupsen/logrus\u0026#34; func main() { withFieldsLog := logrus.WithFields(logrus.Fields{ \u0026#34;name\u0026#34;: \u0026#34;arlettebrook\u0026#34;, \u0026#34;age\u0026#34;: 18, }) withFieldsLog.Error(\u0026#34;error msg\u0026#34;) withFieldsLog.Info(\u0026#34;info msg\u0026#34;) } 运行输出：\n1 2 3 $ go run main.go time=\u0026#34;2024-05-09T15:37:56+08:00\u0026#34; level=error msg=\u0026#34;error msg\u0026#34; age=18 name=arlettebrook time=\u0026#34;2024-05-09T15:37:56+08:00\u0026#34; level=info msg=\u0026#34;info msg\u0026#34; age=18 name=arlettebrook 使用同一个logrus.Entry调不同级别的日志方法，即可实现携带相同的字段（默认字段）。\n注意：默认字段也支持链式调用。\n# 重定向输出 默认情况下，日志输出到io.Stderr。可以调用logrus.SetOutput传入一个io.Writer参数。后续调用相关方法日志将写到io.Writer中。 现在，我们就能像介绍log时一样，可以搞点事情了。传入一个io.MultiWriter， 同时将日志写到bytes.Buffer、标准输出和文件中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package main import ( \u0026#34;bytes\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;github.com/sirupsen/logrus\u0026#34; ) func main() { writer1 := bytes.NewBuffer(nil) writer2 := os.Stdout writer3, err := os.OpenFile(\u0026#34;./log.txt\u0026#34;, os.O_WRONLY|os.O_CREATE, 0755) defer func(writer3 *os.File) { err := writer3.Close() if err != nil { log.Fatal(err) } }(writer3) if err != nil { log.Fatalf(\u0026#34;create file log.txt failed: %v\u0026#34;, err) } logrus.SetOutput(io.MultiWriter(writer1, writer2, writer3)) logrus.Info(\u0026#34;info msg\u0026#34;) fmt.Println(\u0026#34;Buffer:\u0026#34;, writer1.String()) } 运行，会在文件log.txt和控制台输出日志。\n# 处理不同环境 Logrus 并没有像 zap 那样提供现成的 API 来支持在不同的环境下使用（Production 和 Development），如果你想在生产和测试环境使用不同的格式输出日志，则需要通过代码判断在不同环境设置不同的 Formatter 来实现。示例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 package main import ( \u0026#34;os\u0026#34; nested \u0026#34;github.com/antonfisher/nested-logrus-formatter\u0026#34; \u0026#34;github.com/sirupsen/logrus\u0026#34; ) func init() { // 假设环境变量APP_ENV已经被设置 env := os.Getenv(\u0026#34;APP_ENV\u0026#34;) // 根据环境设置日志级别 switch env { case \u0026#34;development\u0026#34;: // 在开发环境中显示所有日志 logrus.SetLevel(logrus.DebugLevel) logrus.SetFormatter(\u0026amp;nested.Formatter{}) case \u0026#34;testing\u0026#34;: // 在测试环境中只显示警告和错误日志 logrus.SetLevel(logrus.WarnLevel) case \u0026#34;production\u0026#34;: // 在生产环境中只显示错误日志 logrus.SetLevel(logrus.ErrorLevel) logrus.SetFormatter(\u0026amp;logrus.JSONFormatter{}) default: // 默认情况下，显示所有日志 logrus.SetLevel(logrus.DebugLevel) logrus.SetFormatter(\u0026amp;nested.Formatter{}) } // 你还可以设置日志格式、输出位置等 // ... } func main() { logrus.Error(\u0026#34;error log\u0026#34;) logrus.Warn(\u0026#34;warn log\u0026#34;) logrus.Info(\u0026#34;info log\u0026#34;) logrus.Debug(\u0026#34;debug log\u0026#34;) } 运行输出：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 $ go run main.go May 11 15:31:46.122 [ERRO] error log May 11 15:31:46.168 [WARN] warn log May 11 15:31:46.168 [INFO] info log May 11 15:31:46.169 [DEBU] debug log $ app_env=production go run main.go {\u0026#34;level\u0026#34;:\u0026#34;error\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;error log\u0026#34;,\u0026#34;time\u0026#34;:\u0026#34;2024-05-11T15:31:53+08:00\u0026#34;} $ app_env=development go run main.go May 11 15:32:05.563 [ERRO] error log May 11 15:32:05.609 [WARN] warn log May 11 15:32:05.609 [INFO] info log May 11 15:32:05.609 [DEBU] debug log # 测试 如果你的单元测试程序中需要测试日志内容，Logrus 提供了 test.NewNullLogger 日志记录器，它只会记录日志，不输出任何内容。使用示例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package main import ( \u0026#34;testing\u0026#34; \u0026#34;github.com/sirupsen/logrus\u0026#34; \u0026#34;github.com/sirupsen/logrus/hooks/test\u0026#34; \u0026#34;github.com/stretchr/testify/assert\u0026#34; ) func TestLogrus(t *testing.T) { logger, hook := test.NewNullLogger() logger.Error(\u0026#34;Hello error\u0026#34;) assert.Equal(t, 1, len(hook.Entries)) assert.Equal(t, logrus.ErrorLevel, hook.LastEntry().Level) assert.Equal(t, \u0026#34;Hello error\u0026#34;, hook.LastEntry().Message) hook.Reset() assert.Nil(t, hook.LastEntry()) } 第二个返回值是一个结构体:\n1 2 3 4 5 6 7 type Hook struct { // Entries is an array of all entries that have been received by this hook. // For safe access, use the AllEntries() method, rather than reading this // value directly. Entries []logrus.Entry // 条目切片 mu sync.RWMutex } 方法LastEntry()返回Entries的最后一条日志条目对象。\n运行输出：\n1 2 3 4 5 $ go test -run TestLogrus -v === RUN TestLogrus --- PASS: TestLogrus (0.07s) PASS ok github.com/arlettebrook/learn 0.643s # 自定义 Logger 除了通过 logrus.Info(\u0026quot;Info msg\u0026quot;) 这种开箱即用的方式使用 Logrus 默认的 Logger，我们还可以自定义 Logger。\n**实际上，考虑到易用性，库一般会使用默认值创建一个对象，包最外层的方法一般都是操作这个默认对象。**用到的设计模式是单例模式。\n我们之前好几篇文章都提到过这点：\nflag标准库中的CommandLine对象； log标准库中的std对象。 这个技巧应用在很多库的开发中，logrus也是如此：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 // github.com/sirupsen/logrus/exported.go var ( // std is the name of the standard logger in stdlib `log` std = New() ) func New() *Logger { return \u0026amp;Logger{ Out: os.Stderr, Formatter: new(TextFormatter), Hooks: make(LevelHooks), Level: InfoLevel, ExitFunc: os.Exit, ReportCaller: false, } } func StandardLogger() *Logger { return std } // SetOutput sets the standard logger output. func SetOutput(out io.Writer) { std.SetOutput(out) } // SetFormatter sets the standard logger formatter. func SetFormatter(formatter Formatter) { std.SetFormatter(formatter) } // SetReportCaller sets whether the standard logger will include the calling // method as a field. func SetReportCaller(include bool) { std.SetReportCaller(include) } // SetLevel sets the standard logger level. func SetLevel(level Level) { std.SetLevel(level) } 首先，使用默认配置定义一个Logger对象std，SetOutput/SetFormatter/SetReportCaller/SetLevel这些方法都是调用std对象的对应方法！\n我们当然也可以创建自己的Logger对象，使用方式与直接调用logrus的方法类似：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import \u0026#34;github.com/sirupsen/logrus\u0026#34; func main() { log := logrus.New() log.Info(\u0026#34;info msg\u0026#34;) // 用自定义logger log.SetLevel(logrus.DebugLevel) log.SetFormatter(\u0026amp;logrus.JSONFormatter{}) log.Debug(\u0026#34;debug msg\u0026#34;) } New()函数创建的logger与默认的logger相同。运行输出：\n1 2 3 $ go run main.go time=\u0026#34;2024-05-09T22:55:30+08:00\u0026#34; level=info msg=\u0026#34;info msg\u0026#34; {\u0026#34;level\u0026#34;:\u0026#34;debug\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;debug msg\u0026#34;,\u0026#34;time\u0026#34;:\u0026#34;2024-05-09T22:55:30+08:00\u0026#34;} 通过创建的logger对象可以直接赋值修改Level、Out、Formatter等，不用调对应的Set方法。\n1 2 3 4 5 6 7 8 9 10 func New() *Logger { return \u0026amp;Logger{ Out: os.Stderr, Formatter: new(TextFormatter), Hooks: make(LevelHooks), Level: InfoLevel, ExitFunc: os.Exit, ReportCaller: false, } } 示例修改如下：\n1 2 3 log.Out=os.Stdout log.Level=logrus.DebugLevel log.Formatter=\u0026amp;logrus.JSONFormatter{} 我们还可以通过FieldMap属性修改默认字段的键名\n1 2 type FieldMap map[fieldKey]string type fieldKey string 支持重命名的默认字段fieldKey如下：\n1 2 3 4 5 6 7 8 9 const ( defaultTimestampFormat = time.RFC3339 FieldKeyMsg = \u0026#34;msg\u0026#34; FieldKeyLevel = \u0026#34;level\u0026#34; FieldKeyTime = \u0026#34;time\u0026#34; FieldKeyLogrusError = \u0026#34;logrus_error\u0026#34; FieldKeyFunc = \u0026#34;func\u0026#34; FieldKeyFile = \u0026#34;file\u0026#34; ) 实例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package main import ( \u0026#34;github.com/sirupsen/logrus\u0026#34; ) func main() { log := logrus.New() log.Formatter = \u0026amp;logrus.TextFormatter{ DisableColors: true, FieldMap: logrus.FieldMap{ logrus.FieldKeyMsg: \u0026#34;message\u0026#34;, // 将msg改成message }, } log.Info(\u0026#34;info msg\u0026#34;) log.Level = logrus.DebugLevel log.Formatter = \u0026amp;logrus.JSONFormatter{ // 会覆盖TextFormatter FieldMap: logrus.FieldMap{ logrus.FieldKeyTime: \u0026#34;TIME\u0026#34;,// 将 time改成TIME }, } log.Debug(\u0026#34;debug msg\u0026#34;) } 运行输出：\n1 2 3 $ go run main.go time=\u0026#34;2024-05-09T23:23:53+08:00\u0026#34; level=info message=\u0026#34;info msg\u0026#34; {\u0026#34;TIME\u0026#34;:\u0026#34;2024-05-09T23:23:53+08:00\u0026#34;,\u0026#34;level\u0026#34;:\u0026#34;debug\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;debug msg\u0026#34;} # 修改日志格式 调用logrus.SetFormatter(formatter Formatter)，即可修改日志格式。\nlogrus支持两种日志格式，文本和 JSON，默认为文本格式。可以通过logrus.SetFormatter设置日志格式：\nLogrus 提供了 JSONFormatter 和 TextFormatter 来分别实现 JSON 和 Text 格式的日志输出，它们的指针类型都实现了 Formatter 接口。除此之外，这里还有一个第三方实现的 Formatter 列表可供选择，如果这些依然无法满足你的需求，则可以自己实现 Formatter 接口对象定制日志格式。\n使用如下：\n1 2 3 4 5 6 7 8 9 10 11 package main import \u0026#34;github.com/sirupsen/logrus\u0026#34; func main() { logrus.Info(\u0026#34;default formatter:TextFormatter\u0026#34;) //text logrus.SetFormatter(\u0026amp;logrus.JSONFormatter{}) logrus.Info(\u0026#34;JSONFormatter\u0026#34;) //json logrus.SetFormatter(\u0026amp;logrus.TextFormatter{}) logrus.Info(\u0026#34;default formatter:TextFormatter\u0026#34;) //text } logrus默认的Formatter是TextFormatter。在非标准TTY中运行输出结果（不带颜色输出）如下：\n1 2 3 4 $ go run main.go time=\u0026#34;2024-05-09T22:06:29+08:00\u0026#34; level=info msg=\u0026#34;default formatter:TextFormatter\u0026#34; {\u0026#34;level\u0026#34;:\u0026#34;info\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;JSONFormatter\u0026#34;,\u0026#34;time\u0026#34;:\u0026#34;2024-05-09T22:06:29+08:00\u0026#34;} time=\u0026#34;2024-05-09T22:06:29+08:00\u0026#34; level=info msg=\u0026#34;default formatter:TextFormatter\u0026#34; # 使用第三方格式 除了内置的TextFormatter和JSONFormatter，还有不少第三方格式支持。我们这里介绍一个nested-logrus-formatter。\n先安装：\n1 $ go get -u github.com/antonfisher/nested-logrus-formatter 后使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; nested \u0026#34;github.com/antonfisher/nested-logrus-formatter\u0026#34; \u0026#34;github.com/sirupsen/logrus\u0026#34; ) func main() { // 非标准TTY，强制输出颜色 logrus.SetFormatter(\u0026amp;logrus.TextFormatter{ ForceColors: true, FullTimestamp: true, TimestampFormat: time.DateTime, }) logrus.Info(\u0026#34;info msg\u0026#34;) logrus.WithFields(logrus.Fields{ \u0026#34;username\u0026#34;: \u0026#34;arlettebrook\u0026#34;, \u0026#34;age\u0026#34;: 18, }).Warn(\u0026#34;user info\u0026#34;) fmt.Println(\u0026#34;----------------\u0026#34;) logrus.SetFormatter(\u0026amp;nested.Formatter{ HideKeys: true, TimestampFormat: time.DateTime, }) logrus.Info(\u0026#34;info msg\u0026#34;) logrus.WithFields(logrus.Fields{ \u0026#34;username\u0026#34;: \u0026#34;arlettebrook\u0026#34;, \u0026#34;age\u0026#34;: 18, }).Warn(\u0026#34;user info\u0026#34;) } 程序运行输出：\n1 2 3 4 5 6 7 $ go run main.go INFO[2024-05-09 22:33:40] info msg WARN[2024-05-09 22:33:41] user info age=18 username=arlettebro ok ---------------- 2024-05-09 22:33:41 [INFO] info msg 2024-05-09 22:33:41 [WARN] [18] [arlettebrook] user info 没有截图，参考的是官方对比图片：\nnested格式提供了多个字段用来定制行为：\n1 2 3 4 5 6 7 8 9 10 // github.com/antonfisher/nested-logrus-formatter/formatter.go type Formatter struct { FieldsOrder []string TimestampFormat string HideKeys bool NoColors bool NoFieldsColors bool ShowFullLevel bool TrimMessages bool } 默认，logrus输出日志中字段是key=value这样的形式。使用nested格式，我们可以通过设置HideKeys为true隐藏键，只输出值；\n如果不隐藏键，程序输出：\n1 2024-05-09 22:40:09 [WARN] [age:18] [username:arlettebrook] user info 默认，logrus是按键的字母序输出字段，可以设置FieldsOrder定义输出字段顺序；string类型的切片指定顺序。\n通过设置TimestampFormat设置日期格式。如time.RFC3339、time.DateTime。\n通过实现接口logrus.Formatter可以实现自己的格式。\n1 2 3 4 // github.com/sirupsen/logrus/formatter.go type Formatter interface { Format(*Entry) ([]byte, error) } # Hooks Hooks本质是一些函数或方法，用于不修改原代码，扩展程序。\nLogrus 最令人心动的两个功能，一个是结构化日志，另一个就是 Hooks 了。\nHooks 为 Logrus 提供了极大的灵活性，通过 Hooks 可以实现各种扩展功能。比如可以通过 Hooks 实现：Error 以上级别日志发送邮件通知、重要日志告警、日志切割、程序优雅退出等，非常实用。\nLogrus 提供了 Hook 接口，只要我们实现了这个接口，并将其注册到 Logrus 中，就可以使用 Hooks 的强大能力了。Hook 接口定义如下：\n1 2 3 4 type Hook interface { Levels() []Level Fire(*Entry) error } Levels 方法返回一个日志级别切片，Logrus 记录的日志级别如果存在于切片中，则会触发 Hooks，即调用 Fire 方法。\n为logrus设置钩子（Hooks），符合[]Level的日志输出前都会执行钩子的特定方法（Fire 方法）。所以，我们可以实现添加输出字段、根据级别将日志输出到不同的目的地。\n并且hook函数会在输出日志之前执行。\nEntry是当前日志条目（当前输出日志对象）。是结构体类型，定义如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 type Entry struct { Logger *Logger // Contains all the fields set by the user. Data Fields // Time at which the log entry was created Time time.Time // Level the log entry was logged at: Trace, Debug, Info, Warn, Error, Fatal or Panic // This field will be set on entry firing and the value will be equal to the one in Logger struct field. Level Level // Calling method, with package name Caller *runtime.Frame // Message passed to Trace, Debug, Info, Warn, Error, Fatal or Panic Message string // When formatter is called in entry.log(), a Buffer may be set to entry Buffer *bytes.Buffer // Contains the context set by the user. Useful for hook processing etc. Context context.Context // err may contain a field formatting error err string } 常用的属性是：\nData Fields是日志条目中所有的字段，Fields类型是type Fields map[string]interface{}。 Logger *Logger记录该日志条目的logger。 单条日志条目信息都保存在Entry结构体中。如，创建时间、日志级别、日志消息等。 logrus也内置了一个syslog的钩子，将日志输出到系统日志syslog中。它不适用用windows的系统日志。\nLogrus 内置 Hooks 列表： https://github.com/sirupsen/logrus/tree/master/hooks\n# 自定义Hook # 利用Hook添加字段 这里我们实现一个钩子，在输出的日志中增加一个app=awesome-web字段。\n示例代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package main import ( \u0026#34;github.com/sirupsen/logrus\u0026#34; ) type AppHook struct { AppName string } func (h *AppHook) Levels() []logrus.Level { return logrus.AllLevels } func (h *AppHook) Fire(entry *logrus.Entry) error { entry.Data[\u0026#34;app\u0026#34;] = h.AppName return nil } func main() { h := \u0026amp;AppHook{AppName: \u0026#34;awesome-web\u0026#34;} logrus.AddHook(h) logrus.Info(\u0026#34;info msg\u0026#34;) logrus.WithField(\u0026#34;username\u0026#34;, \u0026#34;arlettebrook\u0026#34;). Warn(\u0026#34;user info\u0026#34;) } 非标准TTY运行输出：\n1 2 3 4 $ go run main.go time=\u0026#34;2024-05-10T22:58:42+08:00\u0026#34; level=info msg=\u0026#34;info msg\u0026#34; app=awesome-web time=\u0026#34;2024-05-10T22:58:42+08:00\u0026#34; level=warning msg=\u0026#34;user info\u0026#34; app=awesome-web username=arlettebro ok 总结：添加钩子（hook），只需要创建一个结构体实现Hook接口，在Levels方法中设置触发hook函数的条件（日志级别），在Fire方法中定义hook函数行为。然后创建对象，利用AddHook(hook Hook)将hook注册到logger当中。\n# 利用Hook模拟邮件发送 代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/sirupsen/logrus\u0026#34; ) func init() { logrus.SetFormatter(\u0026amp;logrus.JSONFormatter{}) logrus.AddHook(\u0026amp;EmailHook{}) } type EmailHook struct { } func (e EmailHook) Levels() []logrus.Level { return logrus.AllLevels // 所有日志都发送到邮件 } func (e EmailHook) Fire(entry *logrus.Entry) error { // 添加一个邮箱字段标识 entry.Data[\u0026#34;app\u0026#34;] = \u0026#34;email\u0026#34; // 获取日志条目 msg, _ := entry.String() // 模拟发送邮件 fmt.Printf(\u0026#34;fakeSendEmail: %s\u0026#34;, msg) return nil } func main() { logrus.Info(\u0026#34;info msg\u0026#34;) logrus.WithField(\u0026#34;username\u0026#34;, \u0026#34;arlettebrook\u0026#34;). Warn(\u0026#34;user info\u0026#34;) } 运行输出：\n1 2 3 4 5 6 7 $ go run main.go fakeSendEmail: {\u0026#34;app\u0026#34;:\u0026#34;email\u0026#34;,\u0026#34;level\u0026#34;:\u0026#34;info\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;info msg\u0026#34;,\u0026#34;time\u0026#34;:\u0026#34;2024-05-10T23:22:13+08:00\u0026#34;} {\u0026#34;app\u0026#34;:\u0026#34;email\u0026#34;,\u0026#34;level\u0026#34;:\u0026#34;info\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;info msg\u0026#34;,\u0026#34;time\u0026#34;:\u0026#34;2024-05-10T23:22:13+08:00\u0026#34;} fakeSendEmail: {\u0026#34;app\u0026#34;:\u0026#34;email\u0026#34;,\u0026#34;level\u0026#34;:\u0026#34;warning\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;user info\u0026#34;,\u0026#34;time\u0026#34;:\u0026#34;2024-05-10T23:22:13+08:0 0\u0026#34;,\u0026#34;username\u0026#34;:\u0026#34;arlettebrook\u0026#34;} {\u0026#34;app\u0026#34;:\u0026#34;email\u0026#34;,\u0026#34;level\u0026#34;:\u0026#34;warning\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;user info\u0026#34;,\u0026#34;time\u0026#34;:\u0026#34;2024-05-10T23:22:13+08:00\u0026#34;,\u0026#34;username\u0026#34;:\u0026#34; arlettebrook\u0026#34;} 可以发现，在打印每条日志之前，都会执行Hook函数，也就是实现了发送邮件。\n# 第三方Hook logrus的第三方 Hook 有很多，我们可以使用一些现成的 Hook 。如：\nmgorus：将日志发送到 mongodb； logrus-redis-hook：将日志发送到 redis； logrus-amqp：将日志发送到 ActiveMQ。 lumberjackrus ：实现了日志切割和归档功能，并且能够将不同级别的日志输出到不同文件。lumberjackrus 是专门为 Logrus 而打造的文件日志 Hooks，其官方介绍为 local filesystem hook for Logrus。 更多过内容请参考官方提供的第三方开发的 Hooks 列表。\n# lumberjackrus lumberjackrus ：实现了日志切割和归档功能，并且能够将不同级别的日志输出到不同文件。lumberjackrus 是专门为 Logrus 而打造的文件日志 Hooks，其官方介绍为 local filesystem hook for Logrus。\n用于记录到本地文件系统的钩子（使用 logrotate 和可以将不同的日志级保存到一个文件）\nlumberjackrus是一个第三方包，使用要先安装：\n1 $ go get -u github.com/orandin/lumberjackrus 示例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 package main import ( \u0026#34;github.com/orandin/lumberjackrus\u0026#34; \u0026#34;github.com/sirupsen/logrus\u0026#34; ) func init() { logrus.SetFormatter(\u0026amp;logrus.TextFormatter{}) logrus.SetLevel(logrus.DebugLevel) hook, err := lumberjackrus.NewHook( \u0026amp;lumberjackrus.LogFile{ // 未指定级别的日志保存的文件，属性都是optional Filename: \u0026#34;./tmp/general.log\u0026#34;, // 路径+文件名，默认当前目录名字\u0026lt;processName\u0026gt;-lumberjack.log MaxSize: 3, // 文件最大占用，单位MB，默认100MB MaxBackups: 1, // 文件最大备份数，默认不限制 MaxAge: 1, // 备份文件保存的天数，默认永久 Compress: false, // 是否压缩，默认false LocalTime: false, // 文件启用本地时间，默认utc， }, logrus.InfoLevel, // 定义写入文件的日志级别 \u0026amp;logrus.JSONFormatter{}, // 日志格式Formatter \u0026amp;lumberjackrus.LogFileOpts{ // 根据日志级别指定保存位置 logrus.InfoLevel: \u0026amp;lumberjackrus.LogFile{ Filename: \u0026#34;./tmp/info/info.log\u0026#34;, MaxSize: 1, MaxBackups: 2, MaxAge: 1, Compress: true, LocalTime: true, }, logrus.ErrorLevel: \u0026amp;lumberjackrus.LogFile{ Filename: \u0026#34;./tmp/error/error.log\u0026#34;, }, }, ) if err != nil { panic(err) } logrus.AddHook(hook) } func main() { logrus.Debug(\u0026#34;Debug message\u0026#34;) // It is not written to a file (because debug level \u0026lt; minLevel) logrus.Info(\u0026#34;Info message\u0026#34;) // Written in ./tmp/info.log logrus.Warn(\u0026#34;Warn message\u0026#34;) // Written in ./tmp/general.log logrus.Error(\u0026#34;Error message\u0026#34;) // Written in ./tmp/error.log } 运行，在非标准TTY中输出：\n1 2 3 4 5 $ go run main.go time=\u0026#34;2024-05-11T10:49:22+08:00\u0026#34; level=debug msg=\u0026#34;Debug message\u0026#34; time=\u0026#34;2024-05-11T10:49:22+08:00\u0026#34; level=info msg=\u0026#34;Info message\u0026#34; time=\u0026#34;2024-05-11T10:49:22+08:00\u0026#34; level=warning msg=\u0026#34;Warn message\u0026#34; time=\u0026#34;2024-05-11T10:49:22+08:00\u0026#34; level=error msg=\u0026#34;Error message\u0026#34; 并且还会再当前目录下生成tmp/general.log, tmp/info, tmp/error,里面的格式为json。debug日志没有写入文件。info.log文件内容如下：\n1 {\u0026#34;level\u0026#34;:\u0026#34;info\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;Info message\u0026#34;,\u0026#34;time\u0026#34;:\u0026#34;2024-05-11T10:49:22+08:00\u0026#34;} 至此，我们使用lumberjackrus实现了日志轮询以及分级别保存。这个钩子，实现日志轮询是基于lumberjack库实现的。\n使用这个钩子，我们只需要利用NewHook(defaultLogger *LogFile, minLevel logrus.Level, formatter logrus.Formatter, opts *LogFileOpts) (*Hook, error)创建对象，将对象添加logger中即可使用。代码中有对参数的介绍。最后一个参数（本质是map类型）如果为nil或者为空map，那么日志将不会分级别保存，都会保存到defaultLogger指定的文件中。\n# logrus-redis-hook 下面演示利用hook将日志发送到redis，我们用到的包是logrus-redis-hook, 先安装logrus-redis-hook：\n1 $ go get -u github.com/rogierlommers/logrus-redis-hook 默认你已经安装好了redis并且启动了它，如果你想了解redis，可以参考我的另一篇文章《Redis Introduction》。\n然后编写程序：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 package main import ( \u0026#34;io\u0026#34; logredis \u0026#34;github.com/rogierlommers/logrus-redis-hook\u0026#34; \u0026#34;github.com/sirupsen/logrus\u0026#34; ) func init() { logrus.SetFormatter(\u0026amp;logrus.JSONFormatter{}) hookConfig := logredis.HookConfig{ Host: \u0026#34;192.168.245.130\u0026#34;, Password: \u0026#34;123456\u0026#34;, Key: \u0026#34;demo_log\u0026#34;, Format: \u0026#34;v0\u0026#34;, App: \u0026#34;awesome_demo\u0026#34;, Port: 6379, Hostname: \u0026#34;localhost\u0026#34;, // will be sent to field @source_host DB: 1, // optional TTL: 3600, } hook, err := logredis.NewHook(hookConfig) if err == nil { logrus.AddHook(hook) } else { logrus.Errorf(\u0026#34;logredis error: %q\u0026#34;, err) } } func main() { // when hook is injected successfully, logs will be sent to redis server logrus.Info(\u0026#34;just some info logging...\u0026#34;) // we also support log.WithFields() logrus.WithFields(logrus.Fields{ \u0026#34;animal\u0026#34;: \u0026#34;walrus\u0026#34;, \u0026#34;foo\u0026#34;: \u0026#34;bar\u0026#34;, \u0026#34;this\u0026#34;: \u0026#34;that\u0026#34;}). Info(\u0026#34;additional fields are being logged as well\u0026#34;) // If you want to disable writing to stdout, use setOutput logrus.SetOutput(io.Discard) logrus.Info(\u0026#34;This will only be sent to Redis\u0026#34;) } 注意：请连接你自己的redis。\n运行程序后，终端输出：\n1 2 3 4 $ go run main.go {\u0026#34;level\u0026#34;:\u0026#34;info\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;just some info logging...\u0026#34;,\u0026#34;time\u0026#34;:\u0026#34;2024-05-11T11:56:17+08:00\u0026#34;} {\u0026#34;animal\u0026#34;:\u0026#34;walrus\u0026#34;,\u0026#34;foo\u0026#34;:\u0026#34;bar\u0026#34;,\u0026#34;level\u0026#34;:\u0026#34;info\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;additional fields are being logged as well\u0026#34;,\u0026#34; this\u0026#34;:\u0026#34;that\u0026#34;,\u0026#34;time\u0026#34;:\u0026#34;2024-05-11T11:56:17+08:00\u0026#34;} 我们使用redis-cli查看：\n1 2 3 4 127.0.0.1:6379[1]\u0026gt; lrange demo_log 0 -1 1) \u0026#34;{\\\u0026#34;@fields\\\u0026#34;:{\\\u0026#34;application\\\u0026#34;:\\\u0026#34;awesome_demo\\\u0026#34;,\\\u0026#34;level\\\u0026#34;:\\\u0026#34;info\\\u0026#34;},\\\u0026#34;@message\\\u0026#34;:\\\u0026#34;just some info logging...\\\u0026#34;,\\\u0026#34;@source_host\\\u0026#34;:\\\u0026#34;localhost\\\u0026#34;,\\\u0026#34;@timestamp\\\u0026#34;:\\\u0026#34;2024-05-11T03:56:17.867867Z\\\u0026#34;}\u0026#34; 2) \u0026#34;{\\\u0026#34;@fields\\\u0026#34;:{\\\u0026#34;animal\\\u0026#34;:\\\u0026#34;walrus\\\u0026#34;,\\\u0026#34;application\\\u0026#34;:\\\u0026#34;awesome_demo\\\u0026#34;,\\\u0026#34;foo\\\u0026#34;:\\\u0026#34;bar\\\u0026#34;,\\\u0026#34;level\\\u0026#34;:\\\u0026#34;info\\\u0026#34;,\\\u0026#34;this\\\u0026#34;:\\\u0026#34;that\\\u0026#34;},\\\u0026#34;@message\\\u0026#34;:\\\u0026#34;additional fields are being logged as well\\\u0026#34;,\\\u0026#34;@source_host\\\u0026#34;:\\\u0026#34;localhost\\\u0026#34;,\\\u0026#34;@timestamp\\\u0026#34;:\\\u0026#34;2024-05-11T03:56:17.933777Z\\\u0026#34;}\u0026#34; 3) \u0026#34;{\\\u0026#34;@fields\\\u0026#34;:{\\\u0026#34;application\\\u0026#34;:\\\u0026#34;awesome_demo\\\u0026#34;,\\\u0026#34;level\\\u0026#34;:\\\u0026#34;info\\\u0026#34;},\\\u0026#34;@message\\\u0026#34;:\\\u0026#34;This will only be sent to Redis\\\u0026#34;,\\\u0026#34;@source_host\\\u0026#34;:\\\u0026#34;localhost\\\u0026#34;,\\\u0026#34;@timestamp\\\u0026#34;:\\\u0026#34;2024-05-11T03:56:17.9351074Z\\\u0026#34;}\u0026#34; 我们看到demo_log是一个list，每过来一条日志，就在list后新增一项。\n默认的logger是输出到stderr，但修改为discard，将不会输出到任何地方，但是钩子依然执行。因为钩子里面指定发送到的是redis，不受影响。\n# 总结 本文介绍了 Logrus 的基本特点，以及如何使用。\nLogrus 完全兼容 log 标准库，所以可以实现无缝替换。其 API 设计思路跟 log 标准库的风格也有很多相似之处，都提供了一个默认的 std 日志对象达到开箱即用的效果。Logrus 最实用的两个功能，一个是支持结构化日志，一个是支持 Hooks 机制，这极大的提升了可用性和灵活性，也使得 Logrus 成为最受欢迎的 Go 日志库。\n# 参考 logrus GitHub 仓库 Go 每日一库之 logrus Go 第三方 log 库之 logrus 使用 ","date":"2024-05-09T10:31:23+08:00","permalink":"https://arlettebrook.github.io/p/logrus-introduction/","title":"Logrus Introduction"},{"content":" Linux常用命令有很多，本文不会逐个介绍。以下命令是我在后期使用中遇到的，算是我对Linux常用命令的补充、回顾、总结。本篇文章阅读需要一定的Linux基础。更多常见命令可参考：600条Linux命令总结。\n持续更新中\u0026hellip;\n# ln ln命令在Linux系统中用于创建文件链接。\nLinux中文件链接的方式有两种： 符号链接（也称为软链接Symbolic Link）：包含了到原文件的路径信息，相当于一个指向原文件的快捷方式。 符号链接有自己的文件属性及权限等。 可对不存在的文件或目录创建符号链接。 符号链接可交叉文件系统，即可以在不同的文件系统之间创建。 删除符号链接并不影响被指向的文件，但若被指向的原文件被删除，则相关符号链接被称为死链接（dangling link）。若被指向的文件重新被创建，死链接可恢复为正常的符号链接。 符号链接文件的大小是其指向的文件的路径字符串的字节数。 硬链接：硬链接本质上是给一个文件取一个新的名称，原文件和硬链接在物理上仍然是同一个文件。它们共享相同的inode（索引节点）和数据块。 创建硬链接会在对应的目录中增加额外的记录项以引用文件。 原文件和硬链接文件对应于同一文件系统上的一个物理文件。 创建硬链接时原文件的连接数（i_nlink）会递增。即硬链接数递增。 删除文件时，rm命令会递减计数的链接数。文件要是存在，至少有一个链接数。当链接数为零时，该文件才会被真正删除。 硬链接不能跨域驱动器或分区，也不支持对目录创建硬链接。 总结来说，符号链接（软链接）和硬链接的主要区别在于： 符号链接是一个独立的文件，它包含了到原文件的路径信息（快捷方式）；而硬链接则与原文件共享相同的inode和数据块（文件别名）。 符号链接可以跨文件系统，并且可以对不存在的文件或目录创建；而硬链接则不能跨域驱动器或分区，也不能对目录创建。 删除符号链接不影响原文件，但删除原文件会使符号链接成为死链接；而删除硬链接文件时，只有当所有硬链接都被删除且原文件的链接数为零时，文件才会被真正删除。即硬链接数为0，文件才真正被删除。 这个命令允许你在不同的位置为同一个文件或目录建立同步的链接，从而避免了在多个位置重复存储相同的文件内容，节省了磁盘空间。\nln命令的基本语法如下：\n1 ln [选项] \u0026lt;源文件或目录\u0026gt; \u0026lt;链接文件或目录\u0026gt; 常用选项包括： -s：创建符号链接（软链接）。这会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，而是保存了原始文件的路径。（创建快捷方式） 不使用-s选项时创建硬链接。 -f：强制执行，如果链接文件已存在则覆盖。 -v：显示详细的输出信息。 --help：查看帮助文档。 理解记忆：ln可以理解为link的缩写，s可以理解为soft软的意思。 注意：源文件一般用绝对路径，相对会出现死链接情况。 简单介绍一些ls -lh输出\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 $ ls -lh total 20K -rw-r--r--. 1 root root 19K May 8 22:49 abc.txt drwxr-xr-x. 3 root root 18 May 8 23:15 demo # l显示详细信息，h文件大小用人类可读懂的方式显示。 -rw- r-- r-- -开头表示文件，d表示目录，l表示链接，三位为一组用rwx drwx r-x r-x 当前用户权限 用户所属组权限\t其他用户权限 数字1表示硬链接数，理解为别名，别名为0，文件才会被删除。 有多少种方式可以访问该文件或目录 文件一般为1：绝对路径 目录只有一层一般为2：绝对和cd . 2层为3：绝对、cd . 、cd .. root ：拥有者 root ：所在组，没指定默认同名。 5月 8 22:49 文件最后修改日期时间 最后：文件或目录名称 有箭头表示软连接，没有硬链接。 演示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 localhost test $ ls -lh total 20K -rw-r--r--. 1 root root 19K May 8 22:49 abc.txt drwxr-xr-x. 3 root root 18 May 8 23:46 demo localhost test $ ln -sv ~/test/abc.txt ./demo/soft ‘./demo/soft’ -\u0026gt; ‘/root/test/abc.txt’ localhost test $ ln -v ~/test/abc.txt ./demo/hard ‘./demo/hard’ =\u0026gt; ‘/root/test/abc.txt’ localhost test $ ls -lh total 20K -rw-r--r--. 2 root root 19K May 8 22:49 abc.txt drwxr-xr-x. 3 root root 42 May 8 23:46 demo localhost test $ cd demo localhost demo $ ls -lh total 20K -rw-r--r--. 2 root root 19K May 8 22:49 hard lrwxrwxrwx. 1 root root 18 May 8 23:46 soft -\u0026gt; /root/test/abc.txt drwxr-xr-x. 2 root root 6 May 8 23:15 test localhost demo $ 注意：测试环境是在Linux中，ln命令并不适用于windows环境。创建的文件链接无效。\n# curl curl命令是一个利用URL规则在命令行下工作的文件传输工具，它支持文件的上传和下载，因此被视为综合传输工具，但传统上习惯称其为下载工具。curl支持包括HTTP、HTTPS、FTP等众多协议，并具备多种特性，如POST、cookies、认证、从指定偏移处下载部分文件、用户代理字符串、限速、文件大小、进度条等。这些特性使得curl在处理网页处理流程和数据检索自动化方面非常有用。\n总结：用于发送网络请求，可以下载和上传文件。而wget只能用于下载文件，但wget下载文件的功能比curl强大。\n安装：\nlinux系统：根据你的Linux发行版，使用相应的包管理器来安装curl。 对于Debian/Ubuntu系统，使用apt-get命令安装：sudo apt install curl 对于CentOS/Fedora系统，使用yum命令安装：sudo yum install curl 对于Arch Linux系统，使用pacman命令安装：sudo pacman -S curl windows系统： 官网下载对应版本，添加一个CURL_HOME环境变量名，指向的是curl.exe文件所在路径。并将其添加到path环境变量中。 或者安装msys2利用pacman包管理器安装。 或者安装Mingw自带curl，Mingw也可以用msys2来安装。 MacOS系统自带。 基本使用：\ncurl命令的基本语法格式为：curl [选项] URL。其中，URL是要请求的目标地址，而选项则用于指定各种参数和功能。\n-X 或 --request：用于指定HTTP请求方法，如GET、POST、PUT、DELETE等。\n默认发送get请求。 1 curl -X POST http://example.com/ -H 或 --header: 添加自定义的 HTTP 头信息。\n1 curl -H \u0026#34;Content-Type: application/json\u0026#34; http://example.com/ -d 或 --data: 发送 POST 请求时，将数据作为请求体发送。\n1 curl -d \u0026#34;param1=value1\u0026amp;param2=value2\u0026#34; http://example.com/ 对于 JSON 数据：\n1 curl -d \u0026#39;{\u0026#34;key1\u0026#34;:\u0026#34;value1\u0026#34;, \u0026#34;key2\u0026#34;:\u0026#34;value2\u0026#34;}\u0026#39; -H \u0026#34;Content-Type: application/json\u0026#34; http://example.com/ -F 或 --form: 用于发送 multipart/form-data 格式的数据，通常用于文件上传。\n参数\u0026quot;文件名=@path\u0026quot;,还可以指定类型\u0026quot;文件名=@path;type=MIME\u0026quot; 1 curl -F \u0026#34;file=@filename.txt\u0026#34; http://example.com/upload -o 或 --output: 将响应输出到文件，而不是显示在终端上。默认当前目录\n1 curl -o output.html http://example.com/ -O: 将响应保存到本地文件，文件名与远程文件的文件名相同。在当前目录\n1 curl -O http://example.com/file.txt -s 或 --silent: 静默模式，不显示进度或错误消息。常用S组合使用，显示错误消息。\n-v 或 --verbose: 详细模式，显示详细的通信过程，包括请求头和响应头。\n-i: 显示响应头信息以及返回的内容 body。\n-I: 只显示响应头信息。\n-u 用户名:密码: 指定用户名和密码进行身份验证。\n1 curl -u username:password http://example.com/ -L: 跟随重定向。当 HTTP 响应是一个重定向时，curl 会自动获取重定向后的内容。\n-k 或 --insecure: 允许连接到不安全的 SSL 站点，即忽略 SSL 证书验证。\n常用组合：curl -fsSL，默认get请求。\nf不显示客户端错误。 s不显示进度、错误消息。配合S显示错误消息 L接受重定向。 # wget wget 是一个在 Unix 和 Linux 系统上常用的命令行工具，用于从网络上下载文件。\n优点：\n支持断点续传：如果下载过程中连接中断，可以在之后从断点处继续下载。 支持递归下载：可以下载网页上的所有链接文件，并重建目录结构。 强大的重试机制：在下载过程中如果网络出现问题，wget 会自动重试，直到下载完成。 后台执行：支持在后台运行下载任务，用户无需保持登录状态。 curl没有以上优点，但它支持更多的协议。wget只支持HTTP、HTTPS和FTP协议。curl使用更广泛。\n安装：\nlinux系统：根据你的Linux发行版，使用相应的包管理器来安装wget。\n对于Debian/Ubuntu系统，使用apt-get命令安装：sudo apt install wget\n对于CentOS/Fedora系统，使用yum命令安装：sudo yum install wget\n对于Arch Linux系统，使用pacman命令安装：sudo pacman -S wget\nwindows系统：\n官网GNU Wget下载安装或其他可靠的软件下载，然后路径添加到环境变量path中。 或者安装msys2利用pacman包管理器安装。 macos系统：\n对于macOS，使用Homebrew包管理器来安装wget。\n1 brew install wget 基本使用：\n-b, \u0026ndash;background：在后台执行下载任务。\n-c, \u0026ndash;continue：继续下载之前未完成的文件。\n-r, \u0026ndash;recursive：递归下载，下载指定 URL 中的所有链接。可以下载整个目录及其子目录。\n1 wget -r http://www.example.com/ 注意：在使用递归下载时，建议加上 -np 和 -nH 选项，以避免下载过多的不必要文件和创建复杂的目录结构。\n-np, \u0026ndash;no-parent：不递归下载上级目录。\n-nH, \u0026ndash;no-host-directories：不创建主机目录，将文件保存在当前目录。\n-P DIRECTORY, \u0026ndash;directory-prefix=DIRECTORY：将下载的文件保存到指定的目录。\n1 wget -P /tmp http://www.example.com/file.zip -O FILE, \u0026ndash;output-document=FILE：将下载的文件保存为指定的文件名。如果存在会覆盖。-N（时间戳检查），如果旧会覆盖，反之不会。\n1 wget -O new_file.zip http://www.example.com/file.zip -nc, \u0026ndash;no-clobber：如果文件已经存在，不覆盖原有文件。\n-nv, \u0026ndash;no-verbose：下载时只显示更新和出错信息，不显示详细的执行过程。\n-v, \u0026ndash;verbose：详细模式，增加输出信息。\n-q, \u0026ndash;quiet：静默模式，减少输出信息。\n\u0026ndash;no-check-certificate：下载 HTTPS 网站资源时，跳过证书检测过程。\n-t NUM 或 \u0026ndash;tries=NUM：指定最大尝试次数。如果下载失败，wget 会尝试重新下载指定的次数。\n-U AGENT 或 \u0026ndash;user-agent=AGENT：指定 User-Agent 字符串。这可以用来伪装为不同的浏览器或客户端。\n-N 或 \u0026ndash;timestamping：如果本地文件存在且时间戳较新，则不重新下载文件。\n-T SEC 或 \u0026ndash;timeout=SEC：指定超时时间（以秒为单位）。\n-A TYPES 或 \u0026ndash;accept=TYPES：指定下载文件的类型。例如，-A jpg,png,gif 表示只下载 jpg、png 和 gif 文件。\n-d 或 \u0026ndash;debug：打印调试输出。这会在标准错误上输出大量信息，通常用于诊断问题。\n常用组合：\nwget -O-:O表示指定文件名，后面-表示没有指定文件名，内容将输出到TTY。\n通常配合bash -c \u0026quot;$(wget -O- url)\u0026quot;运行脚本。url为脚本地址。\n其中$()表示在当前TTY中运行子命令，下载脚本。\n[bash -c](#bash -c)表示将下载的字符串做为命令执行。\n# bash -c bash -c 命令用于在 Bash shell 中执行一个字符串作为命令。\n基本语法：\n1 bash -c \u0026#39;command_string\u0026#39; [arg0 [arg1 ...]] command_string 是你想要执行的命令字符串。 arg0、arg1 等是可选的，它们会被用作 $0、$1、$2 等 shell 变量在 command_string 内部。 注意这里的$0并不是脚本名或终端名，而是第一个参数。 字符串可以用\u0026quot;\u0026quot;/''，区别在于双引号会转义特殊字符，单引号不会。执行脚本时建议双引号。 示例：\n1 2 3 4 5 6 7 $ bash -c \u0026#39;echo Hello, World!\u0026#39; Hello, World! $ bash -c \u0026#39;echo $0 $1\u0026#39; bash test bash test # bash -c \u0026#34;$(wget -O- https://gist.githubusercontent.com/lss233/2fdd75be3f0724739368d0dcd9d1367d/raw/62a790da4a391af096074b3355c2c2b7ecab3c28/chatgpt-mirai-installer-gocqhttp.sh)\u0026#34; chatgpt-qq-bot安装脚本 ","date":"2024-05-08T19:24:26+08:00","permalink":"https://arlettebrook.github.io/p/linux-common-commands/","title":"Linux Common Commands"},{"content":" Viper 可以监听文件修改进而自动重新加载。 其内部使用的就是fsnotify这个库，它是跨平台的。fs是filesystem的缩写，翻译过来就是文件系统通知。能够监听文件的修改，进而发送通知。今天我们就来介绍一下fsnotify。\n# 快速使用 先安装：\n1 $ go get -u github.com/fsnotify/fsnotify 后使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 package main import ( \u0026#34;log\u0026#34; \u0026#34;github.com/fsnotify/fsnotify\u0026#34; ) func main() { // Create new watcher. watcher, err := fsnotify.NewWatcher() if err != nil { log.Fatal(err) } defer func(watcher *fsnotify.Watcher) { err := watcher.Close() if err != nil { log.Fatal(err) } }(watcher) done := make(chan bool) // Start listening for events. go func() { defer close(done) for { select { case event, ok := \u0026lt;-watcher.Events: if !ok { return } log.Printf(\u0026#34;%s %s\\n\u0026#34;, event.Name, event.Op) /*if event.Has(fsnotify.Write) { log.Println(\u0026#34;modified file:\u0026#34;, event.Name) }*/ case err, ok := \u0026lt;-watcher.Errors: if !ok { return } log.Println(\u0026#34;error:\u0026#34;, err) } } }() // Add a path. err = watcher.Add(\u0026#34;.\u0026#34;) if err != nil { log.Fatal(err) } \u0026lt;-done } fsnotify的使用比较简单：\n先调用NewWatcher创建一个监听器； 然后调用监听器的Add增加监听的文件或目录； 如果目录或文件有事件产生，监听器中的通道Events可以取出事件。如果出现错误，监听器中的通道Errors可以取出错误信息。 上面示例中，我们在另一个 goroutine 中循环读取发生的事件及错误，然后输出它们。\n编译、运行程序。在当前目录创建一个新建文本文档.txt，然后重命名为abc.txt文件，输入内容some test text，然后删除它。观察控制台输出：\n1 2 3 4 5 6 $ go run main.go 2024/05/08 16:29:52 新建文本文档.txt CREATE 2024/05/08 16:30:03 新建文本文档.txt RENAME 2024/05/08 16:30:03 abc.txt CREATE 2024/05/08 16:30:15 abc.txt WRITE 2024/05/08 16:30:26 abc.txt REMOVE 其实，重命名时会产生两个事件，一个是原文件的RENAME事件，一个是新文件的CREATE事件。\n注意：\nfsnotify使用了操作系统接口，监听器中保存了系统资源的句柄，所以使用后需要关闭。 修改文件操作建议不要在IDE中操作，如GlLand。IDE的缓存和自动保存会响应输出结果。建议直接在系统文件管理器中操作，才会出现上面结果。 # 事件 上面示例中的事件是fsnotify.Event类型：\n1 2 3 4 5 // fsnotify/fsnotify.go type Event struct { Name string Op Op } 事件只有两个字段，Name表示发生变化的文件或目录名，Op表示具体的变化。Op有 5 种取值：\n1 2 3 4 5 6 7 8 9 10 // fsnotify/fsnotify.go type Op uint32 const ( Create Op = 1 \u0026lt;\u0026lt; iota Write Remove Rename Chmod ) 在快速使用中，我们已经演示了前 4 种事件。Chmod事件在文件或目录的属性发生变化时触发，在 Linux 系统中可以通过chmod命令改变文件或目录属性。\n事件中的Op是按照左移位运算来存储的，可以存储多个，可以通过\u0026amp;操作判断对应事件是不是发生了。\n1 2 3 if event.Op \u0026amp; fsnotify.Write != 0 { fmt.Println(\u0026#34;Op has Write\u0026#34;) } 补充：\n​\t与运算\u0026amp;：同为1为1。\n​\t左移运算\u0026laquo;：向做做移动指定位，低位用0补齐\n​\t或运算：有1就为1。用在组合Op——\u0026gt;|\n​\t事件中的Op是通过左移运算之后，结果为1,2,4,6,8十进制来存储的，它们的二进制位都只有一个1，当进行与运算时，就就能判断是否包含指定Op。\n判断事件中是否存在某个Op，封装到了事件对象的Has方法下：\n1 2 3 4 // fsnotify/fsnotify.go func (e Event) Has(op Op) bool { return e.Op.Has(op) } func (o Op) Has(h Op) bool { return o\u0026amp;h != 0 } // event.Op \u0026amp; fsnotify.Write != 0同理 当我们直接输出Op时，会自动调用String()方法，这个方法帮我们将对应的Op（uint类型）转换成定义的具体操作，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 func (o Op) String() string { var b strings.Builder if o.Has(Create) { b.WriteString(\u0026#34;|CREATE\u0026#34;) } if o.Has(Remove) { b.WriteString(\u0026#34;|REMOVE\u0026#34;) } if o.Has(Write) { b.WriteString(\u0026#34;|WRITE\u0026#34;) } if o.Has(Rename) { b.WriteString(\u0026#34;|RENAME\u0026#34;) } if o.Has(Chmod) { b.WriteString(\u0026#34;|CHMOD\u0026#34;) } if b.Len() == 0 { return \u0026#34;[no events]\u0026#34; } return b.String()[1:] } # 应用 fsnotify的应用非常广泛，在 godoc 上，我们可以看到哪些库导入了fsnotify。只需进入fsnotify godoc点击Imported by 9,171，就能查看。有兴趣的可以打开看看。\n在《Go配置管理之第三方库viper》文章中，我们介绍了调用viper.WatchConfig就可以监听配置修改，自动重新加载。下面我们就来看看WatchConfig是怎么实现的：\n首先演示viper自动更新配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main // mian.go import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/fsnotify/fsnotify\u0026#34; \u0026#34;github.com/spf13/viper\u0026#34; ) func main() { viper.SetConfigFile(\u0026#34;./cfg.yaml\u0026#34;) err := viper.ReadInConfig() if err != nil { log.Fatal(\u0026#34;ReadInConfig error:\u0026#34;, err) } viper.OnConfigChange(func(in fsnotify.Event) { log.Printf(\u0026#34;%s %s username：%s\\n\u0026#34;, in.Name, in.Op, viper.Get(\u0026#34;username\u0026#34;)) }) fmt.Println(\u0026#34;修改前的username：\u0026#34;, viper.Get(\u0026#34;username\u0026#34;)) viper.WatchConfig() time.Sleep(10 * time.Second) // 修改文件 fmt.Println(\u0026#34;修改后的username：\u0026#34;, viper.Get(\u0026#34;username\u0026#34;)) } 1 2 # ./cfg.yaml username: arlettebrook 运行之后，手动修改cfg.yamlusername（注意不要在IDE中修改，会影响输出效果）,在后面分别追加1/2/3,并别保存，输出：\n1 2 3 4 5 6 $ go run main.go 修改前的username： arlettebrook 2024/05/08 18:01:32 cfg.yaml WRITE username：arlettebrook1 2024/05/08 18:01:36 cfg.yaml WRITE username：arlettebrook12 2024/05/08 18:01:39 cfg.yaml WRITE username：arlettebrook123 修改后的username： arlettebrook123 具体实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 // viper/viper.go // WatchConfig starts watching a config file for changes. func WatchConfig() { v.WatchConfig() } // WatchConfig starts watching a config file for changes. func (v *Viper) WatchConfig() { initWG := sync.WaitGroup{} initWG.Add(1) go func() { watcher, err := fsnotify.NewWatcher() if err != nil { v.logger.Error(fmt.Sprintf(\u0026#34;failed to create watcher: %s\u0026#34;, err)) os.Exit(1) } defer watcher.Close() // we have to watch the entire directory to pick up renames/atomic saves in a cross-platform way filename, err := v.getConfigFile() if err != nil { v.logger.Error(fmt.Sprintf(\u0026#34;get config file: %s\u0026#34;, err)) initWG.Done() return } configFile := filepath.Clean(filename) configDir, _ := filepath.Split(configFile) realConfigFile, _ := filepath.EvalSymlinks(filename) eventsWG := sync.WaitGroup{} eventsWG.Add(1) go func() { for { select { case event, ok := \u0026lt;-watcher.Events: if !ok { // \u0026#39;Events\u0026#39; channel is closed eventsWG.Done() return } currentConfigFile, _ := filepath.EvalSymlinks(filename) // we only care about the config file with the following cases: // 1 - if the config file was modified or created // 2 - if the real path to the config file changed (eg: k8s ConfigMap replacement) if (filepath.Clean(event.Name) == configFile \u0026amp;\u0026amp; (event.Has(fsnotify.Write) || event.Has(fsnotify.Create))) || (currentConfigFile != \u0026#34;\u0026#34; \u0026amp;\u0026amp; currentConfigFile != realConfigFile) { realConfigFile = currentConfigFile err := v.ReadInConfig() if err != nil { v.logger.Error(fmt.Sprintf(\u0026#34;read config file: %s\u0026#34;, err)) } if v.onConfigChange != nil { v.onConfigChange(event) } } else if filepath.Clean(event.Name) == configFile \u0026amp;\u0026amp; event.Has(fsnotify.Remove) { eventsWG.Done() return } case err, ok := \u0026lt;-watcher.Errors: if ok { // \u0026#39;Errors\u0026#39; channel is not closed v.logger.Error(fmt.Sprintf(\u0026#34;watcher error: %s\u0026#34;, err)) } eventsWG.Done() return } } }() watcher.Add(configDir) initWG.Done() // done initializing the watch in this go routine, so the parent routine can move on... eventsWG.Wait() // now, wait for event loop to end in this go-routine... }() initWG.Wait() // make sure that the go routine above fully ended before returning } 其实流程是相似的：\n首先，调用NewWatcher创建一个监听器； 调用v.getConfigFile()获取配置文件路径，抽出文件名、目录，配置文件如果是一个符号链接，获得链接指向的路径； 调用watcher.Add(configDir)监听配置文件所在目录，另起一个 goroutine 处理事件。 WatchConfig不能阻塞主 goroutine，所以创建监听器也是新起 goroutine 进行的。代码中有两个sync.WaitGroup变量，initWG是为了保证监听器初始化， eventsWG是在事件通道关闭，或配置被删除了，或遇到错误时退出事件处理循环。\n然后就是核心事件循环：\n有事件发生时，判断变化的文件是否是在 viper 中设置的配置文件，发生的是否是创建或修改事件（只处理这两个事件）； 如果配置文件为符号链接，若符合链接的指向修改了，也需要重新加载配置； 如果需要重新加载配置，调用v.ReadInConfig()读取新的配置； 如果注册了事件回调，以发生的事件为参数执行回调。 # 总结 fsnotify的接口非常简单直接，所有系统相关的复杂性都被封装起来了。这也是我们平时设计模块和接口时可以参考的案例。\n# 参考 fsnotify API 设计 fsnotify GitHub 仓库 原文：Go 每日一库之 fsnotify ","date":"2024-05-08T15:49:50+08:00","permalink":"https://arlettebrook.github.io/p/fsnotify-introduction/","title":"Fsnotify Introduction"},{"content":" 开源协议(开源许可证)是每一个想要做开源软件的开发者都需要了解的，即使你不想做开源软件，那么当你使用他人开源的软件时也需要了解一些开源协议相关的内容，这样能够尽量避免一些不必要的麻烦。\n# 什么是开源 开源即开放源代码，是 OSI (Open Source Initiative) 这个组织提出来的。而被开源的软件，我们通常称为开源软件。你可能还见到过 Free Software 一词，它代表 自由软件 而非 免费软件，是开源软件的前身。\n开源软件 = 开放源代码 + 开源协议，一份没有添加开源协议的开源代码，并不是真正的开源软件，也就不能随意使用。\n注意：如果你在 GitHub 上创建了一个没有开源协议的公共代码仓库，其他用户仍然有权查看并为其创建分支，这是由 GitHub 的服务条款决定的。\n# 开源许可证 开源协议是指开源软件所携带的一份声明协议，这份协议也叫开源许可证。开源许可证声明了开源协议的内容，规定了原作者和使用者的权利以及义务。\n开源许可证是开源软件生态系统的基础，可以促进软件的协同开发。\n开源许可证是具有法律效力的，并且需要得到 OSI 这个组织的认证，目前 OSI 共计认证了 110+ 个开源许可证，这些被认证的开源许可证都必须遵循 OSD (Open Source Definition) 规则。\n虽然开源许可证非常多，但常用的就那么几种。常见的开源许可证主要有 Apache、MIT、BSD、GPL、LGPL、MPL、SSPL 等。\n开源许可证分成两大类：宽松型许可证（Permissive Licenses）、著作权型许可证（反版权许可证）（Copyleft Licenses）。\n​\t宽松型许可证（Permissive Licenses）是一种对软件的使用、修改、传播等方式采用最低限制的自由软件许可协议条款类型。这种类型的软件许可协议将不保证原作品的派生作品会继续保持与原作品完全相同的相关限制条件，从而为原作品的自由使用、修改和传播等提供更大的空间。\n​\t著作权型许可证（Copyleft Licenses）是经原作者许可在有限空间内的自由使用、修改和传播，且不得违背原作品的限制条款。如果一款软件使用 Copyleft 类型许可协议规定软件不得用于商业用途，且不得闭源，那么后续的衍生子软件也必须得遵循该条款。\n两者最大的差别在于：在软件被修改并再发行时， Copyleft License 仍然强制要求公开源代码（衍生软件需要开源），而 Permissive licence 不要求公开源代码（衍生软件可以变为专有软件）。\n其中，Apache、MIT、BSD 都是宽松型许可证，GPL 是典型的著作权型（copyleft ）许可证，LGPL、MPL 是弱著作权型（copyleft ）许可证。SSPL 则是近年来 MongoDB 创建的一个新许可证，存在较大争议，开放源代码促进会 OSI 甚至认为 SSPL 就不是开源许可协议。\n此外，还有一类是 Creative Commons（CC）知识共享协议。严格意义上说该协议并不能说是真正的开源协议，它们大多是被使用于设计类的工程上。CC 协议种类繁多，每一种都授权特定的权利。大多数的比较严格的 CC 协议会声明 “署名权，非商业用途，禁止衍生” 条款，这意味着你可以自由的分享这个作品，但你不能改变它和对其收费，而且必须声明作品的归属。这个许可协议非常的有用，它可以让你的作品传播出去，但又可以对作品的使用保留部分或完全的控制。最少限制的 CC 协议类型当属 “署名” 协议，这意味着只要人们能维护你的名誉，他们对你的作品怎么使用都行。\n下面就主要介绍下几种常见开源许可证。\n# 宽松型许可证（Permissive Licenses） 顾名思义，这类开源许可证比较宽松，限制更少。常见宽松开源许可证有：\nBSD (2-Clause) (Berkeley Software Distribution，伯克利软件发行版)\n源代码或二进制形式的重新分发，必须保留原始的许可证声明。\nBSD (3-Clause)\n在 BSD(2-Clause) 基础上增加了一条，禁止使用原始作者的名字为衍生软件进行促销。\nGo 语言就在使用 BSD (3-Clause) 开源许可证。\nMIT (Massachusetts Institute of Technology，麻省理工学院许可证)\n免费授予任何人该软件及相关文档的权限，包括但不限于使用、复制、修改、合并、发表、分发、再授权、出售软件的副本。分发软件时，必须保留原始的许可证声明。\nMIT 是最为宽松的开源许可证，所以这也使得它成为最流行的开源许可证，如目前在前端领域非常有名的 Vue.js 就在使用它。\nApache-2.0 (Apache 软件基金会发布的许可证)\nApache 许可证内容非常多，不过可以简单的总结几点：\n分发软件时，必须保留原始的许可证声明。\n所有修改过的文件，必须加以说明告知用户此文件已被更改。\n没有修改过的文件，不得修改许可证。\n云原生领域著名软件 Kubernetes 使用的正是 Apache-2.0 开源许可证。\n# 著作权型许可证（Copyleft Licenses） Copyleft 一词由 理查德·斯托曼 发明，表示 Copyright (版权) 的反义词。Copyleft 表示不经许可，用户无权复制，商业软件开发人员通过 Copyleft剥夺了用户的自由。Copyright 则表示不经许可，用户有权复制，Copyright使用版权来给予用户自由。\n因此Copyleft 类的许可证要比 Permissive 许可证限制更多。注意：不一定要经过原作者许可。常见 Copyleft 开源许可证有：\nGPL (GNU General Public License)\nGPL 有两个版本，GPL-2.0 和 GPL-3，同 BSD 一样，更高版本会带来更多的限制。GPL 协议内容也非常多，我们最需要关注的一点是：使用了 GPL 协议的开源软件，其衍生软件如果需要分发，就必须开源并且同样要使用此协议。\n由于这条规定的存在，有人甚至把 GPL 协议称为 “GPL 病毒”，因为它具有跟病毒一样的传染性。不过 GPL 仍然是非常流行的开源许可证，比如大名鼎鼎的 Linux 就采用了 GPL 协议。\nGPL 是流行开源许可证中最为严格的，所以对于使用开源软件所衍化的商业化软件就不够友好了。\nLGPL (GNU Library General Public License)\n算是 GPL 的一个变种，主要为类库使用而设计的开源协议。\n商用软件如果采用类库方式引用使用了 LGPL 协议的开源软件，则可以不用开源。\n如果是修改或衍生软件需要分发，则必须开源并且同样要使用此协议。这点与 GPL 协议一样。\nAGPL (GNU Affero General Public License)\n除了 AGPL 许可证，上面介绍的其他许可证的限制条件都是只有在分发时才需要遵守。而 SaaS 软件作为一项云服务则不构成分发，所以可以不遵守这些许可证条款。\n为了解决这些早期发布的许可证对 SaaS 软件无效的尴尬，GNU 又发布了 AGPL 许可证，它规定如果 SaaS 用到的代码是该许可证，那么其云服务的代码也必须开源。\n国产开源时序数据库 TDengine 为了阻止云厂商免费使用其开源版本，就采用了 AGPL 协议。\nMPL-2.0 (Mozilla Public License 2.0，Mozilla 基金会发布的许可证)\nMPL 融合了 BSD 开源许可证 和 GPL 开源许可证 的特性，力争在专有软件和开源软件开发者之间寻求平衡。是比 BSD 更严格，比 GPL 更宽松的开源许可证。\nMPL 允许新增的独立代码文件闭源，但在 MPL 授权下的代码文件必须保持 MPL 授权且开源。这使得 MPL 既不像 MIT 和 BSD 那样允许派生作品完全转化为闭源，也不像 GPL 那样要求所有的派生作品，包括新的组件在内，必须全部保持使用 GPL。\nMozilla 自家的 Firefox 浏览器就使用此开源许可证。\n以上介绍的开源许可证都是较为常见的许可证，另外还有两个不太常见但却值得一提的许可证。\n一个是 Unlicense 许可证，翻译过来叫「零约束许可证」，可以说是被 OSI 认证的最开放的许可证了。根据名字也能看出来，Unlicense 是一个不包含任何约束条件的许可证，专用于贡献作品到公共领域。任何人都可以对开源软件进行自由复制、修改、发布、使用、编译、出售等，并且可用于任何商业或非商业目的。\n另外，在 OSI 官网公布的开源许可证列表中，还有一个叫「木兰（Mulan PSL2）」的开源许可证，它是中国本土唯一获得 OSI 认可的开源许可证。Mulan PSL2 以中英文双语表述，中英文版本具有同等法律效力。如果中英文版本存在任何冲突不一致，以中文版为准。\n「木兰」并不是一个许可证，而是一系列许可证，它包含木兰宽松许可证、木兰公共许可证、木兰开放作品许可协议。其中木兰宽松许可证第 2 版（Mulan PSL2）在 2020 年 2 月 14 日通过 OSI 批准。\n如果你想使用一个中文的开源许可证，那么 Mulan PSL2 目前是你唯一的选择。\n# 使用开源许可证 以 MIT 为例，我们来学习下如何在自己的开源项目中使用开源许可证：\n首先我们需要在自己的开源项目根目录下创建一个叫 LICENSE 的文本文件，注意文件名不包含任何后缀。\n然后去到 OSI 官网找到 MIT 开源许可证模板，内容如下：\n1 2 3 4 5 6 7 Copyright \u0026lt;YEAR\u0026gt; \u0026lt;COPYRIGHT HOLDER\u0026gt; Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 将开源许可证模板内容复制到 LICENSE 文本文件中，并将第一行 Copyright 后面的 \u0026lt;YEAR\u0026gt; 替换为当前年份，将 \u0026lt;COPYRIGHT HOLDER\u0026gt; 替换为自己的名字。\n当开放项目源代码时，将此文件一同开放出去即可。如果你使用 GitHub 开放源码，则只需要将此 LICENSE 加入到 git 管理即可。\n如果你是在 GitHub 上新建开源项目，在创建项目界面，有一个 Choose a license 按钮可以很方便的选择一款开源协议，并且 GitHub 会自动替换许可证模板中的年份、作者等信息。 另外，我们在开放源代码时，其实可以不使用 OSI 认证的开源许可证，而是选择自己写一份许可证，用来声明版权。这同样是具有法律效力的，不过这份许可证就不能叫做开源许可证了。 # 如何选择开源许可证 乌克兰程序员 Paul Bagwell 画了一张图在网上很是流行，阮一峰老师将其翻译成了中文，如下：\n注：\n关于什么是许可证兼容性可以参考：《开源许可证兼容性指南.docx》 从上图中可以看出，大体上左边的许可证比较严格，右边的许可证较为宽松。此图虽然不够严谨，胜在方便理解。在开源自己的项目时，可以根据此图快速选择出适合自己的开源许可证。\n更多参考图：\n# 知识共享许可证Creative Commons（CC） 有时候，我们想要开源的并不是一款软件，而是一套开源的教程或者书籍等，此时严格来讲并不能使用上面所介绍的开源许可证。\n在 OSD 第 2 条中有规定：开源软件是必须要包含源代码的。\n也就是说，教程或者书籍等没有源代码，并不能作为开源软件，也就不能使用开源许可证。\n此类项目想要开源，应该使用「知识共享许可证」（creative commons licenses），通常也叫 CC 许可证。\nCC 许可证由 Creative Commons 基金会提出，虽然没有得到 OSI 的认可，但他仍具有法律效力，并且应用广泛。\n上面提到的「木兰开放作品许可协议」就是对标知识共享许可证的。同木兰许可证类似，知识共享许可证也是一系列许可证，目前最新的知识共享许可证为 4.0 版本，常见的许可证有 6 种：\nCC BY 4.0 (Attribution 4.0 International，署名 4.0 国际) CC BY-SA 4.0 (Attribution-ShareAlike 4.0 International，署名-相同方式共享 4.0 国际) CC BY-ND 4.0 (Attribution-NoDerivatives 4.0 International，署名-禁止演绎 4.0 国际) CC BY-NC 4.0 (Attribution-NonCommercial 4.0 International，署名-非商业性使用 4.0 国际) CC BY-NC-SA 4.0 (Attribution-NonCommercial-ShareAlike 4.0 International，署名-非商业性使用-相同方式共享 4.0 国际) CC BY-NC-ND 4.0 (Attribution-NonCommercial-NoDerivatives 4.0 International，署名-非商业性使用-禁止演绎 4.0 国际) 可以发现，CC 许可证命名方式就是它的权利简拼组合。以下是对其中出现的几个名词的解释：\n​\t署名：必须给出原作者的署名，提供指向本许可协议的链接，同时标明是否对原始作品作了修改。\n​\t非商业性使用：您不得将本作品用于商业目的。不得用于盈利性目的。\n​\t相同方式共享：在任何媒介以任何形式复制、发行本作品时必须采用相同的许可证。\n​\t禁止演绎：禁止修改、转换或以本作品为基础进行创作。\n之所以每个许可证后面都带有国际两个字，是因为这系列许可证发布了不同的地域版，不过国际版更为通用。\n需要注意 CC 系列许可证一旦发布，就不可收回，只要你遵守许可协议条款，许可人就无法收回你的这些权利。\n如需使用 CC 许可证，可以参考示例。\n​\t本教程采用知识共享 署名-相同方式共享 4.0国际协议。\n​\t博客内容遵循 知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议\n或参考官网自行组合。\n注意：协议链接并不必须指定，但在使用知识共享协议时，提供协议链接是一个很好的做法，因为它可以帮助其他人方便地访问并了解你所使用的具体协议内容。\n# 开源案例 介绍完了开源协议，我们再来看一个开源案例：\n# 中国首例因违反 GPL 协议致侵害计算机软件著作权纠纷 2021-06-30 在中国裁判文书网上公布了一则民事判决书，标题为：「济宁市罗盒网络科技有限公司诉被告福建风灵创景科技有限公司(以下简称福建风灵公司)、被告北京风灵创景科技有限公司(以下简称北京风灵公司)、被告深圳市腾讯计算机系统有限公司(以下简称腾讯公司)侵害计算机软件著作权纠纷一审民事判决书」。案件概况如下：\n原告济宁市罗盒网络科技有限公司独立开「罗盒（VirtualApp）」从 2016 年 7 月 8 日的版本开始引入开源协议，起初为 LGPL3.0 协议，从 2016 年 8 月 12 日开始更换为 GPL3.0 协议。2017 年 10 月 29 日开始删除适用 GPL3.0 协议的表述，但英文介绍中仍保留openplatform 的表述。\n2018 年 9 月，原告调查发现名为「点心桌面」的软件使用了 VirtualApp 的代码，将两个软件源代码进行分析比对，两者间 421 个可比代码中有 308 个代码具有实质相似性，有 27 个代码具有高度相似性，有 78 个代码具有一般相似性。因此，被诉侵权软件与涉案软件构成实质相似。\n经查，被诉「点心桌面」中使用了原告采用 GPL3.0 协议发布的 VirtualApp，被告对此亦予以确认。\n原告申请赔偿 2000 万，最终，法院酌情确定赔偿数额为 50 万元。原告为制止本案侵权行为所支出的合理费用，计算在赔偿损失数额范围之内。\n更多细节可以点击下载查看。\n该案例给开源软件使用者敲响一记警钟，使用开源软件一定要查看并遵循开源许可证。\n# 总结 本文带大家一起认识了什么是开源协议，并且还对常用开源协议进行了分析，以及如何使用开源协议。同时讲解了针对书籍等开源作品使用的知识共享许可协议和使用方式。最终分享了一个开源软件纠纷案例，以说明了解开源协议的重要性。\n此文仅为作者本人学习并整理的开源协议相关知识，即不够全面，也不够严谨，不能作为法律依据。希望你能通过本篇文章认识并重视开源协议，学习和书写本篇文章时间有限，难免出现表达不够准确或错误的地方，欢迎批评指正。\n最后，想提醒大家，身为一名开发者，掌握开源协议是有必要的。不过开源协议的内容非常多且专业，想要完全了解也是一项繁重的工作，毕竟这不是我们的专业领域，如果遇到无法确定的问题，可以寻求身边的专业法务帮忙。\n# 参考 各种开源协议介绍 一文看懂开源许可证丨开源知识科普 原文：开源协议简介 如何选择开源许可证？ ","date":"2024-05-06T23:22:29+08:00","permalink":"https://arlettebrook.github.io/p/open-source-license-introduction/","title":"Open Source License Introduction"},{"content":" Viper 是一个功能齐全的 Go 应用程序配置库，支持很多场景。它可以处理各种类型的配置需求和格式，包括设置默认值、从多种配置文件和环境变量中读取配置信息、实时监视配置文件等。无论是小型应用还是大型分布式系统，Viper 都可以提供灵活而可靠的配置管理解决方案。在本文中，我们将深入探讨 Viper 的各种用法和使用场景，以帮助读者更好地了解和使用 Viper 来管理应用程序配置。\n# 为什么选择 Viper 当我们在做技术选型时，肯定要知道为什么选择某一项技术，而之所以选择使用 Viper 来管理应用程序的配置，Viper 官方给出了如下答案：\n当构建应用程序时，你不想担心配置文件格式，只想专注于构建出色的软件。Viper 就是为了帮助我们解决这个问题而存在的。\nViper 可以完成以下工作：\n查找、加载和反序列化 JSON、TOML、YAML、HCL、INI、envfile 或 Java Properties 等多种格式的配置文件。 为不同的配置选项设置默认值。 为通过命令行标志指定的选项设置覆盖值。 提供别名系统，以便轻松重命名配置项而不破坏现有代码。 可以轻松区分用户提供的命令行参数或配置文件中的值是否与默认值相同。 可以设置监听配置文件的修改，修改时自动加载新的配置； 从环境变量、命令行选项和io.Reader中读取配置； 从远程配置系统中读取和监听修改，如 etcd/Consul； 代码逻辑中显示设置键值。 \u0026hellip;\u0026hellip; 注：关于上面第 5 点，我个人理解的使用场景是：\n先从命令行参数或配置文件中读取配置。 可以使用 viper.IsSet(key) 方法判断用户是否设置了 key 所对应的 value，如果设置了，可以通过 viper.Get(key) 获取值。 调用 viper.SetDefault(key, default_value) 来设置默认值（默认值不会覆盖上一步所获取到的值）。 在第 2 步中可以拿到用户设置的值 value，在第 3 步中可以知道默认值 default_value，这样其实就可以判断两者是否相同了。 Viper 采用以下优先级顺序来加载配置，按照优先级由高到低排序如下：\n显式调用 viper.Set 设置的配置值 命令行参数 环境变量 配置文件 key/value 存储 默认值 注意 ⚠️：Viper 配置中的键不区分大小写，如 user/User/USER 被视为是相等的 key，关于是否将其设为可选，目前还在讨论中。\nViper 包中最核心的两个功能是：如何把配置值读入 Viper 和从 Viper 中读取配置值，接下来我将分别介绍这两个功能。\n# 快速使用 安装：\n1 go get -u github.com/spf13/viper 导入：\n1 import \u0026#34;github.com/spf13/viper\u0026#34; 使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;github.com/spf13/viper\u0026#34; ) func main() { viper.SetConfigName(\u0026#34;config\u0026#34;) viper.SetConfigType(\u0026#34;toml\u0026#34;) viper.AddConfigPath(\u0026#34;.\u0026#34;) viper.SetDefault(\u0026#34;redis.port\u0026#34;, 6381) err := viper.ReadInConfig() if err != nil { log.Fatalf(\u0026#34;read config failed: %v\u0026#34;, err) } fmt.Println(viper.Get(\u0026#34;app_name\u0026#34;)) fmt.Println(viper.Get(\u0026#34;log_level\u0026#34;)) fmt.Println(\u0026#34;mysql ip: \u0026#34;, viper.Get(\u0026#34;mysql.ip\u0026#34;)) fmt.Println(\u0026#34;mysql port: \u0026#34;, viper.Get(\u0026#34;mysql.port\u0026#34;)) fmt.Println(\u0026#34;mysql user: \u0026#34;, viper.Get(\u0026#34;mysql.user\u0026#34;)) fmt.Println(\u0026#34;mysql password: \u0026#34;, viper.Get(\u0026#34;mysql.password\u0026#34;)) fmt.Println(\u0026#34;mysql database: \u0026#34;, viper.Get(\u0026#34;mysql.database\u0026#34;)) fmt.Println(\u0026#34;redis ip: \u0026#34;, viper.Get(\u0026#34;redis.ip\u0026#34;)) fmt.Println(\u0026#34;redis port: \u0026#34;, viper.Get(\u0026#34;redis.port\u0026#34;)) } 这里的配置文件格式是toml。toml 的语法很简单，快速入门请看TOML:简体中文。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # config.toml app_name = \u0026#34;awesome web\u0026#34; # possible values: DEBUG, INFO, WARNING, ERROR, FATAL log_level = \u0026#34;DEBUG\u0026#34; [mysql] ip = \u0026#34;127.0.0.1\u0026#34; port = 3306 user = \u0026#34;dj\u0026#34; password = 123456 database = \u0026#34;awesome\u0026#34; [redis] ip = \u0026#34;127.0.0.1\u0026#34; port = 7381 viper 的使用非常简单，它需要很少的设置。设置文件名（SetConfigName）、配置类型（SetConfigType）和搜索路径（AddConfigPath），然后调用ReadInConfig。 viper会自动根据类型来读取配置。使用时调用viper.Get方法获取键值。\n编译、运行程序：\n1 2 3 4 5 6 7 8 9 10 $ go run main.go awesome web DEBUG mysql ip: 127.0.0.1 mysql port: 3306 mysql user: dj mysql password: 123456 mysql database: awesome redis ip: 127.0.0.1 redis port: 7381 有几点需要注意：\n设置文件名时不要带后缀； 搜索路径可以设置多个，viper 会根据设置顺序依次查找； viper 获取值时使用section.key的形式，即传入嵌套的键名； 默认值可以调用viper.SetDefault设置。 # 读取键 viper 提供了多种形式的读取方法。在上面的例子中，我们看到了Get方法的用法。Get方法返回一个interface{}的值，使用有所不便。\nGetType系列方法可以返回指定类型的值。 其中，Type 可以为Bool/Float64/Int/String/Time/Duration/IntSlice/StringSlice。 但是请注意，如果指定的键不存在或类型不正确，GetType方法返回对应类型的零值。\n如果要判断某个键是否存在，使用IsSet方法。 另外，GetStringMap和GetStringMapString直接以 map 返回某个键下面所有的键值对，前者返回map[string]interface{}，后者返回map[string]string。 AllSettings以map[string]interface{}返回所有设置。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // 省略包名和 import 部分 func main() { viper.SetConfigName(\u0026#34;config\u0026#34;) viper.SetConfigType(\u0026#34;toml\u0026#34;) viper.AddConfigPath(\u0026#34;.\u0026#34;) err := viper.ReadInConfig() if err != nil { log.Fatalf(\u0026#34;read config failed: %v\u0026#34;, err) } fmt.Println(\u0026#34;protocols: \u0026#34;, viper.GetStringSlice(\u0026#34;server.protocols\u0026#34;)) fmt.Println(\u0026#34;ports: \u0026#34;, viper.GetIntSlice(\u0026#34;server.ports\u0026#34;)) fmt.Println(\u0026#34;timeout: \u0026#34;, viper.GetDuration(\u0026#34;server.timeout\u0026#34;)) fmt.Println(\u0026#34;mysql ip: \u0026#34;, viper.GetString(\u0026#34;mysql.ip\u0026#34;)) fmt.Println(\u0026#34;mysql port: \u0026#34;, viper.GetInt(\u0026#34;mysql.port\u0026#34;)) if viper.IsSet(\u0026#34;redis.port\u0026#34;) { fmt.Println(\u0026#34;redis.port is set\u0026#34;) } else { fmt.Println(\u0026#34;redis.port is not set\u0026#34;) } fmt.Println(\u0026#34;mysql settings: \u0026#34;, viper.GetStringMap(\u0026#34;mysql\u0026#34;)) fmt.Println(\u0026#34;redis settings: \u0026#34;, viper.GetStringMap(\u0026#34;redis\u0026#34;)) fmt.Println(\u0026#34;all settings: \u0026#34;, viper.AllSettings()) } 我们在配置文件 config.toml 中添加protocols和ports配置：\n1 2 3 4 [server] protocols = [\u0026#34;http\u0026#34;, \u0026#34;https\u0026#34;, \u0026#34;port\u0026#34;] ports = [10000, 10001, 10002] timeout = \u0026#34;3s\u0026#34; 编译、运行程序，输出：\n1 2 3 4 5 6 7 8 9 10 11 12 $ go run main.go protocols: [http https port] ports: [10000 10001 10002] timeout: 3s mysql ip: 127.0.0.1 mysql port: 3306 redis.port is set mysql settings: map[database:awesome ip:127.0.0.1 password:123456 port:3306 user:dj] redis settings: map[ip:127.0.0.1 port:7381] all settings: map[app_name:awesome web log_level:DEBUG mysql:map[database:awesome ip:127.0.0.1 pa ssword:123456 port:3306 user:dj] redis:map[ip:127.0.0.1 port:7381] server:map[ports:[10000 10001 1 0002] protocols:[http https port] timeout:3s]] 如果将配置中的redis.port注释掉，将输出redis.port is not set。\n上面的示例中还演示了如何使用time.Duration类型，只要是time.ParseDuration接受的格式都可以，例如3s、2min、1min30s等。\n# 设置键值 viper 支持在多个地方设置，使用下面的顺序依次读取：\n调用Set显示设置的； 命令行选项； 环境变量； 配置文件； 默认值。 viper.Set\n如果某个键通过viper.Set设置了值，那么这个值的优先级最高。\n1 viper.Set(\u0026#34;redis.port\u0026#34;, 5381) 如果将上面这行代码放到程序中，运行程序，输出的redis.port将是 5381。\nviper.SetDefault\n设置默认值，如果没有配置键，将使用默认值\n1 viper.SetDefault(\u0026#34;log_level\u0026#34;, \u0026#34;INFO\u0026#34;) 如果配置文件中没有配置log_level,那么将使用INFO\n# 把配置值读入Viper Viper 支持多种方式读入配置：\n设置默认配置值 从配置文件读取配置 监控并重新读取配置文件 从 io.Reader 读取配置 从环境变量读取配置 从命令行参数读取配置 从远程 key/value 存储读取配置 我们一个一个来看。\n# 设置默认配置值 一个好的配置系统应该支持默认值。Viper 支持使用 viper.SetDefault(key, value) 为 key 设置默认值 value，在没有通过配置文件、环境变量、远程配置或命令行标志设置 key 所对应值的情况下，这很有用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/spf13/viper\u0026#34; ) func main() { // 设置默认配置 viper.SetDefault(\u0026#34;username\u0026#34;, \u0026#34;arlettebrook\u0026#34;) viper.SetDefault(\u0026#34;server\u0026#34;, map[string]string{\u0026#34;ip\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;port\u0026#34;: \u0026#34;8080\u0026#34;}) // 读取配置值 fmt.Printf(\u0026#34;username: %s\\n\u0026#34;, viper.Get(\u0026#34;Username\u0026#34;)) // key 不区分大小写 fmt.Printf(\u0026#34;server: %+v\\n\u0026#34;, viper.Get(\u0026#34;server\u0026#34;)) } 执行以上示例代码得到如下输出：\n1 2 3 $ go run main.go username: arlettebrook server: map[ip:127.0.0.1 port:8080] # 从配置文件读取配置 Viper 支持从 JSON、TOML、YAML、HCL、INI、envfile 或 Java Properties 格式的配置文件中读取配置。Viper 可以搜索多个路径，但目前单个 Viper 实例只支持单个配置文件。Viper 不会默认配置任何搜索路径，将默认决定留给应用程序。\n主要有两种方式来加载配置文件：\n通过 viper.SetConfigFile() 指定配置文件，显式定义配置文件的路径、名称和扩展名。 Viper将使用它并且不检查任何配置路径。 通过 viper.SetConfigName() 指定不带扩展名的配置文件，viper.SetConfigType()指定配置文件类型类型。然后通过 viper.AddConfigPath() 指定配置文件的搜索路径中，可以通过多次调用，来设置多个配置文件搜索路径。Viper 会根据所添加的路径顺序查找指定配置文件，如果找到就停止查找。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 package main import ( \u0026#34;errors\u0026#34; \u0026#34;flag\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;github.com/spf13/viper\u0026#34; ) var ( cfg = flag.String(\u0026#34;c\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;config file.\u0026#34;) ) func main() { flag.Parse() if *cfg != \u0026#34;\u0026#34; { viper.SetConfigFile(*cfg) // 指定配置文件（路径 + 配置文件名） } else { viper.AddConfigPath(\u0026#34;.\u0026#34;) // 把当前目录加入到配置文件的搜索路径中 viper.AddConfigPath(\u0026#34;$HOME/.config\u0026#34;) // 可以多次调用 AddConfigPath 来设置多个配置文件搜索路径 viper.SetConfigName(\u0026#34;config\u0026#34;) viper.SetConfigType(\u0026#34;toml\u0026#34;) // 如果配置文件名中没有扩展名，则需要显式指定配置文件的格式// 指定配置文件名（没有扩展名） } // 读取配置文件 if err := viper.ReadInConfig(); err != nil { var configFileNotFoundError viper.ConfigFileNotFoundError if errors.As(err, \u0026amp;configFileNotFoundError) { log.Fatalln(configFileNotFoundError.Error()) } log.Fatalln(err) } fmt.Printf(\u0026#34;using config file: %s\\n\u0026#34;, viper.ConfigFileUsed()) // 读取配置值 fmt.Printf(\u0026#34;username: %s\\n\u0026#34;, viper.Get(\u0026#34;username\u0026#34;)) } viper.ConfigFileUsed()返回使用的配置文件的路径\n假如有如下配置文件 config.yaml 与示例程序在同一目录中：\n1 2 3 4 5 6 # config.yaml username: arlettebrook password: 123456 server: ip: 127.0.0.1 port: 8080 执行以上示例代码得到如下输出：\n1 2 3 $ go run main.go -c ./config.yaml using config file: ./config.yaml username: arlettebrook # 监控并重新读取配置文件 Viper 支持在应用程序运行过程中实时读取配置文件，即热加载配置。\n只需要调用 viper.WatchConfig() 即可开启此功能。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/fsnotify/fsnotify\u0026#34; \u0026#34;github.com/spf13/viper\u0026#34; ) func main() { viper.SetConfigFile(\u0026#34;./config.yaml\u0026#34;) // 注册每次配置文件发生变更后都会调用的回调函数 viper.OnConfigChange(func(e fsnotify.Event) { fmt.Printf(\u0026#34;config file changed: %s username:%s\\n\u0026#34;, e.Name, viper.Get(\u0026#34;username\u0026#34;)) }) // 监控并重新读取配置文件，需要确保在调用前添加了所有的配置路径 viper.WatchConfig() err := viper.ReadInConfig() if err != nil { log.Fatalln(\u0026#34;加载配置文件错误:\u0026#34;, err) } // 读取配置值 fmt.Printf(\u0026#34;未修改的username: %s\\n\u0026#34;, viper.Get(\u0026#34;username\u0026#34;)) // 阻塞程序，这个过程中可以手动去修改配置文件内容，观察程序输出变化,注意要保存。 time.Sleep(time.Second * 10) // 读取配置值 fmt.Printf(\u0026#34;最终的username: %s\\n\u0026#34;, viper.Get(\u0026#34;username\u0026#34;)) } 值得注意的是，在调用 viper.WatchConfig() 监控并重新读取配置文件之前，需要确保添加了所有的配置搜索路径。\n并且，我们还可以通过 viper.OnConfigChange() 函数注册一个每次配置文件发生变更后都会调用的回调函数。\n我们依然使用上面的 config.yaml 配置文件：\n1 2 3 4 5 username: arlettebrook password: 123456 server: ip: 127.0.0.1 port: 8080 执行以上示例代码，并在程序阻塞的时候，手动修改配置文件中 username 后面分别追加1保存、2保存3保存，可以得到如下输出：\n1 2 3 4 5 6 7 8 9 $ go run main.go 未修改的username: arlettebrook config file changed: config.yaml username:arlettebrook1 config file changed: config.yaml username:arlettebrook1 config file changed: config.yaml username:arlettebrook12 config file changed: config.yaml username:arlettebrook12 config file changed: config.yaml username:arlettebrook123 config file changed: config.yaml username:arlettebrook123 最终的username: arlettebrook123 我这里修改一次回调函数不知道为什么执行了俩次，不过没有影响。\n# 监听文件修改 viper 可以监听文件修改，热加载配置。因此不需要重启服务器，就能让配置生效。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/spf13/viper\u0026#34; ) func main() { viper.SetConfigName(\u0026#34;config\u0026#34;) viper.SetConfigType(\u0026#34;toml\u0026#34;) viper.AddConfigPath(\u0026#34;.\u0026#34;) err := viper.ReadInConfig() if err != nil { log.Fatalf(\u0026#34;read config failed: %v\u0026#34;, err) } viper.WatchConfig() fmt.Println(\u0026#34;redis port before sleep: \u0026#34;, viper.Get(\u0026#34;redis.port\u0026#34;)) time.Sleep(time.Second * 10) fmt.Println(\u0026#34;redis port after sleep: \u0026#34;, viper.Get(\u0026#34;redis.port\u0026#34;)) } 只需要调用viper.WatchConfig，viper 会自动监听配置修改。如果有修改，重新加载的配置。\n上面程序中，我们先打印redis.port的值，然后Sleep 10s。在这期间修改配置中redis.port的值，Sleep结束后再次打印。 发现打印出修改后的值：\n1 2 redis port before sleep: 7381 redis port after sleep: 73810 另外，还可以为配置修改增加一个回调：\n1 2 3 viper.OnConfigChange(func(e fsnotify.Event) { fmt.Printf(\u0026#34;Config file:%s Op:%s\\n\u0026#34;, e.Name, e.Op) }) 这样文件修改时会执行这个回调。\nviper 使用fsnotify这个库来实现监听文件修改的功能。\n# 从 io.Reader 读取配置 Viper 支持从任何实现了 io.Reader 接口的配置源中读取配置。注意需要指定配置文件的类型，才能识别io.Reader。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package main import ( \u0026#34;bytes\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;github.com/spf13/viper\u0026#34; ) func main() { viper.SetConfigType(\u0026#34;yaml\u0026#34;) // 或者使用 viper.SetConfigType(\u0026#34;YAML\u0026#34;) var yamlExample = []byte(` username: arlettebrook password: 123456 server: ip: 127.0.0.1 port: 8080 `) err := viper.ReadConfig(bytes.NewBuffer(yamlExample)) if err != nil { log.Fatalln(\u0026#34;读取配置文件错误：\u0026#34;, err) } // 读取配置值 fmt.Printf(\u0026#34;username: %s\\n\u0026#34;, viper.Get(\u0026#34;username\u0026#34;)) } 这里我们通过 bytes.NewBuffer() 构造了一个 bytes.Buffer 对象，它实现了 io.Reader 接口，所以可以直接传递给 viper.ReadConfig() 来从中读取配置。\n执行以上示例代码得到如下输出：\n1 2 $ go run main.go username: arlettebrook # 从io.Reader中读取 viper 支持从io.Reader中读取配置。这种形式很灵活，来源可以是文件，也可以是程序中生成的字符串，甚至可以从网络连接中读取的字节流。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 package main import ( \u0026#34;bytes\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;github.com/spf13/viper\u0026#34; ) func main() { viper.SetConfigType(\u0026#34;toml\u0026#34;) tomlConfig := []byte(` app_name = \u0026#34;awesome web\u0026#34; # possible values: DEBUG, INFO, WARNING, ERROR, FATAL log_level = \u0026#34;DEBUG\u0026#34; [mysql] ip = \u0026#34;127.0.0.1\u0026#34; port = 3306 user = \u0026#34;dj\u0026#34; password = 123456 database = \u0026#34;awesome\u0026#34; [redis] ip = \u0026#34;127.0.0.1\u0026#34; port = 7381 `) err := viper.ReadConfig(bytes.NewBuffer(tomlConfig)) if err != nil { log.Fatalf(\u0026#34;read config failed: %v\u0026#34;, err) } fmt.Println(\u0026#34;redis port: \u0026#34;, viper.GetInt(\u0026#34;redis.port\u0026#34;)) } # 从环境变量读取配置 Viper 还支持从环境变量读取配置，有 5 个方法可以帮助我们使用环境变量:\nAutomaticEnv()：使Viper检查环境变量是否与任何现有键（配置、默认值或标志）匹配。如果找到匹配的环境变量，它们将被加载到Viper中。\n开启自动匹配（根据前缀匹配）环境变量，加载到Viper中。如何没有前缀将加载所有环境变量。 BindEnv(string...) : error：绑定一个环境变量。需要一个或两个参数，第一个参数是配置项的键名（不区分大小写），第二个参数是环境变量的名称。如果未提供第二个参数，则 Viper 将假定环境变量名为：环境变量前缀_键名，且为全大写形式。例如环境变量前缀为 ENV，键名为 username，则环境变量名为 ENV_USERNAME。当显式提供第二个参数时，它不会自动添加前缀，也不会自动将其转换为大写。例如，使用 viper.BindEnv(\u0026quot;username\u0026quot;, \u0026quot;username\u0026quot;) 绑定键名为 username 的环境变量，应该使用 viper.Get(\u0026quot;username\u0026quot;) 读取环境变量的值。\n在使用环境变量时，需要注意，每次访问它的值时都会去环境变量中读取。当调用 BindEnv 时，Viper 不会固定它的值。\nSetEnvPrefix(string)：可以告诉 Viper 在读取环境变量时使用的前缀。BindEnv 和 AutomaticEnv 都将使用此前缀。例如，使用 viper.SetEnvPrefix(\u0026quot;ENV\u0026quot;) 设置了前缀为 ENV，并且使用 viper.BindEnv(\u0026quot;username\u0026quot;) 绑定了环境变量，在使用 viper.Get(\u0026quot;username\u0026quot;) 读取环境变量时，实际读取的 key 是 ENV_USERNAME。\nSetEnvKeyReplacer(string...) *strings.Replacer：允许使用 strings.Replacer 对象在一定程度上重写环境变量的键名。例如，存在 SERVER_IP=\u0026quot;127.0.0.1\u0026quot; 环境变量，使用 viper.SetEnvKeyReplacer(strings.NewReplacer(\u0026quot;.\u0026quot;, \u0026quot;_\u0026quot;, \u0026quot;-\u0026quot;, \u0026quot;_\u0026quot;)) 将键名中的 . 或 - 替换成 _，则通过 viper.Get(\u0026quot;server_ip\u0026quot;)、viper.Get(\u0026quot;server.ip\u0026quot;)、viper.Get(\u0026quot;server-ip\u0026quot;) 三种方式都可以读取环境变量对应的值。\nAllowEmptyEnv(bool)：当环境变量为空时（有键名而没有值的情况），默认会被认为是未设置的，并且程序将回退到下一个配置来源。要将空环境变量视为已设置，可以使用此方法。\nviper.AllSettings()读取全部配置，只能获取到通过 BindEnv 绑定的环境变量，无法获取到通过 AutomaticEnv 绑定的环境变量\n注意 ⚠️：\nViper 在读取环境变量时，是不区分大小写的。如果指定的环境变量与绑定的大小写不一致，viper会自动大小写转换。 以下代码是在windows下的bash终端中运行的。 使用示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;github.com/spf13/viper\u0026#34; ) func main() { viper.SetEnvPrefix(\u0026#34;env\u0026#34;) // 设置读取环境变量前缀，会自动转为大写 ENV viper.AllowEmptyEnv(true) // 将空环境变量视为已设置 viper.AutomaticEnv() // 开启自动匹配（根据前缀匹配）环境变量，加载到Viper中 _ = viper.BindEnv(\u0026#34;username\u0026#34;) // 也可以单独绑定某一个环境变量 _ = viper.BindEnv(\u0026#34;password\u0026#34;) // 将键名中的 . 或 - 替换成 _ viper.SetEnvKeyReplacer(strings.NewReplacer(\u0026#34;.\u0026#34;, \u0026#34;_\u0026#34;, \u0026#34;-\u0026#34;, \u0026#34;_\u0026#34;)) // 读取配置 fmt.Printf(\u0026#34;username: %v\\n\u0026#34;, viper.Get(\u0026#34;USERNAME\u0026#34;)) fmt.Printf(\u0026#34;password: %v\\n\u0026#34;, viper.Get(\u0026#34;password\u0026#34;)) fmt.Printf(\u0026#34;server.ip: %v\\n\u0026#34;, viper.Get(\u0026#34;server.ip\u0026#34;)) // fmt.Printf(\u0026#34;GOPATH:%v\\n\u0026#34;,viper.Get(\u0026#34;gopath\u0026#34;)) // 请注释到前缀在取消注释运行 // 读取全部配置，只能获取到通过 BindEnv 绑定的环境变量，无法获取到通过 AutomaticEnv 绑定的环境变量 fmt.Println(viper.AllSettings()) } 执行以上示例代码得到如下输出：\n1 2 3 4 5 $ ENV_USERNAME=arlettebrook ENV_SERVER_IP=127.0.0.1 ENV_PASSWORD= go run main.go username: arlettebrook password: server.ip: 127.0.0.1 map[password: username:arlettebrook] # 环境变量 如果从命令行参数都没有获取到键值，将尝试从环境变量中读取。我们既可以一个个绑定，也可以自动全部绑定。\n在init方法中调用AutomaticEnv方法绑定全部环境变量：\n1 2 3 4 func init() { // 绑定环境变量 viper.AutomaticEnv() } 为了验证是否绑定成功，我们在main方法中将环境变量 GOPATH 打印出来：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/spf13/viper\u0026#34; ) func init() { // 绑定环境变量 viper.AutomaticEnv() } func main() { fmt.Println(\u0026#34;GOPATH:\u0026#34;, viper.Get(\u0026#34;gopath\u0026#34;)) fmt.Println(\u0026#34;JAVA_HOME:\u0026#34;, viper.Get(\u0026#34;java_home\u0026#34;)) } 其他环境变量也是一样的，上面输出：\n1 2 3 $ go run main.go GOPATH: D:\\GoSettings\\GoPath JAVA_HOME: E:\\Java\\jdk-17.0.5 也可以单独绑定环境变量：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/spf13/viper\u0026#34; ) func init() { // 绑定环境变量 _ = viper.BindEnv(\u0026#34;redis.port\u0026#34;, \u0026#34;redis_port\u0026#34;) _ = viper.BindEnv(\u0026#34;username\u0026#34;) } func main() { fmt.Println(\u0026#34;redis port:\u0026#34;, viper.Get(\u0026#34;redis.port\u0026#34;)) fmt.Println(\u0026#34;username:\u0026#34;, viper.Get(\u0026#34;username\u0026#34;)) } 调用BindEnv方法，如果只传入一个参数，则这个参数既表示键名，又表示环境变量名。 如果传入两个参数，则第一个参数表示键名，第二个参数表示环境变量名。\n上面将运行将输出：\n1 2 3 $ username=arlettebrook REDIS_PORT=10809 go run main.go redis port: 10809 username: arlettebrook 如果对应的环境变量不存在，viper 会自动将键名全部大小写转换再查找一次。所以，使用键名REDIS_PORT也能读取环境变量redis.port的值。\n另外，嵌套的配置键，绑定环境变量时必须指定环境变量名，因为 Viper 不会自动将点转换为下划线或其他分隔符。\n但可以设置环境变量名的替换符，就可以不用知道第二个参数\n1 2 // 将键名中的 . 或 - 替换成 _ viper.SetEnvKeyReplacer(strings.NewReplacer(\u0026#34;.\u0026#34;, \u0026#34;_\u0026#34;, \u0026#34;-\u0026#34;, \u0026#34;_\u0026#34;)) 完整代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;github.com/spf13/viper\u0026#34; ) func init() { // 绑定环境变量 _ = viper.BindEnv(\u0026#34;redis.port\u0026#34;) _ = viper.BindEnv(\u0026#34;username-a\u0026#34;) viper.SetEnvKeyReplacer(strings.NewReplacer(\u0026#34;.\u0026#34;, \u0026#34;_\u0026#34;, \u0026#34;-\u0026#34;, \u0026#34;_\u0026#34;)) } func main() { fmt.Println(\u0026#34;redis port:\u0026#34;, viper.Get(\u0026#34;redis.port\u0026#34;)) fmt.Println(\u0026#34;username-a:\u0026#34;, viper.Get(\u0026#34;username-a\u0026#34;)) } 演示输出：\n1 2 3 $ username_A=arlettebrook REDIS_PORT=10809 go run main.go redis port: 10809 username-a: arlettebrook # 从命令行参数读取配置 Viper 支持 pflag 包（它们其实都在 spf13 仓库下），能够绑定命令行标志，从而读取命令行参数。\n同 BindEnv 类似，在调用绑定方法时，不会设置值，而是在每次访问时设置。这意味着我们可以随时绑定它，例如可以在 init() 函数中。\nBindPFlag：对于单个标志，可以调用此方法进行绑定。 BindPFlags：可以绑定一组现有的标志集 pflag.FlagSet。 示例程序如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/spf13/pflag\u0026#34; \u0026#34;github.com/spf13/viper\u0026#34; ) var ( _ = pflag.StringP(\u0026#34;username\u0026#34;, \u0026#34;u\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;help message for username\u0026#34;) _ = pflag.StringP(\u0026#34;password\u0026#34;, \u0026#34;p\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;help message for password\u0026#34;) ) func main() { pflag.Parse() _ = viper.BindPFlag(\u0026#34;username\u0026#34;, pflag.Lookup(\u0026#34;username\u0026#34;)) // 绑定单个标志 _ = viper.BindPFlags(pflag.CommandLine) // 绑定标志集 // 读取配置值 fmt.Printf(\u0026#34;username: %s\\n\u0026#34;, viper.Get(\u0026#34;username\u0026#34;)) fmt.Printf(\u0026#34;password: %s\\n\u0026#34;, viper.Get(\u0026#34;password\u0026#34;)) } 执行以上示例代码得到如下输出：\n1 2 3 $ go run main.go -u arlettebrook -p 123456 username: arlettebrook password: 123456 因为 pflag 能够兼容标准库的 flag 包，所以我们也可以变相的让 Viper 支持 flag。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package main import ( \u0026#34;flag\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/spf13/pflag\u0026#34; \u0026#34;github.com/spf13/viper\u0026#34; ) func main() { _ = flag.String(\u0026#34;username\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;help message for username\u0026#34;) pflag.CommandLine.AddGoFlagSet(flag.CommandLine) // 将 flag 命令行参数注册到 pflag pflag.Parse() _ = viper.BindPFlags(pflag.CommandLine) // 读取配置值 fmt.Printf(\u0026#34;username: %s\\n\u0026#34;, viper.Get(\u0026#34;username\u0026#34;)) } 执行以上示例代码得到如下输出：\n1 2 $ go run main.go --username arlettebrook username: arlettebrook 如果你不使用 flag 或 pflag，则 Viper 还提供了 Go 接口的形式来支持其他 Flags，具体用法可以参考官方文档。\n# 命令行选项 如果一个键没有通过viper.Set显示设置值，那么获取时将尝试从命令行选项中读取。 如果有，优先使用。viper 使用 pflag 库来解析选项。 我们首先在init方法中定义选项，并且调用viper.BindPFlags绑定选项到配置中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/spf13/pflag\u0026#34; \u0026#34;github.com/spf13/viper\u0026#34; ) func init() { pflag.Int(\u0026#34;redis.port\u0026#34;, 8381, \u0026#34;Redis port to connect\u0026#34;) // 绑定命令行 _ = viper.BindPFlags(pflag.CommandLine) } func main() { pflag.Parse() viper.SetConfigFile(\u0026#34;./config.toml\u0026#34;) _ = viper.ReadInConfig() fmt.Println(viper.Get(\u0026#34;app_name\u0026#34;)) fmt.Println(viper.Get(\u0026#34;log_level\u0026#34;)) fmt.Println(\u0026#34;mysql ip: \u0026#34;, viper.Get(\u0026#34;mysql.ip\u0026#34;)) fmt.Println(\u0026#34;mysql port: \u0026#34;, viper.Get(\u0026#34;mysql.port\u0026#34;)) fmt.Println(\u0026#34;mysql user: \u0026#34;, viper.Get(\u0026#34;mysql.user\u0026#34;)) fmt.Println(\u0026#34;mysql password: \u0026#34;, viper.Get(\u0026#34;mysql.password\u0026#34;)) fmt.Println(\u0026#34;mysql database: \u0026#34;, viper.Get(\u0026#34;mysql.database\u0026#34;)) fmt.Println(\u0026#34;redis ip: \u0026#34;, viper.Get(\u0026#34;redis.ip\u0026#34;)) fmt.Println(\u0026#34;redis port: \u0026#34;, viper.Get(\u0026#34;redis.port\u0026#34;)) } 编译、运行程序：\n1 2 3 4 5 6 7 8 9 10 $ go run main.go --redis.port 9381 awesome web DEBUG mysql ip: 127.0.0.1 mysql port: 3306 mysql user: dj mysql password: 123456 mysql database: awesome redis ip: 127.0.0.1 redis port: 9381 如何不传入选项：\n将使用环境变量的配置，没有，在使用配置文件的配置，没有，在使用默认，都没有，为对应类型的零值。\n将使用配置文件的配置redis port: 7381，如果配置文件没有配置，才会使用默认值。这里没有默认值。\n# 从远程 key/value 存储读取配置 要在 Viper 中启用远程支持，需要匿名导入 viper/remote 包：\n1 import _ \u0026#34;github.com/spf13/viper/remote\u0026#34; Viper 支持 etcd、Consul 等远程 key/value 存储，这里以 Consul 为例进行讲解。\n首先需要准备 Consul 环境，最方便快捷的方式就是启动一个 Docker 容器：\n1 2 3 4 5 6 $ docker run \\ -d \\ -p 8500:8500 \\ -p 8600:8600/udp \\ --name=badger \\ consul agent -server -ui -node=server-1 -bootstrap-expect=1 -client=0.0.0.0 Docker 容器启动好后，浏览器访问 http://localhost:8500/，即可进入 Consul 控制台，在 user/config 路径下编写 YAML 格式的配置。\n使用 Viper 从 Consul 读取配置示例代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/spf13/viper\u0026#34; _ \u0026#34;github.com/spf13/viper/remote\u0026#34; // 必须导入，才能加载远程 key/value 配置 ) func main() { viper.AddRemoteProvider(\u0026#34;consul\u0026#34;, \u0026#34;localhost:8500\u0026#34;, \u0026#34;user/config\u0026#34;) // 连接远程 consul 服务 viper.SetConfigType(\u0026#34;YAML\u0026#34;) // 显式设置文件格式文 YAML viper.ReadRemoteConfig() // 读取配置值 fmt.Printf(\u0026#34;username: %s\\n\u0026#34;, viper.Get(\u0026#34;username\u0026#34;)) fmt.Printf(\u0026#34;server.ip: %s\\n\u0026#34;, viper.Get(\u0026#34;server.ip\u0026#34;)) } 执行以上示例代码得到如下输出：\n1 2 3 $ go run main.go username: jianghushinian server.ip: 127.0.0.1 笔记：如果你想停止通过 Docker 安装的 Consul 容器，则可以执行 docker stop badger 命令。如果需要删除，则可以执行 docker rm badger 命令。\n# 从 Viper 中读取配置值 前文中我们介绍了各种将配置读入 Viper 的技巧，现在该学习如何使用这些配置了。\n在 Viper 中，有如下几种方法可以获取配置值：\nGet(key string) interface{}：获取配置项 key 所对应的值，key 不区分大小写，返回接口类型。 Get\u0026lt;Type\u0026gt;(key string) \u0026lt;Type\u0026gt;：获取指定类型的配置值， 可以是 Viper 支持的类型：GetBool、GetFloat64、GetInt、GetIntSlice、GetString、GetStringMap、GetStringMapString、GetStringSlice、GetTime、GetDuration。 AllSettings() map[string]interface{}：返回所有配置。根据我的经验，如果使用环境变量指定配置，则只能获取到通过 BindEnv 绑定的环境变量，无法获取到通过 AutomaticEnv 绑定的环境变量。 IsSet(key string) bool：值得注意的是，在使用 Get 或 Get\u0026lt;Type\u0026gt; 获取配置值，如果找不到，则每个 Get 函数都会返回一个零值。为了检查给定的键是否存在，可以使用 IsSet 方法，存在返回 true，不存在返回 false。 # 访问嵌套的键 有如下配置文件 config.yaml：\n1 2 3 4 5 username: arlettebrook password: 123456 server: ip: 127.0.0.1 port: 8080 可以通过 . 分隔符来访问嵌套字段。\n1 viper.Get(\u0026#34;server.ip\u0026#34;) 示例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;github.com/spf13/viper\u0026#34; ) func main() { viper.SetConfigFile(\u0026#34;./config.yaml\u0026#34;) err := viper.ReadInConfig() if err != nil { log.Fatalln(\u0026#34;加载配置文件失败：\u0026#34;, err) } // 读取配置值 fmt.Printf(\u0026#34;username: %v\\n\u0026#34;, viper.Get(\u0026#34;username\u0026#34;)) fmt.Printf(\u0026#34;server: %v\\n\u0026#34;, viper.Get(\u0026#34;server\u0026#34;)) fmt.Printf(\u0026#34;server.ip: %v\\n\u0026#34;, viper.Get(\u0026#34;server.ip\u0026#34;)) fmt.Printf(\u0026#34;server.port: %v\\n\u0026#34;, viper.Get(\u0026#34;server.port\u0026#34;)) } 执行以上示例代码得到如下输出：\n1 2 3 4 5 $ go run main.go username: arlettebrook server: map[ip:127.0.0.1 port:8080] server.ip: 127.0.0.1 server.port: 8080 有一种情况是，配置中本就存在着叫 server.ip 的键，那么它会遮蔽 server 对象下的 ip 配置项。\n1 2 3 4 5 6 username: arlettebrook password: 123456 server: ip: 127.0.0.1 port: 8080 server.ip: 10.0.0.1 示例程序如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;github.com/spf13/viper\u0026#34; ) func main() { viper.SetConfigFile(\u0026#34;./config.yaml\u0026#34;) err := viper.ReadInConfig() if err != nil { log.Println(\u0026#34;加载配置文件出错：\u0026#34;, err) } // 读取配置值 fmt.Printf(\u0026#34;username: %v\\n\u0026#34;, viper.Get(\u0026#34;username\u0026#34;)) fmt.Printf(\u0026#34;server: %v\\n\u0026#34;, viper.Get(\u0026#34;server\u0026#34;)) fmt.Printf(\u0026#34;server.ip: %v\\n\u0026#34;, viper.Get(\u0026#34;server.ip\u0026#34;)) fmt.Printf(\u0026#34;server.port: %v\\n\u0026#34;, viper.Get(\u0026#34;server.port\u0026#34;)) } 执行以上示例代码得到如下输出：\n1 2 3 4 5 $ go run main.go username: arlettebrook server: map[ip:127.0.0.1 port:8080] server.ip: 10.0.0.1 server.port: 8080 server.ip 打印结果为 10.0.0.1，而不再是 server map 中所对应的值 127.0.0.1。\n# 提取子树 当使用 Viper 读取 config.yaml 配置文件后，viper 对象就包含了所有配置，并能通过 viper.Get(\u0026quot;server.ip\u0026quot;) 获取子配置。\n我们可以将这份配置理解为一颗树形结构，viper 对象就包含了这个完整的树，可以使用如下方法获取 server 子树。\n1 srvCfg := viper.Sub(\u0026#34;server\u0026#34;) 使用示例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/spf13/viper\u0026#34; ) func main() { viper.SetConfigFile(\u0026#34;./config.yaml\u0026#34;) _ = viper.ReadInConfig() // 获取 server 子树 srvCfg := viper.Sub(\u0026#34;server\u0026#34;) // 读取配置值 fmt.Printf(\u0026#34;ip: %v\\n\u0026#34;, srvCfg.Get(\u0026#34;ip\u0026#34;)) fmt.Printf(\u0026#34;port: %v\\n\u0026#34;, srvCfg.Get(\u0026#34;port\u0026#34;)) fmt.Printf(\u0026#34;server.ip: %v\\n\u0026#34;, viper.Get(\u0026#34;server.ip\u0026#34;)) } 执行以上示例代码得到如下输出：\n1 2 3 4 $ go run main.go ip: 127.0.0.1 port: 8080 server.ip: 10.0.0.1 这里键没有出现覆盖的情况\n# 反序列化 Viper 提供了 2 个方法进行反序列化操作，以此来实现将所有或特定的值解析到结构体、map 等。\nUnmarshal(rawVal interface{}) : error：反序列化所有配置项。 UnmarshalKey(key string, rawVal interface{}) : error：反序列化指定配置项。 使用示例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;github.com/spf13/viper\u0026#34; ) type Config struct { Username string Password string // Viper 支持嵌套结构体 Server struct { IP string Port int } } func main() { viper.SetConfigFile(\u0026#34;./config.yaml\u0026#34;) _ = viper.ReadInConfig() var cfg Config if err := viper.Unmarshal(\u0026amp;cfg); err != nil { log.Fatalln(\u0026#34;反序列化错误：\u0026#34;, err) } var Password string if err := viper.UnmarshalKey(\u0026#34;Password\u0026#34;, \u0026amp;Password); err != nil { log.Fatalln(\u0026#34;反序列化错误：\u0026#34;, err) } fmt.Printf(\u0026#34;cfg: %+v\\n\u0026#34;, cfg) fmt.Printf(\u0026#34;Password: %s\\n\u0026#34;, Password) } 执行以上示例代码得到如下输出：\n1 2 3 $ go run main.go cfg: {Username:arlettebrook Password:123456 Server:{IP:10.0.0.1 Port:8080}} Password: 123456 如果配置项的 key 本身就包含 .，则需要修改分隔符。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/spf13/viper\u0026#34; ) type Config struct { Chart struct { Values map[string]interface{} } } func main() { // 默认的键分隔符为 `.`，这里将其修改为 `::` v := viper.NewWithOptions(viper.KeyDelimiter(\u0026#34;::\u0026#34;)) v.SetDefault(\u0026#34;chart::values\u0026#34;, map[string]interface{}{ \u0026#34;ingress\u0026#34;: map[string]interface{}{ \u0026#34;annotations\u0026#34;: map[string]interface{}{ \u0026#34;traefik.frontend.rule.type\u0026#34;: \u0026#34;PathPrefix\u0026#34;, \u0026#34;traefik.ingress.kubernetes.io/ssl-redirect\u0026#34;: \u0026#34;true\u0026#34;, }, }, }) var cfg Config if err := v.Unmarshal(\u0026amp;cfg); err != nil { panic(err) } fmt.Printf(\u0026#34;cfg: %+v\\n\u0026#34;, cfg) } 执行以上示例代码得到如下输出：\n1 2 3 $ go run main.go cfg: {Chart:{Values:map[ingress:map[annotations:map[traefik.frontend.rule.type:PathPrefix traefik. ingress.kubernetes.io/ssl-redirect:true]]]}} 注意⚠️：Viper 在后台使用 mapstructure 来解析值，其默认情况下使用 mapstructure tags。当我们需要将 Viper 读取的配置反序列到结构体中时，如果出现结构体字段跟配置项不匹配，则可以设置 mapstructure tags 来解决。\n# Unmarshal viper 支持将配置Unmarshal到一个结构体中，为结构体中的对应字段赋值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;github.com/spf13/viper\u0026#34; ) type Config struct { AppName string LogLevel string MySQL MySQLConfig Redis RedisConfig } type MySQLConfig struct { IP string Port int User string Password string Database string } type RedisConfig struct { IP string Port int } func main() { viper.SetConfigName(\u0026#34;config\u0026#34;) viper.SetConfigType(\u0026#34;toml\u0026#34;) viper.AddConfigPath(\u0026#34;.\u0026#34;) err := viper.ReadInConfig() if err != nil { log.Fatalf(\u0026#34;read config failed: %v\u0026#34;, err) } var c Config err = viper.Unmarshal(\u0026amp;c) if err != nil { log.Fatalf(\u0026#34;反序列化失败：%v\u0026#34;, err) } fmt.Println(c.MySQL) } 编译，运行程序，输出：\n1 2 $ go run main.go {127.0.0.1 3306 dj 123456 awesome} # 序列化 一个好用的配置包不仅能够支持反序列化操作，还要支持序列化操作。Viper 支持将配置序列化成字符串，或直接序列化到文件中。\n# 序列化成字符串 我们可以将全部配置序列化配置为 YAML 格式字符串。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/spf13/viper\u0026#34; \u0026#34;gopkg.in/yaml.v3\u0026#34; ) // 序列化配置为 YAML 格式字符串 func yamlStringSettings() string { c := viper.AllSettings() // 获取全部配置 bs, _ := yaml.Marshal(c) // 根据需求序列化成不同格式 return string(bs) } func main() { viper.SetConfigFile(\u0026#34;./config.yaml\u0026#34;) _ = viper.ReadInConfig() fmt.Printf(yamlStringSettings()) } 执行以上示例代码得到如下输出：\n1 2 3 4 5 6 $ go run main.go password: 123456 server: ip: 10.0.0.1 port: 8080 username: arlettebrook # 写入配置文件 Viper 还支持直接将配置序列化到文件中，提供了如下几个方法：\nWriteConfig：将当前的 viper 配置写入预定义路径。如果没有预定义路径，则会报错。如果预定义路径已经存在配置文件，将会被覆盖。 SafeWriteConfig：将当前的 viper 配置写入预定义路径。如果没有预定义路径，则会报错。如果预定义路径已经存在配置文件，不会覆盖，会报错。 WriteConfigAs： 将当前的 viper 配置写入给定的文件路径。如果给定的文件路径已经存在配置文件，将会被覆盖。 SafeWriteConfigAs：将当前的 viper 配置写入给定的文件路径。如果给定的文件路径已经存在配置文件，不会覆盖，会报错。 注意保存的文件类型要与配置类型一直，否则会报错config type could not be determined for XXX。 使用示例：\n1 2 3 4 5 6 viper.WriteConfig() // 将当前配置写入由 `viper.AddConfigPath()` 和 `viper.SetConfigFile()` 设置的预定义路径。类型就为配置类型。 viper.SafeWriteConfig() // 将会报错，因为它已经被写入了。 viper.WriteConfigAs(\u0026#34;./cfg.yaml\u0026#34;) // 文件类型要与配置类型一直，否则报错 viper.SafeWriteConfigAs(\u0026#34;./cfg.yaml\u0026#34;) // 将会报错，因为它已经被写入了。 viper.SafeWriteConfigAs(\u0026#34;./cfg/cfg.yaml\u0026#34;) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/spf13/viper\u0026#34; \u0026#34;gopkg.in/yaml.v3\u0026#34; ) // 序列化配置为 YAML 格式字符串 func yamlStringSettings() string { c := viper.AllSettings() // 获取全部配置 bs, _ := yaml.Marshal(c) // 根据需求序列化成不同格式 return string(bs) } func main() { viper.SetConfigFile(\u0026#34;./config.yaml\u0026#34;) _ = viper.ReadInConfig() fmt.Printf(yamlStringSettings()) viper.Set(\u0026#34;username\u0026#34;, \u0026#34;哈哈哈\u0026#34;) err := viper.WriteConfigAs(\u0026#34;./cfg.yaml\u0026#34;) if err != nil { panic(err) } fmt.Println(\u0026#34;修改后的username:\u0026#34;, viper.Get(\u0026#34;username\u0026#34;)) } 输出：\n1 2 3 4 5 6 7 $ go run main.go password: 123456 server: ip: 10.0.0.1 port: 8080 username: arlettebrook 修改后的username: 哈哈哈 # 保存配置 有时候，我们想要将程序中生成的配置，或者所做的修改保存下来。viper 提供了接口！\nWriteConfig：将当前的 viper 配置写到预定义路径，如果没有预定义路径，返回错误。将会覆盖当前配置； SafeWriteConfig：与上面功能一样，但是如果配置文件存在，则不覆盖； WriteConfigAs：保存配置到指定路径，如果文件存在，则覆盖； SafeWriteConfig：与上面功能一样，但是入股配置文件存在，则不覆盖。 下面我们通过程序生成一个config.toml配置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package main import ( \u0026#34;log\u0026#34; \u0026#34;github.com/spf13/viper\u0026#34; ) func main() { viper.SetConfigName(\u0026#34;config\u0026#34;) viper.SetConfigType(\u0026#34;toml\u0026#34;) viper.AddConfigPath(\u0026#34;.\u0026#34;) viper.Set(\u0026#34;app_name\u0026#34;, \u0026#34;awesome web\u0026#34;) viper.Set(\u0026#34;log_level\u0026#34;, \u0026#34;DEBUG\u0026#34;) viper.Set(\u0026#34;mysql.ip\u0026#34;, \u0026#34;127.0.0.1\u0026#34;) viper.Set(\u0026#34;mysql.port\u0026#34;, 3306) viper.Set(\u0026#34;mysql.user\u0026#34;, \u0026#34;root\u0026#34;) viper.Set(\u0026#34;mysql.password\u0026#34;, \u0026#34;123456\u0026#34;) viper.Set(\u0026#34;mysql.database\u0026#34;, \u0026#34;awesome\u0026#34;) viper.Set(\u0026#34;redis.ip\u0026#34;, \u0026#34;127.0.0.1\u0026#34;) viper.Set(\u0026#34;redis.port\u0026#34;, 6381) err := viper.SafeWriteConfig() if err != nil { log.Fatal(\u0026#34;write config failed: \u0026#34;, err) } } # 多实例对象 由于大多数应用程序都希望使用单个配置实例对象来管理配置，因此 viper 包默认提供了这一功能，它类似于一个单例。当我们使用 Viper 时不需要配置或初始化，Viper 实现了开箱即用的效果。\n在上面的所有示例中，演示了如何以单例方式使用 Viper。我们还可以创建多个不同的 Viper 实例以供应用程序中使用，每个实例都有自己单独的一组配置和值，并且它们可以从不同的配置文件、key/value 存储等位置读取配置信息。\nViper 包支持的所有功能都被镜像为 viper 对象上的方法，这种设计思路在 Go 语言中非常常见，如标准库中的 log 包。\n多实例使用示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/spf13/viper\u0026#34; ) func main() { x := viper.New() y := viper.New() x.SetConfigFile(\u0026#34;./config.yaml\u0026#34;) _ = x.ReadInConfig() fmt.Printf(\u0026#34;x.username: %v\\n\u0026#34;, x.Get(\u0026#34;username\u0026#34;)) y.SetDefault(\u0026#34;username\u0026#34;, \u0026#34;多实例对象\u0026#34;) fmt.Printf(\u0026#34;y.username: %v\\n\u0026#34;, y.Get(\u0026#34;username\u0026#34;)) viper.SetDefault(\u0026#34;username\u0026#34;, \u0026#34;默认单实例对象\u0026#34;) fmt.Printf(\u0026#34;viper.username: %v\\n\u0026#34;, viper.Get(\u0026#34;username\u0026#34;)) } 在这里，我创建了两个 Viper 实例 x 和 y，它们分别从配置文件读取配置和通过默认值的方式设置配置，使用时互不影响，使用者可以自行管理它们的生命周期。\n执行以上示例代码得到如下输出：\n1 2 3 4 $ go run main.go x.username: arlettebrook y.username: 多实例对象 viper.username: 默认单实例对象 # 使用建议 Viper 提供了众多方法可以管理配置，在实际项目开发中我们可以根据需要进行使用。如果是小型项目，推荐直接使用 viper 实例管理配置。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/spf13/viper\u0026#34; ) func main() { viper.SetConfigFile(\u0026#34;./config.yaml\u0026#34;) if err := viper.ReadInConfig(); err != nil { panic(fmt.Errorf(\u0026#34;read config file error: %s \\n\u0026#34;, err.Error())) } // 监控配置文件变化 viper.WatchConfig() // use config... fmt.Println(viper.Get(\u0026#34;username\u0026#34;)) } 如果是中大型项目，一般都会有一个用来记录配置的结构体，可以使用 Viper 将配置反序列化到结构体中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/fsnotify/fsnotify\u0026#34; \u0026#34;github.com/spf13/viper\u0026#34; ) type Config struct { Username string Password string // Viper 支持嵌套结构体 Server struct { IP string Port int } } func main() { viper.SetConfigFile(\u0026#34;./config.yaml\u0026#34;) if err := viper.ReadInConfig(); err != nil { panic(fmt.Errorf(\u0026#34;read config file error: %s \\n\u0026#34;, err.Error())) } // 将配置信息反序列化到结构体中 var cfg Config if err := viper.Unmarshal(\u0026amp;cfg); err != nil { panic(fmt.Errorf(\u0026#34;unmarshal config error: %s \\n\u0026#34;, err.Error())) } // 注册每次配置文件发生变更后都会调用的回调函数 viper.OnConfigChange(func(e fsnotify.Event) { // 每次配置文件发生变化，需要重新将其反序列化到结构体中 if err := viper.Unmarshal(\u0026amp;cfg); err != nil { panic(fmt.Errorf(\u0026#34;unmarshal config error: %s \\n\u0026#34;, err.Error())) } }) // 监控配置文件变化 viper.WatchConfig() // use config... fmt.Println(cfg.Username) } 需要注意的是，直接使用 viper 实例管理配置的情况下，当我们通过 viper.WatchConfig() 监听了配置文件变化，如果配置变化，则变化会立刻体现在 viper 实例对象上，下次通过 viper.Get() 获取的配置即为最新配置。但是在使用结构体管理配置时，viper 实例对象变化了，记录配置的结构体 Config 是不会自动更新的，所以需要使用 viper.OnConfigChange 在回调函数中重新将变更后的配置反序列化到 Config 中。\n# 总结 本文探讨 Viper 的各种用法和使用场景，首先说明了为什么使用 Viper，它的优势是什么。\n接着讲解了 Viper 包中最核心的两个功能：如何把配置值读入 Viper 和从 Viper 中读取配置值。Viper 对着两个功能都提供了非常多的方法来支持。\n然后又介绍了如何用 Viper 来管理多份配置，即使用多实例。\n对于 Viper 的使用我也给出了自己的建议，针对小型项目，推荐直接使用 viper 实例管理配置，如果是中大型项目，则推荐使用结构体来管理配置。\n最后，Viper 正在向着 v2 版本迈进，欢迎读者在这里分享想法，也期待下次来写一篇 v2 版本的文章与读者一起学习进步。\n# 参考 Viper 源码仓库： https://github.com/spf13/viper 搬运：在 Go 中如何使用 Viper 来管理配置 Go 每日一库之 viper ","date":"2024-05-03T18:24:28+08:00","permalink":"https://arlettebrook.github.io/p/go%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E4%B9%8B%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93viper/","title":"Go配置管理之第三方库viper"},{"content":" # 介绍 Cobra是一个命令行程序库，可以用来编写命令行程序。同时，它也提供了一个脚手架， 用于生成基于 cobra 的应用程序框架。非常多知名的开源项目使用了 cobra 库构建命令行，如Kubernetes、Hugo、etcd等等等等。 本文介绍 cobra 库的基本使用和一些有趣的特性。\n关于作者spf13，这里多说两句。spf13 开源不少项目，而且他的开源项目质量都比较高。 相信使用过 vim 的都知道spf13-vim，号称 vim 终极配置。 可以一键配置，对于我这样的懒人来说绝对是福音。他的viper是一个完整的配置解决方案。 完美支持 JSON/TOML/YAML/HCL/envfile/Java properties 配置文件等格式，还有一些比较实用的特性，如配置热更新、多查找目录、配置保存等。 还有非常火的静态网站生成器hugo也是他的作品。\nCobra 是一个 Go 语言开发的命令行（CLI）框架，它提供了简洁、灵活且强大的方式来创建命令行程序。它包含一个用于创建命令行程序的库（Cobra 库），以及一个用于快速生成基于 Cobra 库的命令行程序工具（Cobra 命令）。Cobra 是由 Go 团队成员 spf13 为 Hugo 项目创建的，并已被许多流行的 Go 项目所采用，如 Kubernetes、Helm、Docker (distribution)、Etcd 等。\n# 概念 Cobra 建立在命令、参数和标志这三个结构之上。要使用 Cobra 编写一个命令行程序，需要明确这三个概念。\n命令（COMMAND）：命令表示要执行的操作。 参数（ARG）：是命令的参数，一般用来表示操作的对象。 标志（FLAG）：是命令的修饰，可以调整操作的行为。 一个好的命令行程序在使用时读起来像句子，用户会自然的理解并知道如何使用该程序。\n要编写一个好的命令行程序，需要遵循的模式是 APPNAME VERB NOUN --ADJECTIVE 或 APPNAME COMMAND ARG --FLAG。\n在这里 VERB 代表动词，NOUN 代表名词，ADJECTIVE 代表形容词。\n以下是一个现实世界中好的命令行程序的例子：\n1 $ hugo server --port=1313 以上示例中，server 是一个命令（子命令），port 是一个标志（1313 是标志的参数，但不是命令的参数 ARG）。\n下面是一个 git 命令的例子：\n1 $ git clone URL --bare 以上示例中，clone 是一个命令（子命令），URL 是命令的参数，bare 是标志。\n# 特性 cobra 提供非常丰富的功能：\n轻松支持子命令，如app server，app fetch等； 完全兼容 POSIX 选项（包括短、长选项）； 嵌套子命令； 全局、本地层级选项。可以在多处设置选项，按照一定的顺序取用； 使用脚手架轻松生成程序框架和命令。 等。 # 快速使用 要使用 Cobra 创建命令行程序，需要先通过如下命令进行下载并添加到项目：\n1 go get -u github.com/spf13/cobra@latest 安装好后，就可以像其他 Go 语言库一样导入 Cobra 包并使用了。\n1 import \u0026#34;github.com/spf13/cobra\u0026#34; # 创建一个命令 假设我们要创建的命令行程序叫作 hugo，可以编写如下代码创建一个命令：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // hugo/cmd/root.go var rootCmd = \u0026amp;cobra.Command{ Use: \u0026#34;hugo\u0026#34;, Short: \u0026#34;Hugo is a very fast static site generator\u0026#34;, Long: `A Fast and Flexible Static Site Generator built with love by spf13 and friends in Go. Complete documentation is available at https://gohugo.io`, Run: func(cmd *cobra.Command, args []string) { fmt.Println(\u0026#34;run hugo...\u0026#34;) }, } func Execute() { if err := rootCmd.Execute(); err != nil { fmt.Println(err) os.Exit(1) } } cobra.Command 是一个结构体，代表一个命令，其各个属性含义如下：\nUse 是命令的名称。指定使用信息，即命令怎么被调用，格式为name arg1 [arg2]。name为命令名，后面的arg1为必填参数，arg3为可选参数，参数可以多个。参数一般用在子命令上。\nShort 代表当前命令的简短描述。\nLong 表示当前命令的完整描述。\nRun 属性是一个函数，当执行命令时会调用此函数。\nrootCmd.Execute() 是命令的执行入口，其内部会解析 os.Args[1:] 参数列表（默认情况下是这样，也可以通过 Command.SetArgs 方法设置参数），然后遍历命令树，为命令找到合适的匹配项和对应的标志。\n# 创建 main.go 按照编写 Go 程序的惯例，我们要为 hugo 程序编写一个 main.go 文件，作为程序的启动入口。\n1 2 3 4 5 6 7 8 9 10 // hugo/main.go package main import ( \u0026#34;hugo/cmd\u0026#34; ) func main() { cmd.Execute() } main.go 代码实现非常简单，只在 main 函数中调用了 cmd.Execute() 函数，来执行命令。\n# 编译并运行命令 现在，我们就可以编译并运行这个命令行程序了。\n1 2 3 4 5 # 编译 $ go build -o hugo # 执行 $ ./hugo run hugo... 笔记：示例代码里没有打印 Run 函数的 args 参数内容，你可以自行打印看看结果（提示：args 为命令行参数列表）。\n以上我们编译并执行了 hugo 程序，输出内容正是 cobra.Command 结构体中 Run 函数内部代码的执行结果。\n我们还可以使用 --help 查看这个命令行程序的使用帮助。\n1 2 3 4 5 6 7 8 9 10 $ ./hugo --help A Fast and Flexible Static Site Generator built with love by spf13 and friends in Go. Complete documentation is available at https://gohugo.io Usage: hugo [flags] Flags: -h, --help help for hugo 这里打印了 cobra.Command 结构体中 Long 属性的内容，如果 Long 属性不存在，则打印 Short 属性内容。\nhugo 命令用法为 hugo [flags]，如 hugo --help。\n这个命令行程序自动支持了 -h/--help 标志。\n以上就是使用 Cobra 编写一个命令行程序最常见的套路，这也是 Cobra 推荐写法。\n当前项目目录结构如下：\n1 2 3 4 5 6 7 $ tree hugo hugo ├── cmd │ └── root.go ├── go.mod ├── go.sum └── main.go Cobra 程序目录结构基本如此，main.go 作为命令行程序的入口，不要写过多的业务逻辑，所有命令都应该放在 cmd/ 目录下，以后不管编写多么复杂的命令行程序都可以这么来设计。\n在 cobra 中，命令和子命令都是用Command结构表示的。Command有非常多的字段，用来定制命令的行为。 在实际中，最常用的就那么几个。我们在前面示例中已经看到了Use/Short/Long/Run。\nUse指定使用信息，即命令怎么被调用，格式为name arg1 [arg2]。name为命令名，后面的arg1为必填参数，arg3为可选参数，参数可以多个。\nShort/Long都是指定命令的帮助信息，只是前者简短，后者详尽而已。\nRun是实际执行操作的函数。\n定义新的子命令很简单，就是创建一个cobra.Command变量，设置一些字段，然后添加到根命令中\n# 添加子命令 与定义 rootCmd 一样，我们可以使用 cobra.Command 定义其他命令，并通过 rootCmd.AddCommand() 方法将其添加为 rootCmd 的一个子命令。\n1 2 3 4 5 6 7 8 9 10 11 12 var versionCmd = \u0026amp;cobra.Command{ Use: \u0026#34;version\u0026#34;, Short: \u0026#34;Print the version number of Hugo\u0026#34;, Long: `All software has versions. This is Hugo\u0026#39;s`, Run: func(cmd *cobra.Command, args []string) { fmt.Println(\u0026#34;Hugo Static Site Generator v0.9 -- HEAD\u0026#34;) }, } func init() { rootCmd.AddCommand(versionCmd) } 现在重新编译并运行命令行程序。\n1 2 3 $ go build -o hugo $ ./hugo version Hugo Static Site Generator v0.9 -- HEAD 可以发现 version 命令已经被加入进来了。\n再次查看帮助信息：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 $ ./hugo -h A Fast and Flexible Static Site Generator built with love by spf13 and friends in Go. Complete documentation is available at https://gohugo.io Usage: hugo [flags] hugo [command] Available Commands: completion Generate the autocompletion script for the specified shell help Help about any command version Print the version number of Hugo Flags: -h, --help help for hugo Use \u0026#34;hugo [command] --help\u0026#34; for more information about a command. 这次的帮助信息更为丰富，除了可以使用 hugo [flags] 语法，由于子命令的加入，又多了一个 hugo [command] 语法可以使用，如 hugo version。\n现在有三个可用命令：\ncompletion 可以为指定的 Shell 生成自动补全脚本，将在 Shell 补全 小节进行讲解。\nhelp 用来查看帮助，同 -h/--help 类似，可以使用 hugo help command 语法查看 command 命令的帮助信息。\nversion 为新添加的子命令。\n查看子命令帮助信息：\n1 2 3 4 5 6 7 8 $ ./hugo help version All software has versions. This is Hugo\u0026#39;s Usage: hugo version [flags] Flags: -h, --help help for version # 使用命令行标志 Cobra 完美适配 pflag，结合 pflag 可以更灵活的使用标志功能。\n提示：对 pflag 不熟悉的读者可以参考我的另一篇文章《Go解析命令行参数之第三方库pflag》。\n# 持久标志 如果一个标志是持久的，则意味着该标志将可用于它所分配的命令以及该命令下的所有子命令。\n对于全局标志，可以定义在根命令 rootCmd 上。\n1 2 3 4 5 // hugo/cmd/root.go func init() { var Verbose bool rootCmd.PersistentFlags().BoolVarP(\u0026amp;Verbose, \u0026#34;verbose\u0026#34;, \u0026#34;v\u0026#34;, false, \u0026#34;Verbose output\u0026#34;) } # 本地标志 标志也可以是本地的，这意味着它只适用于该指定命令。\n1 2 3 4 5 // hugo/cmd/root.go func init() { var Source string rootCmd.Flags().StringVarP(\u0026amp;Source, \u0026#34;source\u0026#34;, \u0026#34;s\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;Source directory to read from\u0026#34;) } # 父命令的本地标志 默认情况下，Cobra 仅解析目标命令上的本地标志，忽略父命令上的本地标志。通过在父命令上启用 Command.TraverseChildren 属性，Cobra 将在执行目标命令之前解析每个命令的本地标志。(在执行子命令之前解析所有父级上的标志。)\n1 2 3 4 var rootCmd = \u0026amp;cobra.Command{ Use: \u0026#34;hugo\u0026#34;, TraverseChildren: true, } 提示：如果你不理解，没关系，继续往下看，稍后会有示例代码演示讲解。\n# 必选标志 默认情况下，标志是可选的。我们可以将其标记为必选，如果运行目标命令时没有提供，则会报错。\n1 2 3 4 5 6 7 8 9 10 11 12 var Verbose bool var Source string var Region string // hugo/cmd/root.go func init() { rootCmd.PersistentFlags().BoolVarP(\u0026amp;Verbose, \u0026#34;verbose\u0026#34;, \u0026#34;v\u0026#34;, false, \u0026#34;Verbose output\u0026#34;) rootCmd.Flags().StringVarP(\u0026amp;Source, \u0026#34;source\u0026#34;, \u0026#34;s\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;Source directory to read from\u0026#34;) rootCmd.Flags().StringVarP(\u0026amp;Region, \u0026#34;region\u0026#34;, \u0026#34;r\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;AWS region (required)\u0026#34;) _ = rootCmd.MarkFlagRequired(\u0026#34;region\u0026#34;) } 定义好以上几个标志后，为了展示效果，我们对 rootCmd.Run 方法做些修改，分别打印 Verbose、Source、Region 几个变量。\n1 2 3 4 5 6 7 8 9 var rootCmd = \u0026amp;cobra.Command{ Use: \u0026#34;hugo\u0026#34;, Run: func(cmd *cobra.Command, args []string) { fmt.Println(\u0026#34;run hugo...\u0026#34;) fmt.Printf(\u0026#34;Verbose: %v\\n\u0026#34;, Verbose) fmt.Printf(\u0026#34;Source: %v\\n\u0026#34;, Source) fmt.Printf(\u0026#34;Region: %v\\n\u0026#34;, Region) }, } 另外，为了测试启用 Command.TraverseChildren 的效果，我又添加了一个 print 子命令。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 var printCmd = \u0026amp;cobra.Command{ Use: \u0026#34;print [OPTIONS] [COMMANDS]\u0026#34;, Run: func(cmd *cobra.Command, args []string) { fmt.Println(\u0026#34;run print...\u0026#34;) fmt.Printf(\u0026#34;printFlag: %v\\n\u0026#34;, printFlag) fmt.Printf(\u0026#34;Source: %v\\n\u0026#34;, Source) }, } var printFlag string func init() { // 本地标志 printCmd.Flags().StringVarP(\u0026amp;printFlag, \u0026#34;flag\u0026#34;, \u0026#34;f\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;print flag for local\u0026#34;) rootCmd.AddCommand(printCmd) } 现在，我们重新编译并运行 hugo，来对上面添加的这几个标志进行测试。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 $ go build -o hugo $ ./hugo -h A Fast and Flexible Static Site Generator built with love by spf13 and friends in Go. Complete documentation is available at https://gohugo.io Usage: hugo [flags] hugo [command] Available Commands: completion Generate the autocompletion script for the specified shell help Help about any command print version Print the version number of Hugo Flags: -h, --help help for hugo -r, --region string AWS region (required) -s, --source string Source directory to read from -v, --verbose verbose output Use \u0026#34;hugo [command] --help\u0026#34; for more information about a command. 以上帮助信息清晰明了，我就不过多解释了。\n执行 hugo 命令：\n1 2 3 4 5 $ ./hugo -r test-region run hugo... Verbose: false Source: Region: test-region 现在 -r/--region 为必选标志，不传将会得到 Error: required flag(s) \u0026quot;region\u0026quot; not set 报错。\n执行 print 子命令：\n1 2 3 4 $ ./hugo print -f test-flag run print... printFlag: test-flag Source: 以上执行结果可以发现，父命令的标志 Source 内容为空。\n现在使用如下命令执行 print 子命令：\n1 2 3 4 $ ./hugo -s test-source print -f test-flag run print... printFlag: test-flag Source: test-source 在 print 子命令前，我们指定了 -s test-source 标志，-s/--source 是父命令 hugo 的标志，也能够被正确解析，这就是启用 Command.TraverseChildren 的效果。\n如果我们将 rootCmd 的 TraverseChildren 属性置为 false，则会得到 Error: unknown shorthand flag: 's' in -s 报错。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 指定 rootCmd.TraverseChildren = false 后，重新编译程序 $ go build -o hugo # 执行同样的命令，现在会得到报错 $ ./hugo -s test-source print -f test-flag Error: unknown shorthand flag: \u0026#39;s\u0026#39; in -s Usage: hugo print [OPTIONS] [COMMANDS] [flags] Flags: -f, --flag string print flag for local -h, --help help for print Global Flags: -v, --verbose verbose output unknown shorthand flag: \u0026#39;s\u0026#39; in -s 总结：在父命令上设置穿越儿童为true，运行子命令时会解析父命令的本地选项，反之，只解析子命令的本地选项以及持久选项。\n# 处理配置 除了将命令行标志的值绑定到变量，我们也可以将标志绑定到 Viper，这样就可以使用 viper.Get() 来获取标志的值了。\n1 2 3 4 5 6 var author string func init() { rootCmd.PersistentFlags().StringVar(\u0026amp;author, \u0026#34;author\u0026#34;, \u0026#34;YOUR NAME\u0026#34;, \u0026#34;Author name for copyright attribution\u0026#34;) viper.BindPFlag(\u0026#34;author\u0026#34;, rootCmd.PersistentFlags().Lookup(\u0026#34;author\u0026#34;)) } 提示：对 Viper 不熟悉的读者可以参考我的另一篇文章《Go配置管理之第三方库viper》。\n另外，我们可以使用 cobra.OnInitialize() 来初始化配置文件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 var cfgFile string func init() { cobra.OnInitialize(initConfig) rootCmd.Flags().StringVarP(\u0026amp;cfgFile, \u0026#34;config\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;config file\u0026#34;) } func initConfig() { if cfgFile != \u0026#34;\u0026#34; { viper.SetConfigFile(cfgFile) } else { home, err := homedir.Dir() if err != nil { fmt.Println(err) os.Exit(1) } viper.AddConfigPath(home) viper.SetConfigName(\u0026#34;.cobra_test\u0026#34;) } if err := viper.ReadInConfig(); err != nil { fmt.Println(\u0026#34;Can\u0026#39;t read config:\u0026#34;, err) os.Exit(1) } } 传递给 cobra.OnInitialize() 的函数 initConfig 函数将在调用命令的 Execute 方法时运行。\n为了展示使用 Cobra 处理配置的效果，需要修改 rootCmd.Run 函数的打印代码：\n1 2 3 4 5 6 7 8 9 10 11 var rootCmd = \u0026amp;cobra.Command{ Use: \u0026#34;hugo\u0026#34;, Run: func(cmd *cobra.Command, args []string) { fmt.Println(\u0026#34;run hugo...\u0026#34;) fmt.Printf(\u0026#34;Verbose: %v\\n\u0026#34;, Verbose) fmt.Printf(\u0026#34;Source: %v\\n\u0026#34;, Source) fmt.Printf(\u0026#34;Region: %v\\n\u0026#34;, Region) fmt.Printf(\u0026#34;Author: %v\\n\u0026#34;, viper.Get(\u0026#34;author\u0026#34;)) fmt.Printf(\u0026#34;Config: %v\\n\u0026#34;, viper.AllSettings()) }, } 提供 config.yaml 配置文件内容如下：\n1 2 3 4 5 password: 123456 server: ip: 10.0.0.1 port: 8080 username: arlettebrook 现在重新编译并运行 hugo 命令：\n1 2 3 4 5 6 7 8 $ go run main.go -r test-rergion run hugo... Verbose: false Source: Region: test-rergion Author: YOUR NAME Config: map[author:YOUR NAME password:123456 server:map[ip:10.0.0.1 port:8080] username:arlettebro ok] 注意事项：viper读取配置文件若根据文件名进行扫描，当文件名相同，后缀不同时，谁先扫到就用谁，在根据指定的类型进行解析。如果没有指定类型，解析的是什么类型，就是什么类型，但在最后保存时，需要指定具体的类型，不然保存不了，指定了类型就可以。\n笔记：Cobra 同时支持 pflag 和 Viper 两个库，实际上这三个库出自同一作者 spf13。\n# 参数验证 在执行命令行程序时，我们可能需要对命令参数进行合法性验证，cobra.Command 的 Args 属性提供了此功能。\nArgs 属性类型为一个函数：func(cmd *Command, args []string) error，可以用来验证参数。\nCobra 内置了以下验证函数：\nNoArgs：如果存在任何命令参数，该命令将报错。 ArbitraryArgs：该命令将接受任意参数。 OnlyValidArgs：如果有任何命令参数不在 Command 的 ValidArgs 字段中，该命令将报错。 MinimumNArgs(int)：如果没有至少 N 个命令参数，该命令将报错。 MaximumNArgs(int)：如果有超过 N 个命令参数，该命令将报错。 ExactArgs(int)：如果命令参数个数不为 N，该命令将报错。 ExactValidArgs(int)：如果命令参数个数不为 N，或者有任何命令参数不在 Command 的 ValidArgs 字段中，该命令将报错。 RangeArgs(min, max)：如果命令参数的数量不在预期的最小数量 min 和最大数量 max 之间，该命令将报错。 内置验证函数用法如下：\n1 2 3 4 5 6 7 var versionCmd = \u0026amp;cobra.Command{ Use: \u0026#34;version\u0026#34;, Run: func(cmd *cobra.Command, args []string) { fmt.Println(\u0026#34;Hugo Static Site Generator v0.9 -- HEAD\u0026#34;) }, Args: cobra.MaximumNArgs(2), // 使用内置的验证函数，位置参数多于 2 个则报错 } 重新编译并运行 hugo 命令：\n1 2 3 4 5 6 7 8 # 编译 $ go build -o hugo # 两个命令参数满足验证函数的要求 $ ./hugo version a b Hugo Static Site Generator v0.9 -- HEAD # 超过两个参数则报错 $ ./hugo version a b c Error: accepts at most 2 arg(s), received 3 当然，我们也可以自定义验证函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 var printCmd = \u0026amp;cobra.Command{ Use: \u0026#34;print [OPTIONS] [COMMANDS]\u0026#34;, Run: func(cmd *cobra.Command, args []string) { fmt.Println(\u0026#34;run print...\u0026#34;) // 命令行位置参数列表：例如执行 `hugo print a b c d` 将得到 [a b c d] fmt.Printf(\u0026#34;args: %v\\n\u0026#34;, args) }, // 使用自定义验证函数 Args: func(cmd *cobra.Command, args []string) error { if len(args) \u0026lt; 1 { return errors.New(\u0026#34;requires at least one arg\u0026#34;) } if len(args) \u0026gt; 4 { return errors.New(\u0026#34;the number of args cannot exceed 4\u0026#34;) } if args[0] != \u0026#34;a\u0026#34; { return errors.New(\u0026#34;first argument must be \u0026#39;a\u0026#39;\u0026#34;) } return nil }, } 重新编译并运行 hugo 命令：\n1 2 3 4 5 6 7 8 9 10 11 12 # 编译 $ go build -o hugo # 1~4 个参数满足条件 $ ./hugo print a b c d run print... args: [a b c d] # 没有参数则报错 $ ./hugo print Error: requires at least one arg # 第一个参数不满足验证函数逻辑，也会报错 $ ./hugo print x Error: first argument must be \u0026#39;a\u0026#39; # Hooks 在执行 Run 函数前后，我么可以执行一些钩子函数，其作用和执行顺序如下：\nPersistentPreRun：在 PreRun 函数执行之前执行，对此命令的子命令同样生效。 PreRun：在 Run 函数执行之前执行。 Run：执行命令时调用的函数，用来编写命令的业务逻辑。 PostRun：在 Run 函数执行之后执行。 PersistentPostRun：在 PostRun 函数执行之后执行，对此命令的子命令同样生效。 修改 rootCmd 如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 var rootCmd = \u0026amp;cobra.Command{ Use: \u0026#34;hugo\u0026#34;, PersistentPreRun: func(cmd *cobra.Command, args []string) { fmt.Println(\u0026#34;hugo PersistentPreRun\u0026#34;) }, PreRun: func(cmd *cobra.Command, args []string) { fmt.Println(\u0026#34;hugo PreRun\u0026#34;) }, Run: func(cmd *cobra.Command, args []string) { fmt.Println(\u0026#34;run hugo...\u0026#34;) }, PostRun: func(cmd *cobra.Command, args []string) { fmt.Println(\u0026#34;hugo PostRun\u0026#34;) }, PersistentPostRun: func(cmd *cobra.Command, args []string) { fmt.Println(\u0026#34;hugo PersistentPostRun\u0026#34;) }, } 重新编译并运行 hugo 命令：\n1 2 3 4 5 6 7 8 9 # 编译 $ go build -o hugo # 执行 $ ./hugo hugo PersistentPreRun hugo PreRun run hugo... hugo PostRun hugo PersistentPostRun 输出顺序符合预期。\n其中 PersistentPreRun、PersistentPostRun 两个函数对子命令同样生效。\n1 2 3 4 $ ./hugo version hugo PersistentPreRun Hugo Static Site Generator v0.9 -- HEAD hugo PersistentPostRun 以上几个函数都有对应的 \u0026lt;Hooks\u0026gt;E 版本，E 表示 Error，即函数执行出错将会返回 Error，执行顺序不变：\nPersistentPreRunE PreRunE RunE PostRunE PersistentPostRunE 如果定义了 \u0026lt;Hooks\u0026gt;E 函数，则 \u0026lt;Hooks\u0026gt; 函数不会执行。比如同时定义了 Run 和 RunE，则只会执行 RunE，不会执行 Run，其他 Hooks 函数同理。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 var rootCmd = \u0026amp;cobra.Command{ Use: \u0026#34;hugo\u0026#34;, PersistentPreRun: func(cmd *cobra.Command, args []string) { fmt.Println(\u0026#34;hugo PersistentPreRun\u0026#34;) }, PersistentPreRunE: func(cmd *cobra.Command, args []string) error { fmt.Println(\u0026#34;hugo PersistentPreRunE\u0026#34;) return nil }, PreRun: func(cmd *cobra.Command, args []string) { fmt.Println(\u0026#34;hugo PreRun\u0026#34;) }, PreRunE: func(cmd *cobra.Command, args []string) error { fmt.Println(\u0026#34;hugo PreRunE\u0026#34;) return errors.New(\u0026#34;PreRunE err\u0026#34;) }, Run: func(cmd *cobra.Command, args []string) { fmt.Println(\u0026#34;run hugo...\u0026#34;) }, PostRun: func(cmd *cobra.Command, args []string) { fmt.Println(\u0026#34;hugo PostRun\u0026#34;) }, PersistentPostRun: func(cmd *cobra.Command, args []string) { fmt.Println(\u0026#34;hugo PersistentPostRun\u0026#34;) }, } 重新编译并运行 hugo 命令：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 # 编译 $ go build -o hugo # 执行 $ ./hugo hugo PersistentPreRunE hugo PreRunE Error: PreRunE err Usage: hugo [flags] hugo [command] Available Commands: completion Generate the autocompletion script for the specified shell help Help about any command print version Print the version number of Hugo Flags: --author string Author name for copyright attribution (default \u0026#34;YOUR NAME\u0026#34;) -c, --config string config file -h, --help help for hugo -r, --region string AWS region (required) -s, --source string Source directory to read from -v, --verbose verbose output Use \u0026#34;hugo [command] --help\u0026#34; for more information about a command. PreRunE err 可以发现，虽然同时定义了 PersistentPreRun、PersistentPreRunE 两个钩子函数，但只有 PersistentPreRunE 会被执行。\n在执行 PreRunE 时返回了一个错误 PreRunE err，程序会终止运行并打印错误信息。\n如果子命令定义了自己的 Persistent*Run 函数，则不会继承父命令的 Persistent*Run 函数。\n1 2 3 4 5 6 7 8 9 10 11 12 var versionCmd = \u0026amp;cobra.Command{ Use: \u0026#34;version\u0026#34;, PersistentPreRun: func(cmd *cobra.Command, args []string) { fmt.Println(\u0026#34;version PersistentPreRun\u0026#34;) }, PreRun: func(cmd *cobra.Command, args []string) { fmt.Println(\u0026#34;version PreRun\u0026#34;) }, Run: func(cmd *cobra.Command, args []string) { fmt.Println(\u0026#34;Hugo Static Site Generator v0.9 -- HEAD\u0026#34;) }, } 重新编译并运行 hugo 命令：\n1 2 3 4 5 6 7 8 # 编译 $ go build -o hugo # 执行子命令 $ ./hugo version version PersistentPreRun version PreRun Hugo Static Site Generator v0.9 -- HEAD hugo PersistentPostRun 注意事项：cobra.OnInitialize()传入调用命令时执行的函数（可以用来初始化配置）：执行顺序都在Hooks函数的前面。\n# 定义自己的 Help 命令 如果你对 Cobra 自动生成的帮助命令不满意，我们可以自定义帮助命令或模板。\n1 2 3 cmd.SetHelpCommand(cmd *Command) cmd.SetHelpFunc(f func(*Command, []string)) cmd.SetHelpTemplate(s string) Cobra 提供了三个方法来实现自定义帮助命令。\n默认情况下，我们可以使用 hugo help command 语法查看子命令的帮助信息，也可以使用 hugo command -h/--help 查看。\n使用 help 命令查看帮助信息：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 $ ./hugo help version hugo PersistentPreRunE All software has versions. This is Hugo\u0026#39;s Usage: hugo version [flags] Flags: -h, --help help for version Global Flags: --author string Author name for copyright attribution (default \u0026#34;YOUR NAME\u0026#34;) -v, --verbose verbose output hugo PersistentPostRun 使用 -h/--help 查看帮助信息：\n1 2 3 4 5 6 7 8 9 10 11 12 $ ./hugo version -h All software has versions. This is Hugo\u0026#39;s Usage: hugo version [flags] Flags: -h, --help help for version Global Flags: --author string Author name for copyright attribution (default \u0026#34;YOUR NAME\u0026#34;) -v, --verbose verbose output 二者唯一的区别是，使用 help 命令查看帮助信息时会执行初始化函数（这里没有演示，参考）和钩子函数。\n我们可以使用 rootCmd.SetHelpCommand 来控制 help 命令输出，使用 rootCmd.SetHelpFunc 来控制 -h/--help 输出。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 func init() { rootCmd.PersistentFlags().BoolVarP(\u0026amp;Verbose, \u0026#34;verbose\u0026#34;, \u0026#34;v\u0026#34;, false, \u0026#34;Verbose output\u0026#34;) rootCmd.Flags().StringVarP(\u0026amp;Source, \u0026#34;source\u0026#34;, \u0026#34;s\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;Source directory to read from\u0026#34;) rootCmd.Flags().StringVarP(\u0026amp;Region, \u0026#34;region\u0026#34;, \u0026#34;r\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;AWS region (required)\u0026#34;) _ = rootCmd.MarkFlagRequired(\u0026#34;region\u0026#34;) rootCmd.PersistentFlags().StringVar(\u0026amp;Author, \u0026#34;author\u0026#34;, \u0026#34;YOUR NAME\u0026#34;, \u0026#34;Author name for copyright attribution\u0026#34;) _ = viper.BindPFlag(\u0026#34;author\u0026#34;, rootCmd.PersistentFlags().Lookup(\u0026#34;author\u0026#34;)) cobra.OnInitialize(initConfig) rootCmd.Flags().StringVarP(\u0026amp;cfgFile, \u0026#34;config\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;config file\u0026#34;) rootCmd.SetHelpCommand(\u0026amp;cobra.Command{ Use: \u0026#34;help\u0026#34;, Short: \u0026#34;Custom help command\u0026#34;, Hidden: true, Run: func(cmd *cobra.Command, args []string) { fmt.Println(\u0026#34;Custom help command\u0026#34;) }, }) rootCmd.SetHelpFunc(func(command *cobra.Command, strings []string) { fmt.Println(strings) }) } 重新编译并运行 hugo 命令：\n1 2 3 4 5 6 7 8 9 10 11 12 13 # 编译 $ go build -o hugo # 使用 `help` 命令查看帮助信息 $ ./hugo help version hugo PersistentPreRunE Custom help command hugo PersistentPostRun # 使用 `-h` 查看根命令帮助信息 $ ./hugo -h [-h] # 使用 `-h` 查看 version 命令帮助信息 $ ./hugo version -h [version -h] 可以发现，使用 help 命令查看帮助信息输出结果是 rootCmd.SetHelpCommand 中 Run 函数的执行输出。使用 -h 查看帮助信息输出结果是 rootCmd.SetHelpFunc 函数的执行输出，strings 代表的是命令行标志和参数列表。\n现在我们再来测试下 rootCmd.SetHelpTemplate 的作用，它用来设置帮助信息模板，支持标准的 Go Template 语法，自定义模板如下：\n1 2 3 4 5 6 7 8 9 10 rootCmd.SetHelpTemplate(`Custom Help Template: Usage: {{.UseLine}} Description: {{.Short}} Commands: {{- range .Commands}} {{.Name}}: {{.Short}} {{- end}} `) 注意：为了单独测试 cmd.SetHelpTemplate(s string)，我已将上面 rootCmd.SetHelpCommand 和 rootCmd.SetHelpFunc 部分代码注释掉了。\n重新编译并运行 hugo 命令：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # 编译 $ go build -o hugo # 查看帮助 $ ./hugo -h Custom Help Template: Usage: hugo [flags] Description: Hugo is a very fast static site generator Commands: completion: Generate the autocompletion script for the specified shell help: Help about any command print: version: Print the version number of Hugo # 查看子命令帮助 $ ./hugo help version hugo PersistentPreRunE Custom Help Template: Usage: hugo version [flags] Description: Print the version number of Hugo Commands: hugo PersistentPostRun 可以发现，无论使用 help 命令查看帮助信息，还是使用 -h 查看帮助信息，其输出内容都遵循我们自定义的模版格式。\n# 定义自己的 Usage Message 当用户提供无效标志或无效命令时，Cobra 通过向用户显示 Usage 来提示用户如何正确的使用命令。\n例如，当用户输入无效的标志 --demo 时，将得到如下输出：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 $ ./hugo --demo Error: unknown flag: --demo Usage: hugo [flags] hugo [command] Available Commands: completion Generate the autocompletion script for the specified shell help Help about any command print version Print the version number of Hugo Flags: --author string Author name for copyright attribution (default \u0026#34;YOUR NAME\u0026#34;) -c, --config string config file -h, --help help for hugo -s, --source string Source directory to read from -v, --verbose verbose output Use \u0026#34;hugo [command] --help\u0026#34; for more information about a command. unknown flag: --demo 首先程序会报错 Error: unknown flag: --demo，报错后会显示 Usage 信息。\n这个输出格式默认与 help 信息一样，我们也可以进行自定义。Cobra 提供了如下两个方法，来控制输出，具体效果我就不演示了，留给读者自行探索。\n1 2 cmd.SetUsageFunc(f func(*Command) error) cmd.SetUsageTemplate(s string) # 未知命令建议 在我们使用 git 命令时，有一个非常好用的功能，能够对用户输错的未知命令智能提示。\n示例如下：\n1 2 3 4 5 6 7 $ git statu git: \u0026#39;statu\u0026#39; is not a git command. See \u0026#39;git --help\u0026#39;. The most similar commands are status stage stash 当我们输入一个不存在的命令 statu 时，git 会提示命令不存在，并且给出几个最相似命令的建议。\n这个功能非常实用，幸运的是，Cobra 自带了此功能。\n如下，当我们输入一个不存在的命令 vers 时，hugo 会自动给出建议命令 version：\n1 2 3 4 5 6 7 8 9 10 11 $ ./hugo vers Error: unknown command \u0026#34;vers\u0026#34; for \u0026#34;hugo\u0026#34; Did you mean this? version Run \u0026#39;hugo --help\u0026#39; for usage. unknown command \u0026#34;vers\u0026#34; for \u0026#34;hugo\u0026#34; Did you mean this? version 注意⚠️：根据我的实测，要想让此功能生效，Command.TraverseChildren 属性要置为 false。\n如果你想彻底关闭此功能，可以使用如下设置：\n1 cmd.DisableSuggestions = true 或者使用如下设置调整字符串匹配的最小距离：\n1 cmd.SuggestionsMinimumDistance = 1 SuggestionsMinimumDistance 是一个正整数，表示输错的命令与正确的命令最多有几个不匹配的字符（最小距离），才会给出建议。如当值为 1 时，用户输入 hugo versiox 会给出建议，而如果用户输入 hugo versixx 时，则不会给出建议，因为已经有两个字母不匹配 version 了。\n# Shell 补全 本文在讲添加子命令小节时，我们见到过 completion 子命令，可以为指定的 Shell 生成自动补全脚本，现在我们就来讲解它的用法。\n直接执行 hugo completion -h 命令，我们可以查看它支持的几种 Shell 类型 bash、fish、powershell、zsh。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 $ go run main.go completion -h Generate the autocompletion script for tools for the specified shell. See each sub-command\u0026#39;s help for details on how to use the generated script. Usage: tools completion [command] Available Commands: bash Generate the autocompletion script for bash fish Generate the autocompletion script for fish powershell Generate the autocompletion script for powershell zsh Generate the autocompletion script for zsh Flags: -h, --help help for completion Global Flags: --author string Author name for copyright attribution (default \u0026#34;YOUR NAME\u0026#34;) -v, --verbose Verbose output Use \u0026#34;tools completion [command] --help\u0026#34; for more information about a command. 要想知道自己正在使用的 Shell 类型，可以使用如下命令：\n1 2 3 4 $ echo $0 /bin/zsh $ echo $SHELL /bin/zsh 可以发现，我使用的是 zsh，所以我就以 zsh 为例，来演示下 completion 命令补全用法。\n使用 -h/--help 我们可以查看使用说明：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 $ ./hugo completion zsh -h Generate the autocompletion script for the zsh shell. If shell completion is not already enabled in your environment you will need to enable it. You can execute the following once: echo \u0026#34;autoload -U compinit; compinit\u0026#34; \u0026gt;\u0026gt; ~/.zshrc To load completions in your current shell session: source \u0026lt;(hugo completion zsh) To load completions for every new session, execute once: #### Linux: hugo completion zsh \u0026gt; \u0026#34;${fpath[1]}/_hugo\u0026#34; #### macOS: hugo completion zsh \u0026gt; $(brew --prefix)/share/zsh/site-functions/_hugo You will need to start a new shell for this setup to take effect. Usage: hugo completion zsh [flags] Flags: -h, --help help for zsh --no-descriptions disable completion descriptions Global Flags: --author string Author name for copyright attribution (default \u0026#34;YOUR NAME\u0026#34;) -v, --verbose verbose output 根据帮助信息，如果为当前会话提供命令行补全功能，可以使用 source \u0026lt;(hugo completion zsh) 命令来实现。\n如果要让命令行补全功能永久生效，Cobra 则非常贴心的为 Linux 和 macOS 提供了不同命令。\n你可以根据提示选择自己喜欢的方式来实现命令行补全功能。\n我这里只实现为当前会话提供命令行补全功能为例进行演示：\n1 2 3 4 5 6 7 8 9 10 11 # 首先在项目根目录下，安装 hugo 命令行程序，安装后软件存放在 $GOPATH/bin 目录下 $ go install . # 添加命令行补全功能 $ source \u0026lt;(hugo completion zsh) # 现在命令行补全已经生效，只需要输入一个 `v`，然后按下键盘上的 `Tab` 键，命令将自动补全为 `version` $ hugo v # 命令已被自动补全 $ hugo version version PersistentPreRun version PreRun Hugo Static Site Generator v0.9 -- HEAD 其实将命令 source \u0026lt;(hugo completion zsh) 添加到 ~/.zshrc 文件中，也能实现每次进入 zsh 后自动加载 hugo 的命令行补全功能。\n注意：在执行 source \u0026lt;(hugo completion zsh) 前需要将 rootCmd 中的钩子函数内部的 fmt.Println 代码全部注释掉，不然打印内容会被当作命令来执行，将会得到 Error: unknown command \u0026quot;PersistentPreRunE\u0026quot; for \u0026quot;hugo\u0026quot; 类似报错信息，虽然命令行补全功能依然能够生效，但「没有消息才是最好的消息」。\n还有要注意：主命令要与项目名（构建之后的命令）一直，不然也不会自动补全。\n# 生成文档 Cobra 支持生成 Markdown、ReStructured Text、Man Page 三种格式文档。\n这里以生成 Markdown 格式文档为例，来演示下 Cobra 这一强大功能。\n我们可以定义一个标志 md-docs 来决定是否生成文档：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // hugo/cmd/root.go ... import \u0026#34;github.com/spf13/cobra/doc\u0026#34; ... var MarkdownDocs bool func init() { rootCmd.Flags().BoolVarP(\u0026amp;MarkdownDocs, \u0026#34;md-docs\u0026#34;, \u0026#34;m\u0026#34;, false, \u0026#34;gen Markdown docs\u0026#34;) ... } func GenDocs() { if MarkdownDocs { if err := doc.GenMarkdownTree(rootCmd, \u0026#34;./docs/md\u0026#34;); err != nil { fmt.Println(err) os.Exit(1) } } } 在 main.go 中调用 GenDocs() 函数。注意./docs/md路径必须存在。\n1 2 3 4 func main() { cmd.Execute() cmd.GenDocs() } 现在，重新编译并运行 hugo 即可生成文档：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 编译 $ go build -o hugo # 生成文档 $ ./hugo --md-docs ... ... # 会执行root命令的Run函数 # 查看生成的文档 $ tree docs/md docs/md ├── hugo.md ├── hugo_completion.md ├── hugo_completion_bash.md ├── hugo_completion_fish.md ├── hugo_completion_powershell.md ├── hugo_completion_zsh.md ├── hugo_print.md └── hugo_version.md 可以发现，Cobra 不仅为 hugo 命令生成了文档，并且还生成了子命令的文档以及命令行补全的文档。\n# 使用 Cobra 命令创建项目 文章读到这里，我们可以发现，其实 Cobra 项目是遵循一定套路的，目录结构、文件、模板代码都比较固定。\n此时，脚手架工具就派上用场了。Cobra 提供了 cobra-cli 命令行工具，可以通过命令的方式快速创建一个命令行项目。\n安装：\n1 $ go install github.com/spf13/cobra-cli@latest 查看使用帮助：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 $ cobra-cli -h Cobra is a CLI library for Go that empowers applications. This application is a tool to generate the needed files to quickly create a Cobra application. Usage: cobra-cli [command] Available Commands: add Add a command to a Cobra Application completion Generate the autocompletion script for the specified shell help Help about any command init Initialize a Cobra Application Flags: -a, --author string author name for copyright attribution (default \u0026#34;YOUR NAME\u0026#34;) --config string config file (default is $HOME/.cobra.yaml) -h, --help help for cobra-cli -l, --license string name of license for the project --viper use Viper for configuration Use \u0026#34;cobra-cli [command] --help\u0026#34; for more information about a command. 可以发现，cobra-cli 脚手架工具仅提供了少量命令和标志，所以上手难度不大。\n# 初始化模块 要使用 cobra-cli 生成一个项目，首先要手动创建项目根目录并使用 go mod 命令进行初始化。\n假设我们要编写的命令行程序叫作 cob，模块初始化过程如下：\n1 2 3 4 5 6 # 创建项目目录 $ mkdir cob # 进入项目目录 $ cd cob # 初始化模块 $ go mod init github.com/arlettebrook/cob # 初始化命令行程序 有了初始化好的 Go 项目，我们就可以初始化命令行程序了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # 初始化程序 $ cobra-cli init Your Cobra application is ready at ... # 查看生成的项目目录结构 $ tree . . ├── LICENSE ├── cmd │ └── root.go ├── go.mod ├── go.sum └── main.go 2 directories, 5 files # 执行命令行程序 $ go run main.go A longer description that spans multiple lines and likely contains examples and usage of using your application. For example: Cobra is a CLI library for Go that empowers applications. This application is a tool to generate the needed files to quickly create a Cobra application. 使用 cobra-cli 初始化程序非常方便，只需要一个简单的 init 命令即可完成。\n目录结构跟我们手动编写的程序相同，只不过多了一个 LICENSE 文件，用来存放项目的开源许可证。\n通过 go run main.go 执行这个命令行程序，即可打印 rootCmd.Run 的输出结果。\n使用脚手架自动生成的 cob/main.go 文件内容如下：\n1 2 3 4 5 6 7 8 9 10 11 /* Copyright © 2024 NAME HERE \u0026lt;EMAIL ADDRESS\u0026gt; */ package main import \u0026#34;github.com/arlettebrook/cob/cmd\u0026#34; func main() { cmd.Execute() } 自动生成的 cog/cmd/root.go 文件内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 /* Copyright © 2023 NAME HERE \u0026lt;EMAIL ADDRESS\u0026gt; */ package cmd import ( \u0026#34;os\u0026#34; \u0026#34;github.com/spf13/cobra\u0026#34; ) // rootCmd represents the base command when called without any subcommands var rootCmd = \u0026amp;cobra.Command{ Use: \u0026#34;cog\u0026#34;, Short: \u0026#34;A brief description of your application\u0026#34;, Long: `A longer description that spans multiple lines and likely contains examples and usage of using your application. For example: Cobra is a CLI library for Go that empowers applications. This application is a tool to generate the needed files to quickly create a Cobra application.`, // Uncomment the following line if your bare application // has an action associated with it: // Run: func(cmd *cobra.Command, args []string) { }, } // Execute adds all child commands to the root command and sets flags appropriately. // This is called by main.main(). It only needs to happen once to the rootCmd. func Execute() { err := rootCmd.Execute() if err != nil { os.Exit(1) } } func init() { // Here you will define your flags and configuration settings. // Cobra supports persistent flags, which, if defined here, // will be global for your application. // rootCmd.PersistentFlags().StringVar(\u0026amp;cfgFile, \u0026#34;config\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;config file (default is $HOME/.cog.yaml)\u0026#34;) // Cobra also supports local flags, which will only run // when this action is called directly. rootCmd.Flags().BoolP(\u0026#34;toggle\u0026#34;, \u0026#34;t\u0026#34;, false, \u0026#34;Help message for toggle\u0026#34;) } 以上两个文件跟我们手动编写的代码没什么两样，套路完全相同，唯一不同的是每个文件头部都会多出来一个 Copyright 头信息，用来标记代码的 LICENSE。\n# 可选标志 cobra-cli 提供了如下三个标志分别用来设置项目的作者、许可证类型、是否使用 Viper 管理配置。\n1 2 3 $ cobra-cli init --author arlettebrook --license mit --viper Your Cobra application is ready at ... 以上命令我们指定可选标志后对项目进行了重新初始化。\n现在 LICENSE 文件内容不再为空，而是 MIT 协议。\n1 2 3 4 5 The MIT License (MIT) Copyright © 2024 arlettebrook Permission is hereby granted... 并且 Go 文件 Copyright 头信息中作者信息也会被补全。\n1 2 3 4 5 /* Copyright © 2024 arlettebrook ... */ 笔记：cobra-cli 命令内置开源许可证支持 GPLv2、GPLv3、LGPL、AGPL、MIT、2-Clause BSD 或 3-Clause BSD。也可以参考官方文档来指定自定义许可证。\n提示：如果你对开源许可证不熟悉，可以参考我的另一篇文章《Open Source License Introduction》。\n# 添加命令 1 2 3 $ cobra-cli add serve $ cobra-cli add config $ cobra-cli add create -p configCmd --author arlettebrook --license mit --viper 这里分别添加了三个命令 serve、config、create，前两者都是 rootCmd 的子命令，create 命令则通过 -p 'configCmd' 参数指定为 config 的子命令。\n注意⚠️：使用 -p 'configCmd' 标志指定当前命令的父命令时，configCmd 必须是小驼峰命名法，因为 cobra-cli 为 config 生成的命令代码自动命名为 configCmd，而不是 config_cmd 或其他形式，这符合 Go 语言变量命名规范。\n现在命令行程序目录结构如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 $ tree . . ├── LICENSE ├── cmd │ ├── config.go │ ├── create.go │ ├── root.go │ └── serve.go ├── go.mod ├── go.sum └── main.go 2 directories, 8 files 可以使用如下命令执行子命令：\n1 2 $ go run main.go config create create called 其他新添加的命令同理。\n# 使用配置取代标志 如果你不想每次生成或添加命令时都指定选项参数，则可以定义 ~/.cobra.yaml 文件来保存配置信息：\n1 2 3 4 author: arlettebrook \u0026lt;arlettebrook@proton.me\u0026gt; year: 2024 license: MIT useViper: true 再次使用 init 命令初始化程序：\n1 2 $ cobra-cli init Using config file: C:\\Users\\Lenovo\\.cobra.yaml 会提示使用了 ~/.cobra.yaml 配置文件。\n现在 LICENSE 文件内容格式如下：\n1 2 3 4 5 The MIT License (MIT) Copyright © 2024 arlettebrook \u0026lt;arlettebrook@proton.me\u0026gt; ... Go 文件 Copyright 头信息也会包含日期、用户名、用户邮箱。\n1 2 3 4 5 /* Copyright © 2024 arlettebrook \u0026lt;arlettebrook@proton.me\u0026gt; ... */ 如果你不想把配置保存在 ~/.cobra.yaml 中，cobra-cli 还提供了 --config 标志来指定任意目录下的配置文件。\n至此，cobra-cli 的功能我们就都讲解完成了，还是非常方便实用的。\n# 总结 在我们日常开发中，编写命令行程序是必不可少，很多开源软件都具备强大的命令行工具，如 K8s、Docker、Git 等。\n一款复杂的命令行程序通常有上百种使用组合，所以如何组织和编写出好用的命令行程序是很考验开发者功底的，而 Cobra 则为我们开发命令行程序提供了足够的便利。这也是为什么我将其称为命令行框架，而不仅仅是一个 Go 第三方库。\nCobra 功能非常强大，要使用它来编写命令行程序首先要明白三个概念：命令、参数和标志。\nCobra 不仅支持子命令，还能够完美兼容 pflag 和 Viper 包，因为这三个包都是同一个作者开发的。关于标志，Cobra 支持持久标志、本地标志以及将标志标记为必选。Cobra 可以将标志绑定到 Viper，方便使用 viper.Get() 来获取标志的值。对于命令行参数，Cobra 提供了不少验证函数，我们也可以自定义验证函数。\nCobra 还提供了几个 Hooks 函数 PersistentPreRun、PreRun、PostRun、PersistentPostRun，可以分别在执行 Run 前后来处理一段逻辑。\n如果觉得 Cobra 提供的默认帮助信息不能满足需求，我们还可以定义自己的 Help 命令和 Usage Message，非常灵活。\nCobra 还支持未知命令的智能提示功能以及 Shell 自动补全功能，此外，它还支持自动生成 Markdown、ReStructured Text、Man Page 三种格式的文档。这对命令行工具的使用者来说非常友好，还能极大减少开发者的工作量。\n最后，Cobra 的命令行工具 cobra-cli 进一步提高了编写命令行程序的效率，非常推荐使用。\n本文完整 代码 (参考@jianghushinian），欢迎点击查看。\n# 参考 Cobra 官网：https://cobra.dev/ Cobra 源码：https://github.com/spf13/cobra Cobra 文档：https://pkg.go.dev/github.com/spf13/cobra Cobra-CLI 文档：https://github.com/spf13/cobra-cli/blob/main/README.md 原文地址：Go 语言现代命令行框架 Cobra 详解 ","date":"2024-05-02T23:33:49+08:00","permalink":"https://arlettebrook.github.io/p/go%E6%9E%84%E5%BB%BA%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%A8%8B%E5%BA%8F%E4%B9%8B%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93cobra/","title":"Go构建命令行程序之第三方库cobra"},{"content":" 在使用 Go 进行开发的过程中，命令行参数解析是我们经常遇到的需求。尽管 Go 标准库提供了 flag 包用于实现命令行参数解析，但只能满足基本需要，不支持高级特性。于是 Go 社区中出现了一个叫 pflag 的第三方包，功能更加全面且足够强大。在本文中，我们将学习并掌握如何使用 pflag。\n# 特点 pflag 作为 Go 内置 flag 包的替代品，具有如下特点：\n实现了 POSIX/GNU 风格的 –flags。 pflag 与《The GNU C Library》 中「25.1.1 程序参数语法约定」章节中 POSIX 建议语法兼容。 兼容 Go 标准库中的 flag 包。如果直接使用 flag 包定义的全局 FlagSet 对象 CommandLine，则完全兼容；否则当你手动实例化了 FlagSet 对象，这时就需要为每个标志设置一个简短标志（Shorthand）。 # 使用 # 基本用法 安装\n1 go get -u github.com/spf13/pflag 导入\n1 import \u0026#34;github.com/spf13/pflag\u0026#34; 使用\n我们可以像使用 Go 标准库中的 flag 包一样使用 pflag。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/spf13/pflag\u0026#34; ) type host struct { value string } func (h *host) String() string { return h.value } func (h *host) Set(v string) error { h.value = v return nil } func (h *host) Type() string { return \u0026#34;host\u0026#34; } func main() { var ip *int = pflag.Int(\u0026#34;ip\u0026#34;, 1234, \u0026#34;help message for ip\u0026#34;) var port int pflag.IntVar(\u0026amp;port, \u0026#34;port\u0026#34;, 8080, \u0026#34;help message for port\u0026#34;) var h host pflag.Var(\u0026amp;h, \u0026#34;host\u0026#34;, \u0026#34;help message for host\u0026#34;) // 解析命令行参数 pflag.Parse() fmt.Printf(\u0026#34;ip: %d\\n\u0026#34;, *ip) fmt.Printf(\u0026#34;port: %d\\n\u0026#34;, port) fmt.Printf(\u0026#34;host: %+v\\n\u0026#34;, h) fmt.Printf(\u0026#34;NFlag: %v\\n\u0026#34;, pflag.NFlag()) // 返回已设置的命令行标志个数 fmt.Printf(\u0026#34;NArg: %v\\n\u0026#34;, pflag.NArg()) // 返回处理完标志后剩余的参数个数 fmt.Printf(\u0026#34;Args: %v\\n\u0026#34;, pflag.Args()) // 返回处理完标志后剩余的参数列表 fmt.Printf(\u0026#34;Arg(1): %v\\n\u0026#34;, pflag.Arg(1)) // 返回处理完标志后剩余的参数列表中第 i 项 } 以上示例演示的 pflag 用法跟 flag 包用法一致，可以做到二者无缝替换。\n示例分别使用 pflag.Int()、pflag.IntVar()、pflag.Var() 三种不同方式来声明标志。其中 ip 和 port 都是 int 类型标志，host 标志则为自定义的 host 类型，它实现了 pflag.Value 接口，通过实现接口类型，标志能够支持任意类型，增加灵活性。\n通过 --help/-h 参数查看命令行程序使用帮助：\n1 2 3 4 5 6 7 $ go run main.go --help Usage of ./main: --host host help message for host --ip int help message for ip (default 1234) --port int help message for port (default 8080) pflag: help requested exit status 2 可以发现，帮助信息中的标志位置是经过重新排序的，并不是标志定义的顺序。\n与 flag 包不同的是，pflag 包参数定界符是两个 -，而不是一个 -，在 pflag 中 -- 和 - 具有不同含义，这点稍后会进行介绍。\nip 标志的默认参数为 1234，port 标志的默认参数为 8080。\n注意：在有些终端下执行程序退出后，还会多打印一行 exit status 2，这并不意味着程序没有正常退出，而是因为 --help 意图就是用来查看使用帮助，所以程序在打印使用帮助信息后，主动调用 os.Exit(2) 退出了。\n通过如下方式使用命令行程序：\n1 2 3 4 5 6 7 8 $ go run main.go --ip 1 x y --host localhost a b ip: 1 port: 8080 host: {value:localhost} NFlag: 2 NArg: 4 Args: [x y a b] Arg(1): y ip 标志的默认值已被命令行参数 1 所覆盖，由于没有传递 port 标志，所以打印结果为默认值 8080，host 标志的值也能够被正常打印。\n还有 4 个非选项参数数 x、y、a、b 也都被 pflag 识别并记录了下来。这点比 flag 要强大，在 flag 包中，非选项参数数只能写在所有命令行参数最后，x、y 出现在这里程序是会报错的。\n# 进阶用法 除了像 flag 包一样的用法，pflag 还支持一些独有的用法，以下是用法示例。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;github.com/spf13/pflag\u0026#34; ) type host struct { value string } func (h *host) String() string { return h.value } func (h *host) Set(v string) error { h.value = v return nil } func (h *host) Type() string { return \u0026#34;host\u0026#34; } func main() { flagSet := pflag.NewFlagSet(\u0026#34;test\u0026#34;, pflag.ExitOnError) var ip = flagSet.IntP(\u0026#34;ip\u0026#34;, \u0026#34;i\u0026#34;, 1234, \u0026#34;help message for ip\u0026#34;) var boolVar bool flagSet.BoolVarP(\u0026amp;boolVar, \u0026#34;boolVar\u0026#34;, \u0026#34;b\u0026#34;, true, \u0026#34;help message for boolVar\u0026#34;) var h host flagSet.VarP(\u0026amp;h, \u0026#34;host\u0026#34;, \u0026#34;H\u0026#34;, \u0026#34;help message for host\u0026#34;) flagSet.SortFlags = false parseErr := flagSet.Parse(os.Args[1:]) if parseErr != nil { log.Fatal(\u0026#34;解析命令行参数出错：\u0026#34;, parseErr) } fmt.Printf(\u0026#34;ip: %d\\n\u0026#34;, *ip) fmt.Printf(\u0026#34;boolVar: %t\\n\u0026#34;, boolVar) fmt.Printf(\u0026#34;host: %#v\\n\u0026#34;, h) i, err := flagSet.GetInt(\u0026#34;ip\u0026#34;) fmt.Printf(\u0026#34;i: %d, err: %v\\n\u0026#34;, i, err) } 首先我们通过 pflag.NewFlagSet 自定义了 FlagSet 对象 flagset，之后的标志定义和解析都通过 flagset 来完成。\n前文示例中 pflag.Int() 这种用法，实际上使用的是全局 FlagSet 对象 CommandLine，CommandLine 定义如下：\n1 var CommandLine = NewFlagSet(os.Args[0], ExitOnError) 现在同样使用三种不同方式来声明标志，分别为 flagset.IntP()、flagset.BoolVarP()、flagset.VarP()。不难发现，这三个方法的命名结尾都多了一个 P，它们的能力也得以升级，三个方法都多了一个 shorthand string 参数（flagset.IntP 的第 2 个参数，flagset.BoolVarP 和 flagset.VarP 的第 3 个参数）用来设置简短标志。\n从声明标志的方法名中我们能够总结出一些规律：\npflag.\u0026lt;Type\u0026gt; 类方法名会将标志参数值存储在指针中并返回。 pflag.\u0026lt;Type\u0026gt;Var 类方法名中包含 Var 关键字的，会将标志参数值绑定到第一个指针类型的参数。 pflag.\u0026lt;Type\u0026gt;P、pflag.\u0026lt;Type\u0026gt;VarP 类方法名以 P 结尾的，支持简短标志。 一个完整标志在命令行传参时使用的分界符为 --，而一个简短标志的分界符则为 -。\nflagset.SortFlags = false 作用是禁止打印帮助信息时对标志进行重排序。\n示例最后，使用 flagset.GetInt() 获取参数的值。\n通过 --help/-h 参数查看命令行程序使用帮助：\n1 2 3 4 5 6 7 $ go run main.go --help Usage of test: -i, --ip int help message for ip (default 1234) -b, --boolVar help message for boolVar (default true) -H, --host host help message for host pflag: help requested exit status 2 这次的帮助信息中，标志顺序没有被改变，就是声明的顺序。\n每一个标志都会对应一个简短标志，如 -b 和 --boolVar 是等价的，可以更加方便的设置参数。\n指定如下命令行参数运行示例：\n1 2 3 4 5 $ go run main.go --ip 1 -H localhost --boolVar=false ip: 1 boolVar: false host: main.host{value:\u0026#34;localhost\u0026#34;} i: 1, err: \u0026lt;nil\u0026gt; 通过 --ip 1 使用完整标志指定 ip 参数值。\n通过 -H localhost 使用简短标志指定 host 参数值。\n布尔类型的标志指定参数 --boolVar=false 需要使用等号 = 而非空格。\n# 命令行标志语法 命令行标志遵循如下语法：\n语法 说明 --flag 适用于 bool 类型标志，或具有 NoOptDefVal 属性的标志。 --flag x 适用于非 bool 类型标志，或没有 NoOptDefVal 属性的标志。 --flag=x 适用于 bool 类型标志。 -n 1234/-n=1234/-n1234 简短标志，非 bool 类型且没有 NoOptDefVal 属性，三者等价。 标志解析在终止符 -- 之后停止。\n整数标志接受 1234、0664、0x1234，并且可能为负数。\n布尔标志接受 1, 0, t, f, true, false, TRUE, FALSE, True, False。\nDuration 标志接受任何对 time.ParseDuration 有效的输入。\n# 标志名 Normalize 标准化Normalize\n借助 pflag.NormalizedName 我们能够给标志起一个或多个别名、规范化标志名等。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;github.com/spf13/pflag\u0026#34; ) func normalizeFunc(f *pflag.FlagSet, name string) pflag.NormalizedName { // alias switch name { case \u0026#34;old-flag-name\u0026#34;: name = \u0026#34;new-flag-name\u0026#34; break } // --my-flag == --my_flag == --my.flag from := []string{\u0026#34;-\u0026#34;, \u0026#34;_\u0026#34;} to := \u0026#34;.\u0026#34; for _, sep := range from { name = strings.Replace(name, sep, to, -1) } return pflag.NormalizedName(name) } func main() { flagSet := pflag.NewFlagSet(\u0026#34;test\u0026#34;, pflag.ExitOnError) var ip = flagSet.IntP(\u0026#34;new-flag-name\u0026#34;, \u0026#34;i\u0026#34;, 1234, \u0026#34;help message for new-flag-name\u0026#34;) var myFlag = flagSet.IntP(\u0026#34;my-flag\u0026#34;, \u0026#34;m\u0026#34;, 1234, \u0026#34;help message for my-flag\u0026#34;) flagSet.SetNormalizeFunc(normalizeFunc) err := flagSet.Parse(os.Args[1:]) if err != nil { log.Fatal(\u0026#34;命令行参数解析失败：\u0026#34;, err) } fmt.Printf(\u0026#34;ip: %d\\n\u0026#34;, *ip) fmt.Printf(\u0026#34;myFlag: %d\\n\u0026#34;, *myFlag) } 要使用 pflag.NormalizedName，我们需要创建一个函数 normalizeFunc，然后将其通过 flagset.SetNormalizeFunc(normalizeFunc) 注入到 flagset 使其生效。\n在 normalizeFunc 函数中，我们给 new-flag-name 标志起了一个别名 old-flag-name。\n另外，还对标志名进行了规范化处理，带有 - 和 _ 分割符的标志名，会统一规范化成以 . 作为分隔符的标志名。\n使用示例如下：\n1 2 3 4 5 6 7 8 9 10 11 $ go run pflag.go --old-flag-name 2 --my-flag 200 ip: 2 myFlag: 200 $ go run pflag.go --new-flag-name 3 --my_flag 300 ip: 3 myFlag: 300 $ go run pflag.go --new-flag_name 2 --my.flag 200 ip: 2 myFlag: 200 # NoOptDefVal NoOptDefVal 是 no option default values 的简写。\n创建标志后，可以为标志设置 NoOptDefVal 属性，如果标志具有 NoOptDefVal 属性并且在命令行上设置了标志而没有参数选项，则标志将设置为 NoOptDefVal 指定的值。\n如下示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/spf13/pflag\u0026#34; ) func main() { var ip = pflag.IntP(\u0026#34;flagName\u0026#34;, \u0026#34;f\u0026#34;, 1234, \u0026#34;help message\u0026#34;) pflag.Lookup(\u0026#34;flagName\u0026#34;).NoOptDefVal = \u0026#34;4321\u0026#34; pflag.Parse() fmt.Println(*ip) } 不同参数结果如下：\n命令行参数 结果值 –flagname=1357 ip=1357 –flagname ip=4321 [nothing] ip=1234 1 2 3 4 5 var ip = pflag.BoolP(\u0026#34;flagName\u0026#34;, \u0026#34;f\u0026#34;, false, \u0026#34;help message\u0026#34;) //pflag.Lookup(\u0026#34;flagName\u0026#34;).NoOptDefVal = \u0026#34;false\u0026#34; pflag.Parse() fmt.Println(*ip) bool类型的NoOptDefValue默认值是true，可以修改为false\n1 2 $ go run main.go -f true # 弃用/隐藏标志 使用 flags.MarkDeprecated 可以弃用一个标志，使用 flags.MarkShorthandDeprecated 可以弃用一个简短标志，使用 flags.MarkHidden 可以隐藏一个标志。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;github.com/spf13/pflag\u0026#34; ) func main() { flags := pflag.NewFlagSet(\u0026#34;test\u0026#34;, pflag.ExitOnError) var ip = flags.IntP(\u0026#34;ip\u0026#34;, \u0026#34;i\u0026#34;, 1234, \u0026#34;help message for ip\u0026#34;) var boolVar bool flags.BoolVarP(\u0026amp;boolVar, \u0026#34;boolVar\u0026#34;, \u0026#34;b\u0026#34;, true, \u0026#34;help message for boolVar\u0026#34;) var h string flags.StringVarP(\u0026amp;h, \u0026#34;host\u0026#34;, \u0026#34;H\u0026#34;, \u0026#34;127.0.0.1\u0026#34;, \u0026#34;help message for host\u0026#34;) // 弃用标志 _ = flags.MarkDeprecated(\u0026#34;ip\u0026#34;, \u0026#34;deprecated\u0026#34;) _ = flags.MarkShorthandDeprecated(\u0026#34;boolVar\u0026#34;, \u0026#34;please use --boolVar only\u0026#34;) // 隐藏标志 _ = flags.MarkHidden(\u0026#34;host\u0026#34;) err := flags.Parse(os.Args[1:]) if err != nil { log.Fatalln(\u0026#34;解析命令行出错了：\u0026#34;, err) } fmt.Printf(\u0026#34;ip: %d\\n\u0026#34;, *ip) fmt.Printf(\u0026#34;boolVar: %t\\n\u0026#34;, boolVar) fmt.Printf(\u0026#34;host: %+v\\n\u0026#34;, h) } 查看使用帮助：\n1 2 3 4 5 $ go run main.go -h Usage of test: --boolVar help message for boolVar (default true) pflag: help requested exit status 2 从打印结果可以发现，弃用标志 ip 时，其对应的简短标志 i 也会跟着被弃用；弃用 boolVar 所对应的简短标志 b 时，boolVar 标志会被保留；host 标志则完全被隐藏。\n指定如下命令行参数运行示例：\n1 2 3 4 5 $ go run main.go --ip 1 --boolVar=false -H localhost Flag --ip has been deprecated, deprecated ip: 1 boolVar: false host: localhost 打印信息中会提示用户 ip 标志已经弃用，不过使用 --ip 1 指定的参数值依然能够生效。\n隐藏的 host 标志使用 -H localhost 指定参数值同样能够生效。\n指定如下命令行参数运行示例：\n1 2 3 4 5 6 $ go run main.go -i 1 -b=false --host localhost Flag --ip has been deprecated, deprecated Flag shorthand -b has been deprecated, please use --boolVar only ip: 1 boolVar: false host: localhost 打印信息中增加了一条简短标志 -b 已被弃用的提示，指定参数值依然生效。\n对于弃用的 ip 标志，使用简短标志形式传惨 -i 1 同样生效。\n# 支持 flag 类型 由于 pflag 对 flag 包兼容，所以可以在一个程序中混用二者：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package main import ( \u0026#34;flag\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/spf13/pflag\u0026#34; ) func main() { var ip *int = pflag.Int(\u0026#34;ip\u0026#34;, 1234, \u0026#34;help message for ip\u0026#34;) var port *int = flag.Int(\u0026#34;port\u0026#34;, 80, \u0026#34;help message for port\u0026#34;) pflag.CommandLine.AddGoFlagSet(flag.CommandLine) pflag.Parse() fmt.Printf(\u0026#34;ip: %d\\n\u0026#34;, *ip) fmt.Printf(\u0026#34;port: %d\\n\u0026#34;, *port) } 其中，ip 标志是使用 pflag.Int() 声明的，port 标志则是使用 flag.Int() 声明的。只需要通过 AddGoFlagSet 方法将 flag.CommandLine 注册到 pflag 中，那么 pflag 就可以使用 flag 中声明的标志集合了。\n运行示例结果如下：\n1 2 3 $ go run main.go --ip 10 --port 8000 ip: 10 port: 8000 # 总结 本文主要介绍了 Go第三方标志包 pflag 的特点及用法。\n首先介绍了 pflag 的基本使用方法，包括声明标志、解析命令行参数、获取标志值等。接着介绍了 pflag 的进阶用法，例如自定义 FlagSet、使用 pflag.\u0026lt;Type\u0026gt;P 方法来支持简短标志。之后又对命令行标志语法进行了讲解，对于布尔值、非布尔值和简短标志，都有各自不同的语法。我们还讲解了如何借助 pflag.NormalizedName 给标志起一个或多个别名、规范化标志名。然后介绍了 NoOptDefVal 的作用和如何弃用/隐藏标志。最后通过示例演示了如何在一个程序中混用 flag 和 pflag。\n彩蛋：不知道你有没有发现，示例中的 ip 标志的名称其实代表的是 int pointer 而非 Internet Protocol Address。ip 标志源自官方示例，不过我顺势而为又声明了 port、host 标志，算是一个程序中的谐音梗 :)。\n# 参考 pflag 源码: https://github.com/spf13/pflag pflag 文档: https://pkg.go.dev/github.com/spf13/pflag 程序参数语法约定: https://www.gnu.org/software/libc/manual/html_node/Argument-Syntax.html Go 命令行参数解析工具 pflag 使用 ","date":"2024-05-02T15:21:19+08:00","permalink":"https://arlettebrook.github.io/p/go%E8%A7%A3%E6%9E%90%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E4%B9%8B%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93pflag/","title":"Go解析命令行参数之第三方库pflag"},{"content":" # 简介 在Go flag库介绍中，我们介绍了flag库。flag库是用于解析命令行选项的标准库。但是flag有几个缺点：\n不显示支持短选项。当然在Go flag库介绍文章中也提到过可以通过将两个选项共享同一个变量迂回实现，但写起来比较繁琐； 选项变量的定义比较繁琐，每个选项都需要根据类型调用对应的Type或TypeVar函数； 默认只支持有限的数据类型，当前只有基本类型bool/int/uint/string和time.Duration； 为了解决这些问题，出现了不少第三方解析命令行选项的库，今天的主角go-flags就是其中一个。第一次看到go-flags库是在阅读pgweb源码的时候。\ngo-flags提供了比标准库flag更多的选项。它利用结构标签（struct tag）和反射提供了一个方便、简洁的接口。它除了基本的功能，还提供了丰富的特性：\n支持短选项（-v）和长选项（–verbose）； 支持短选项合写，如-aux； 同一个选项可以设置多个值； 支持所有的基础类型和 map 类型，甚至是函数； 支持命名空间和选项组； 等等。 上面只是粗略介绍了go-flags的特性，下面我们依次来介绍。\n# 快速开始 学习从使用开始！我们先来看看go-flags的基本使用。\n由于是第三方库，使用前需要安装，执行下面的命令安装：\n1 $ go get -u github.com/jessevdk/go-flags 代码中使用import导入该库：\n1 import \u0026#34;github.com/jessevdk/go-flags\u0026#34; 完整示例代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package main import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/jessevdk/go-flags\u0026#34; ) type Option struct { Verbose []bool `short:\u0026#34;v\u0026#34; long:\u0026#34;verbose\u0026#34; description:\u0026#34;Show verbose debug message\u0026#34;` } func main() { var opt Option _, parseErr := flags.Parse(\u0026amp;opt) if parseErr != nil { var errPtr *flags.Error // 指针类型实现Error接口 if errors.As(parseErr, \u0026amp;errPtr) { // 断言的类型要是指针 if errors.Is(errPtr.Type, flags.ErrHelp) { return } return } panic(parseErr) return } fmt.Println(opt.Verbose) } 使用go-flags的一般步骤：\n定义选项结构，在结构标签中设置选项信息。通过short和long设置短、长选项名字，description设置帮助信息。命令行传参时，短选项前加-，长选项前加--； 声明选项变量； 调用go-flags的解析方法解析。 解析之后会返回两个参数： 第一个：剩余未解析选项，是string类型的切片，一般忽略。 第二个：error对象 对于帮助信息的error对象我们应该忽略。内部会打印这个错误，造成重复。其他错误抛出panic，并退出 flags.Parse()方法默认选项是Default = HelpFlag | PrintErrors | PassDoubleDash:打印帮助信息、打印错误信息、\u0026ndash;后面的参数不解析。 错误信息是封装到flags.Error结构体里面的ErrorType类型l字段里面的。所以需要断言之后再判断。 编译、运行代码（我的环境是 Win10 + Git Bash）：\n1 $ go build -o main.exe main.go 短选项：\n1 2 $ ./main.exe -v [true] 长选项：\n1 2 $ ./main.exe --verbose [true] 由于Verbose字段是切片类型，每次遇到-v或--verbose都会追加一个true到切片中。\n多个短选项：\n1 2 $ ./main.exe -v -v [true true] 多个长选项：\n1 2 $ ./main.exe --verbose --verbose [true true] 短选项 + 长选项：\n1 2 $ ./main.exe -v --verbose -v [true true true] 短选项合写：\n1 2 $ ./main.exe -vvv [true true true] # 基本特性 # 支持丰富的数据类型 go-flags相比标准库flag支持更丰富的数据类型：\n所有的基本类型（包括有符号整数int/int8/int16/int32/int64，无符号整数uint/uint8/uint16/uint32/uint64，浮点数float32/float64，布尔类型bool和字符串string）和它们的切片； map 类型。只支持键为string，值为基础类型的 map； 函数类型。 如果字段是基本类型的切片，基本解析流程与对应的基本类型是一样的。切片类型选项的不同之处在于，遇到相同的选项时，值会被追加到切片中。而非切片类型的选项，后出现的值会覆盖先出现的值。\n下面来看一个示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 package main import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/jessevdk/go-flags\u0026#34; ) type Option struct { IntFlag int `short:\u0026#34;i\u0026#34; long:\u0026#34;int\u0026#34; description:\u0026#34;int flag value\u0026#34;` IntSlice []int `long:\u0026#34;intslice\u0026#34; description:\u0026#34;int slice flag value\u0026#34;` BoolFlag bool `long:\u0026#34;bool\u0026#34; description:\u0026#34;bool flag value\u0026#34;` BoolSlice []bool `long:\u0026#34;boolslice\u0026#34; description:\u0026#34;bool slice flag value\u0026#34;` FloatFlag float64 `long:\u0026#34;float\u0026#34; description:\u0026#34;float64 flag value\u0026#34;` FloatSlice []float64 `long:\u0026#34;floatslice\u0026#34; description:\u0026#34;float64 slice flag value\u0026#34;` StringFlag string `short:\u0026#34;s\u0026#34; long:\u0026#34;string\u0026#34; description:\u0026#34;string flag value\u0026#34;` StringSlice []string `long:\u0026#34;strslice\u0026#34; description:\u0026#34;string slice flag value\u0026#34;` PtrStringSlice []*string `long:\u0026#34;pstrslice\u0026#34; description:\u0026#34;slice of pointer of string flag value\u0026#34;` Call func(string) `long:\u0026#34;call\u0026#34; description:\u0026#34;callback\u0026#34;` IntMap map[string]int `long:\u0026#34;intmap\u0026#34; description:\u0026#34;A map from string to int\u0026#34;` } func main() { var opt Option opt.Call = func(value string) { fmt.Println(\u0026#34;in callback: \u0026#34;, value) } _, parseErr := flags.Parse(\u0026amp;opt) if parseErr != nil { var errPtr *flags.Error if errors.As(parseErr, \u0026amp;errPtr) { return } panic(parseErr) return } fmt.Printf(\u0026#34;int flag: %v\\n\u0026#34;, opt.IntFlag) fmt.Printf(\u0026#34;int slice flag: %v\\n\u0026#34;, opt.IntSlice) fmt.Printf(\u0026#34;bool flag: %v\\n\u0026#34;, opt.BoolFlag) fmt.Printf(\u0026#34;bool slice flag: %v\\n\u0026#34;, opt.BoolSlice) fmt.Printf(\u0026#34;float flag: %v\\n\u0026#34;, opt.FloatFlag) fmt.Printf(\u0026#34;float slice flag: %v\\n\u0026#34;, opt.FloatSlice) fmt.Printf(\u0026#34;string flag: %v\\n\u0026#34;, opt.StringFlag) fmt.Printf(\u0026#34;string slice flag: %v\\n\u0026#34;, opt.StringSlice) fmt.Println(\u0026#34;slice of pointer of string flag: \u0026#34;) for i := 0; i \u0026lt; len(opt.PtrStringSlice); i++ { fmt.Printf(\u0026#34;\\t%d: %v\\n\u0026#34;, i, *opt.PtrStringSlice[i]) } fmt.Printf(\u0026#34;int map: %v\\n\u0026#34;, opt.IntMap) } 基本类型和其切片比较简单，就不过多介绍了。值得留意的是基本类型指针的切片，即上面的PtrStringSlice字段，类型为[]*string。 由于结构中存储的是字符串指针，go-flags在解析过程中遇到该选项会自动创建字符串，将指针追加到切片中。\n运行程序，传入--pstrslice选项：\n1 2 3 4 $ ./main.exe --pstrslice test1 --pstrslice test2 slice of pointer of string flag: 0: test1 1: test2 另外，我们可以在选项中定义函数类型。该函数的唯一要求是有一个字符串类型的参数。解析中每次遇到该选项就会以选项值为参数调用这个函数。 上面代码中，Call函数只是简单的打印传入的选项值。运行代码，传入--call选项：\n1 2 3 $ ./main.exe --call test1 --call test2 in callback: test1 in callback: test2 最后，go-flags还支持 map 类型。虽然限制键必须是string类型，值必须是基本类型，也能实现比较灵活的配置。 map类型的选项值中键-值通过:分隔，如key:value，可设置多个。运行代码，传入--intmap选项：\n1 2 $ ./main.exe --intmap key1:12 --intmap key2:58 int map: map[key1:12 key2:58] # 常用设置 go-flags提供了非常多的设置选项，具体可参见文档。这里重点介绍两个required和default。\nrequired非空时，表示对应的选项必须设置值，否则解析时返回ErrRequired错误。\ndefault用于设置选项的默认值。如果已经设置了默认值，那么required是否设置并不影响，也就是说命令行参数中该选项可以没有。\n看下面示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;github.com/jessevdk/go-flags\u0026#34; ) type Option struct { Required string `short:\u0026#34;r\u0026#34; long:\u0026#34;required\u0026#34; required:\u0026#34;true\u0026#34;` Default string `short:\u0026#34;d\u0026#34; long:\u0026#34;default\u0026#34; default:\u0026#34;default\u0026#34;` } func main() { var opt Option _, err := flags.Parse(\u0026amp;opt) if err != nil { log.Fatal(\u0026#34;Parse error:\u0026#34;, err) } fmt.Println(\u0026#34;required: \u0026#34;, opt.Required) fmt.Println(\u0026#34;default: \u0026#34;, opt.Default) } 运行程序，不传入default选项，Default字段取默认值，不传入required选项，执行报错：\n1 2 3 4 5 6 7 8 9 10 11 $ ./main.exe -r required-data required: required-data default: default $ ./main.exe -d default-data -r required-data required: required-data default: default-data $ ./main.exe the required flag `/r, /required\u0026#39; was not specified 2020/01/09 18:07:39 Parse error:the required flag `/r, /required\u0026#39; was not specified # 高级特性 # 选项分组 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 package main import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;github.com/jessevdk/go-flags\u0026#34; ) type Option struct { GroupBasicOption `group:\u0026#34;basic\u0026#34;` GroupSliceOption `group:\u0026#34;slice\u0026#34;` } type GroupBasicOption struct { IntFlag int `short:\u0026#34;i\u0026#34; long:\u0026#34;intflag\u0026#34; description:\u0026#34;int flag\u0026#34;` BoolFlag bool `short:\u0026#34;b\u0026#34; long:\u0026#34;boolflag\u0026#34; description:\u0026#34;bool flag\u0026#34;` FloatFlag float64 `short:\u0026#34;f\u0026#34; long:\u0026#34;floatflag\u0026#34; description:\u0026#34;float flag\u0026#34;` StringFlag string `short:\u0026#34;s\u0026#34; long:\u0026#34;stringflag\u0026#34; description:\u0026#34;string flag\u0026#34;` } type GroupSliceOption struct { IntSlice int `long:\u0026#34;intslice\u0026#34; description:\u0026#34;int slice\u0026#34;` BoolSlice bool `long:\u0026#34;boolslice\u0026#34; description:\u0026#34;bool slice\u0026#34;` FloatSlice float64 `long:\u0026#34;floatslice\u0026#34; description:\u0026#34;float slice\u0026#34;` StringSlice string `long:\u0026#34;stringslice\u0026#34; description:\u0026#34;string slice\u0026#34;` } func main() { var opt Option p := flags.NewParser(\u0026amp;opt, flags.Default) _, err := p.Parse() if err != nil { var errPtr *flags.Error if errors.As(err, \u0026amp;errPtr) { return } log.Fatal(err) } fmt.Println(opt) } 上面代码中我们将基本类型和它们的切片类型选项拆分到两个结构体中，这样可以使代码看起来更清晰自然，特别是在代码量很大的情况下。 这样做还有一个好处，我们试试用--help运行该程序：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 $ go run main.go --help Usage: C:\\Users\\Lenovo\\AppData\\Local\\Temp\\go-build4141518920\\b001\\exe\\main.exe [OPTIONS] basic: /i, /intflag: int flag /b, /boolflag bool flag /f, /floatflag: float flag /s, /stringflag: string flag slice: /intslice: int slice /boolslice bool slice /floatslice: float slice /stringslice: string slice Help Options: /? Show this help message /h, /help Show this help message 输出的帮助信息中，也是按照我们设定的分组显示了，便于查看。\ngroup标签字段用于分组并命名。当在结构体字段上指定时，使该结构体字段具有给定名称的单独组（可选）\n# 子命令 go-flags支持子命令。我们经常使用的 Go 和 Git 命令行程序就有大量的子命令。例如go version、go build、go run、git status、git commit这些命令中version/build/run/status/commit就是子命令。 使用go-flags定义子命令比较简单：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 package main import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;strconv\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;github.com/jessevdk/go-flags\u0026#34; ) type Option struct { GroupBasicOption `group:\u0026#34;Basic\u0026#34;` GroupSliceOption `group:\u0026#34;Slice\u0026#34;` MathCommand `command:\u0026#34;math\u0026#34;` Call func(int) `long:\u0026#34;call\u0026#34; description:\u0026#34;callback\u0026#34;` } type GroupBasicOption struct { IntFlag int `short:\u0026#34;i\u0026#34; long:\u0026#34;intflag\u0026#34; description:\u0026#34;int flag\u0026#34;` BoolFlag bool `short:\u0026#34;b\u0026#34; long:\u0026#34;boolflag\u0026#34; description:\u0026#34;bool flag\u0026#34;` FloatFlag float64 `short:\u0026#34;f\u0026#34; long:\u0026#34;floatflag\u0026#34; description:\u0026#34;float flag\u0026#34;` StringFlag string `short:\u0026#34;s\u0026#34; long:\u0026#34;stringflag\u0026#34; description:\u0026#34;string flag\u0026#34;` } type GroupSliceOption struct { IntSlice int `long:\u0026#34;intslice\u0026#34; description:\u0026#34;int slice\u0026#34;` BoolSlice bool `long:\u0026#34;boolslice\u0026#34; description:\u0026#34;bool slice\u0026#34;` FloatSlice float64 `long:\u0026#34;floatslice\u0026#34; description:\u0026#34;float slice\u0026#34;` StringSlice string `long:\u0026#34;stringslice\u0026#34; description:\u0026#34;string slice\u0026#34;` } type MathCommand struct { Op string `long:\u0026#34;op\u0026#34; description:\u0026#34;operation to execute\u0026#34;` Args []string Result int64 } func (m *MathCommand) Execute(args []string) error { // 注意，不能使用乘法符号*和除法符号/，它们都不可识别。 if m.Op != \u0026#34;+\u0026#34; \u0026amp;\u0026amp; m.Op != \u0026#34;-\u0026#34; \u0026amp;\u0026amp; m.Op != \u0026#34;*\u0026#34; \u0026amp;\u0026amp; m.Op != \u0026#34;/\u0026#34; { return errors.New(\u0026#34;invalid op\u0026#34;) } for _, arg := range args { num, err := strconv.ParseInt(arg, 10, 64) if err != nil { return err } // 只实现了加的功能 m.Result += num } m.Args = args return nil } func main() { var opt Option opt.Call = func(i int) { fmt.Println(i) } //_, errParse := flags.Parse(\u0026amp;opt) _, errParse := flags.NewParser(\u0026amp;opt, flags.HelpFlag|flags.PassDoubleDash).Parse() if errParse != nil { var p *flags.Error if errors.As(errParse, \u0026amp;p) { /*if errors.Is(p.Type, flags.ErrHelp) { os.Exit(0) }*/ switch { case errors.Is(p.Type, flags.ErrHelp): fmt.Println(p.Message) os.Exit(0) case errors.Is(p.Type, flags.ErrCommandRequired): default: log.Fatal(p.Message) } } else { log.Fatal(errParse) } } fmt.Println(opt) fmt.Printf(\u0026#34;The result of %s is %d\u0026#34;, strings.Join(opt.MathCommand.Args, opt.MathCommand.Op), opt.MathCommand.Result) } 子命令必须实现go-flags定义的Commander接口：\n1 2 3 type Commander interface { Execute(args []string) error } command结构体标签字段：当在结构体字段上指定时，使该结构体字段具有给定名称的（子）命令\n解析命令行时，如果遇到不是以-或--开头的参数，go-flags会尝试将其解释为子命令名。子命令的名字通过在结构标签中使用command指定。 子命令后面的参数都将作为子命令的参数，子命令也可以有选项。\n上面代码中，我们实现了一个可以计算任意个整数的加、减、乘、除子命令math。\n接下来看看如何使用：\n1 2 3 $ go run main.go math --op + 1 2 3 {{0 false 0 } {0 false 0 } {+ [1 2 3] 6} 0x6809a0} The result of 1+2+3 is 6 注意，不能使用乘法符号*和除法符号/，它们都不可识别。\n# 其他 go-flags库还有很多有意思的特性，例如支持 Windows 选项格式（/v和/verbose）、从环境变量中读取默认值、从 ini 文件中读取默认设置等等。大家有兴趣可以自行去研究~\n# 参考 go-flagsGoDoc 文档 Go 每日一库之 go-flags ","date":"2024-05-01T21:50:22+08:00","permalink":"https://arlettebrook.github.io/p/go%E8%A7%A3%E6%9E%90%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E4%B9%8B%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93go-flags/","title":"Go解析命令行参数之第三方库go-flags"},{"content":" zap 是由 Uber 公司开源的一款 Go 日志库，就像它的命名一样，zap 以快著称。官方 GitHub 仓库中只用一句话来概括 zap：「在 Go 中进行快速、结构化、分级的日志记录」。这句话简单明了的概括了 zap 的核心特性，今天我们就来介绍下 zap 日志库的基本使用和高级特性，以及如何在实际应用程序中使用，来提高应用程序的可靠性。\n# 特点 zap 具有如下特点：\n快，非常快，这也是 zap 最显著的特点。速度快的原因是 zap 避免使用 interface{} 和反射，并且使用 sync.Pool 减少堆内存分配。在 zap 面前 Logrus 的执行速度只有被吊打的份，你可以在官方 GitHub 仓库中看到 zap 与不同日志库的速度对比。 支持结构化日志记录。这是一个优秀的日志库必备功能。 支持七种日志级别：Debug、Info、Warn、Error、DPanic、Panic、Fatal，其中 DPanic 是指在开发环境下（development）记录日志后会进行 panic。 支持输出调用堆栈。 支持 Hooks 机制。 # 使用 # 基本使用 先安装go get -u go.uber.org/zap\n基本使用如下：\nzap库的使用与其他的日志库非常相似。先创建一个logger，然后调用各个级别的方法记录日志（Debug/Info/Warn/Error/）。zap提供了几个快速创建logger的方法，zap.NewExample()、zap.NewDevelopment()、zap.NewProduction()，还有高度定制化的创建方法zap.New()。创建前 3 个logger时，zap会使用一些预定义的设置，它们的使用场景也有所不同。Example适合用在测试代码中，Development在开发环境中使用，Production用在生成环境。\nzap底层 API 可以设置缓存，所以一般使用defer logger.Sync()将缓存同步到文件中。刷新缓存，确保日志输出。\n由于fmt.Printf之类的方法大量使用interface{}和反射，会有不少性能损失，并且增加了内存分配的频次。zap为了提高性能、减少内存分配次数，没有使用反射，而且默认的Logger只支持强类型的、结构化的日志。必须使用zap提供的方法记录字段。zap为 Go 语言中所有的基本类型和其他常见类型都提供了方法。这些方法的名称也比较好记忆，zap.Type（Type为bool/int/uint/float64/complex64/time.Time/time.Duration/error等）就表示该类型的字段，zap.Typep以p结尾表示该类型指针的字段，zap.Types以s结尾表示该类型切片的字段。如：\nzap.Bool(key string, val bool) Field：bool字段 zap.Boolp(key string, val *bool) Field：bool指针字段； zap.Bools(key string, val []bool) Field：bool切片字段。 当然也有一些特殊类型的字段：\nzap.Any(key string, value interface{}) Field：任意类型的字段； zap.Binary(key string, val []byte) Field：二进制串的字段。 当然，每个字段都用方法包一层用起来比较繁琐。zap也提供了便捷的方法SugarLogger，可以使用printf格式符的方式。调用logger.Sugar()即可创建SugaredLogger。SugaredLogger的使用比Logger简单，只是性能比Logger低 50% 左右，可以用在非热点函数中。调用SugarLogger以f结尾的方法与fmt.Printf没什么区别，如例子中的Infof。同时SugarLogger还支持以w结尾的方法，这种方式不需要先创建字段对象，直接将字段名和值依次放在参数中即可，如例子中的Infow。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; \u0026#34;go.uber.org/zap\u0026#34; ) func main() { // 生产环境 fmt.Println(\u0026#34;------生产环境------\u0026#34;) { logger, _ := zap.NewProduction() defer logger.Sync() // 刷新 buffer，保证日志最终会被输出 url := \u0026#34;https://arlettebrook.github.io/\u0026#34; logger.Info(\u0026#34;production failed to fetch URL\u0026#34;, zap.String(\u0026#34;url\u0026#34;, url), // 因为没有使用 interface{} 和反射机制，所以需要指定具体类型 zap.Int(\u0026#34;attempt\u0026#34;, 3), zap.Duration(\u0026#34;backoff\u0026#34;, time.Second), ) } // 开发环境 fmt.Println(\u0026#34;------开发环境------\u0026#34;) { logger, _ := zap.NewDevelopment() defer logger.Sync() url := \u0026#34;https://arlettebrook.github.io/\u0026#34; logger.Debug(\u0026#34;development failed to fetch URL\u0026#34;, zap.String(\u0026#34;url\u0026#34;, url), zap.Int(\u0026#34;attempt\u0026#34;, 3), zap.Duration(\u0026#34;backoff\u0026#34;, time.Second), ) } // 测试环境 fmt.Println(\u0026#34;------测试环境------\u0026#34;) { logger := zap.NewExample() defer logger.Sync() url := \u0026#34;https://arlettebrook.github.io/\u0026#34; logger.Info(\u0026#34;failed to fetch URL\u0026#34;, zap.String(\u0026#34;url\u0026#34;, url), zap.Int(\u0026#34;attempt\u0026#34;, 3), zap.Duration(\u0026#34;backoff\u0026#34;, time.Second), ) fmt.Println(\u0026#34;------sugaredLogger------\u0026#34;) sugar := logger.Sugar() sugar.Infow(\u0026#34;failed to fetch URL\u0026#34;, \u0026#34;url\u0026#34;, url, \u0026#34;attempt\u0026#34;, 3, \u0026#34;backoff\u0026#34;, time.Second, ) sugar.Infof(\u0026#34;Failed to fetch URL: %s\u0026#34;, url) } } zap 针对生产环境、开发环境以及测试环境提供了不同的函数来创建 Logger 对象。\n如果想在日志后面追加 key-value，则需要根据 value 的数据类型使用 zap.String、zap.Int 等方法实现。这一点在使用上显然不如 Logrus 等其他日志库来的方便，但这也是 zap 速度快的原因之一，zap 内部尽量避免使用 interface{} 和反射来提高代码执行效率。\n记录日志的 logger.Xxx 方法签名如下：\n1 func (log *Logger) Info(msg string, fields ...Field) 其中 fields 是 zapcore.Field 类型，用来存储 key-value，并记录 value 类型，不管是 zap.String 还是 zap.Int 底层都是 zapcore.Field 类型来记录的。zap 为每一种 Go 的内置类型都定义了对应的 zap.Xxx 方法，甚至还实现 zap.Any() 来支持 interface{}。\n执行以上代码，控制台得到如下输出：\n1 2 3 4 5 6 7 8 9 10 11 12 13 ------生产环境------ {\u0026#34;level\u0026#34;:\u0026#34;info\u0026#34;,\u0026#34;ts\u0026#34;:1714375211.8196504,\u0026#34;caller\u0026#34;:\u0026#34;learn/main.go:18\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;production failed to fe tch URL\u0026#34;,\u0026#34;url\u0026#34;:\u0026#34;https://arlettebrook.github.io/\u0026#34;,\u0026#34;attempt\u0026#34;:3,\u0026#34;backoff\u0026#34;:1} ------开发环境------ 2024-04-29T15:20:11.820+0800 DEBUG learn/main.go:32 development failed to fetch URL {\u0026#34; url\u0026#34;: \u0026#34;https://arlettebrook.github.io/\u0026#34;, \u0026#34;attempt\u0026#34;: 3, \u0026#34;backoff\u0026#34;: \u0026#34;1s\u0026#34;} ------测试环境------ {\u0026#34;level\u0026#34;:\u0026#34;info\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;failed to fetch URL\u0026#34;,\u0026#34;url\u0026#34;:\u0026#34;https://arlettebrook.github.io/\u0026#34;,\u0026#34;attempt\u0026#34;:3,\u0026#34;b ackoff\u0026#34;:\u0026#34;1s\u0026#34;} ------sugaredLogger------ {\u0026#34;level\u0026#34;:\u0026#34;info\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;failed to fetch URL\u0026#34;,\u0026#34;url\u0026#34;:\u0026#34;https://arlettebrook.github.io/\u0026#34;,\u0026#34;attempt\u0026#34;:3,\u0026#34;b ackoff\u0026#34;:\u0026#34;1s\u0026#34;} {\u0026#34;level\u0026#34;:\u0026#34;info\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;Failed to fetch URL: https://arlettebrook.github.io/\u0026#34;} 可以发现，通过 zap.NewProduction() 创建的日志对象输出格式为 JSON，而通过 zap.NewDevelopment() 创建的日志对象输出格式为 Text，日志后面追加的 key-value 会被转换成 JSON。并且，两者输出的字段内容也略有差异，如生产环境日志输出的时间格式为 Unix epoch 利于程序解析，而开发环境日志输出的时间格式为 ISO8601 更利于人类阅读。测试环境没有文件行号、堆栈跟踪信息以及时间，格式为JSON。对应的sugar都是是一样的。\n导致以上这些差异的原因是配置不同，我们来看下 zap.NewProduction 和 zap.NewDevelopment 的代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 func NewProduction(options ...Option) (*Logger, error) { return NewProductionConfig().Build(options...) } func NewProductionConfig() Config { return Config{ Level: NewAtomicLevelAt(InfoLevel), Development: false, Sampling: \u0026amp;SamplingConfig{ Initial: 100, Thereafter: 100, }, Encoding: \u0026#34;json\u0026#34;, EncoderConfig: NewProductionEncoderConfig(), OutputPaths: []string{\u0026#34;stderr\u0026#34;}, ErrorOutputPaths: []string{\u0026#34;stderr\u0026#34;}, } } func NewDevelopment(options ...Option) (*Logger, error) { return NewDevelopmentConfig().Build(options...) } func NewDevelopmentConfig() Config { return Config{ Level: NewAtomicLevelAt(DebugLevel), Development: true, Encoding: \u0026#34;console\u0026#34;, EncoderConfig: NewDevelopmentEncoderConfig(), OutputPaths: []string{\u0026#34;stderr\u0026#34;}, ErrorOutputPaths: []string{\u0026#34;stderr\u0026#34;}, } } 可以看到，两者在实现思路上是一样的，都是先创建一个配置对象 zap.Config，然后再调用配置对象的 Build 方法来构建 Logger。\nzap.Config 定义如下：\n1 2 3 4 5 6 7 8 9 10 11 12 type Config struct { Level AtomicLevel `json:\u0026#34;level\u0026#34; yaml:\u0026#34;level\u0026#34;` Development bool `json:\u0026#34;development\u0026#34; yaml:\u0026#34;development\u0026#34;` DisableCaller bool `json:\u0026#34;disableCaller\u0026#34; yaml:\u0026#34;disableCaller\u0026#34;` DisableStacktrace bool `json:\u0026#34;disableStacktrace\u0026#34; yaml:\u0026#34;disableStacktrace\u0026#34;` Sampling *SamplingConfig `json:\u0026#34;sampling\u0026#34; yaml:\u0026#34;sampling\u0026#34;` Encoding string `json:\u0026#34;encoding\u0026#34; yaml:\u0026#34;encoding\u0026#34;` EncoderConfig zapcore.EncoderConfig `json:\u0026#34;encoderConfig\u0026#34; yaml:\u0026#34;encoderConfig\u0026#34;` OutputPaths []string `json:\u0026#34;outputPaths\u0026#34; yaml:\u0026#34;outputPaths\u0026#34;` ErrorOutputPaths []string `json:\u0026#34;errorOutputPaths\u0026#34; yaml:\u0026#34;errorOutputPaths\u0026#34;` InitialFields map[string]interface{} `json:\u0026#34;initialFields\u0026#34; yaml:\u0026#34;initialFields\u0026#34;` } 每个配置项说明如下：\nLevel: 日志级别。 Development: 是否为开发模式。 DisableCaller: 禁用调用信息，值为 true 时，日志中将不再显示记录日志时所在的函数调用文件名和行号。 DisableStacktrace: 禁用堆栈跟踪捕获。 Sampling: 采样策略配置，单位为每秒，作用是限制日志在每秒内的输出数量，以此来防止全局的 CPU 和 I/O 负载过高。 Encoding: 指定日志编码器，目前支持 json 和 console。 EncoderConfig: 编码配置，决定了日志字段格式。 OutputPaths: 配置日志输出位置，URLs 或文件路径，可配置多个。 ErrorOutputPaths: zap 包内部出现错误的日志输出位置，URLs 或文件路径，可配置多个，默认 os.Stderr。 InitialFields: 初始化字段配置，该配置的字段会以结构化的形式打印在每条日志输出中。 我们再来对比下 NewProductionEncoderConfig() 和 NewDevelopmentEncoderConfig() 这两个配置的不同：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 func NewProductionEncoderConfig() zapcore.EncoderConfig { return zapcore.EncoderConfig{ TimeKey: \u0026#34;ts\u0026#34;, LevelKey: \u0026#34;level\u0026#34;, NameKey: \u0026#34;logger\u0026#34;, CallerKey: \u0026#34;caller\u0026#34;, FunctionKey: zapcore.OmitKey, MessageKey: \u0026#34;msg\u0026#34;, StacktraceKey: \u0026#34;stacktrace\u0026#34;, LineEnding: zapcore.DefaultLineEnding, EncodeLevel: zapcore.LowercaseLevelEncoder, EncodeTime: zapcore.EpochTimeEncoder, EncodeDuration: zapcore.SecondsDurationEncoder, EncodeCaller: zapcore.ShortCallerEncoder, } } func NewDevelopmentEncoderConfig() zapcore.EncoderConfig { return zapcore.EncoderConfig{ // Keys can be anything except the empty string. TimeKey: \u0026#34;T\u0026#34;, LevelKey: \u0026#34;L\u0026#34;, NameKey: \u0026#34;N\u0026#34;, CallerKey: \u0026#34;C\u0026#34;, FunctionKey: zapcore.OmitKey, MessageKey: \u0026#34;M\u0026#34;, StacktraceKey: \u0026#34;S\u0026#34;, LineEnding: zapcore.DefaultLineEnding, EncodeLevel: zapcore.CapitalLevelEncoder, EncodeTime: zapcore.ISO8601TimeEncoder, EncodeDuration: zapcore.StringDurationEncoder, EncodeCaller: zapcore.ShortCallerEncoder, } } 对比来看，两者有很多不同的配置，比如生产环境下 EncodeTime 值为 zapcore.EpochTimeEncoder，开发环境下 EncodeTime 值为 zapcore.ISO8601TimeEncoder。这就是生产环境日志输出的时间格式为 Unix epoch 而开发环境日志输出的时间格式为 ISO8601 的原因。\nzapcore.EncoderConfig 其他几个常用的配置项说明如下：\nMessageKey: 日志信息的键名，默认 msg。 LevelKey: 日志级别的键名，默认 level。 TimeKey: 日志时间的键名。 EncodeLevel: 日志级别的格式，默认为小写，如 info。 除了提供 zap.NewProduction() 和 zap.NewDevelopment() 两个构造函数外，zap 还提供了 zap.NewExample() 来创建一个 Logger 对象，这个方法主要用于测试，这里就不多介绍了。\n# 记录层级关系 前面我们记录的日志都是一层结构，没有嵌套的层级。我们可以使用zap.Namespace(key string) Field构建一个命名空间，后续的Field都记录在此命名空间中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func main() { logger := zap.NewExample() defer logger.Sync() logger.Info(\u0026#34;tracked some metrics\u0026#34;, zap.Namespace(\u0026#34;metrics\u0026#34;), zap.Int(\u0026#34;counter\u0026#34;, 1), ) logger2 := logger.With( zap.Namespace(\u0026#34;metrics\u0026#34;), zap.Int(\u0026#34;counter\u0026#34;, 1), ) logger2.Info(\u0026#34;tracked some metrics\u0026#34;) } 输出：\n1 2 {\u0026#34;level\u0026#34;:\u0026#34;info\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;tracked some metrics\u0026#34;,\u0026#34;metrics\u0026#34;:{\u0026#34;counter\u0026#34;:1}} {\u0026#34;level\u0026#34;:\u0026#34;info\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;tracked some metrices\u0026#34;,\u0026#34;metrics\u0026#34;:{\u0026#34;counter\u0026#34;:1}} 上面我们演示了两种Namespace的用法，一种是直接作为字段传入Debug/Info等方法，一种是调用With()创建一个新的Logger，新的Logger记录日志时总是带上预设的字段。With()方法实际上是创建了一个新的Logger：\n1 2 3 4 5 6 7 8 9 // src/go.uber.org/zap/logger.go func (log *Logger) With(fields ...Field) *Logger { if len(fields) == 0 { return log } l := log.clone() l.core = l.core.With(fields) return l } # 预设日志字段 如果每条日志都要记录一些共用的字段，那么使用zap.Fields(fs ...Field)创建的选项。例如在服务器日志中记录可能都需要记录serverId和serverName：\n1 2 3 4 5 6 7 8 func main() { logger := zap.NewExample(zap.Fields( zap.Int(\u0026#34;serverId\u0026#34;, 90), zap.String(\u0026#34;serverName\u0026#34;, \u0026#34;awesome web\u0026#34;), )) logger.Info(\u0026#34;hello world\u0026#34;) } 输出：\n1 {\u0026#34;level\u0026#34;:\u0026#34;info\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;hello world\u0026#34;,\u0026#34;serverId\u0026#34;:90,\u0026#34;serverName\u0026#34;:\u0026#34;awesome web\u0026#34;} 与logger.with()差不多\n# 给语法加点糖 zap 虽然速度足够快，但是多数情况下，我们并不需要极致的性能，而是想让代码写起来更爽一些。zap 为我们提供了解决方案 —— SugaredLogger。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package main import ( \u0026#34;time\u0026#34; \u0026#34;go.uber.org/zap\u0026#34; ) func main() { logger, _ := zap.NewProduction() defer logger.Sync() url := \u0026#34;https://arlettebrook.github.io/\u0026#34; sugar := logger.Sugar() sugar.Infow(\u0026#34;production failed to fetch URL\u0026#34;, \u0026#34;url\u0026#34;, url, \u0026#34;attempt\u0026#34;, 3, \u0026#34;backoff\u0026#34;, time.Second, ) sugar.Info(\u0026#34;Info\u0026#34;) sugar.Infoln(\u0026#34;Infoln\u0026#34;) sugar.Infof(\u0026#34;Infof: %s\u0026#34;, url) } 通过 logger.Sugar() 方法可以将一个 Logger 对象转换成一个 SugaredLogger 对象。\nSugaredLogger 提供了更人性化的接口，日志中追加 key-value 时不在需要 zap.String(\u0026quot;url\u0026quot;, url) 这种显式指明类型的写法，只需要保证 key 为 string 类型，value 则可以为任意类型，能够减少我们编写的代码量。\n此外，为了满足不同需求，SugaredLogger 提供了四种方式输出日志：sugar.Xxx、sugar.Xxxw、sugar.Xxxf、sugar.Xxxln。\n执行以上代码，控制台得到如下输出：\n1 2 3 4 5 6 {\u0026#34;level\u0026#34;:\u0026#34;info\u0026#34;,\u0026#34;ts\u0026#34;:1714398451.8505704,\u0026#34;caller\u0026#34;:\u0026#34;learn/main.go:15\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;production failed to fe tch URL\u0026#34;,\u0026#34;url\u0026#34;:\u0026#34;https://arlettebrook.github.io/\u0026#34;,\u0026#34;attempt\u0026#34;:3,\u0026#34;backoff\u0026#34;:1} {\u0026#34;level\u0026#34;:\u0026#34;info\u0026#34;,\u0026#34;ts\u0026#34;:1714398451.8511178,\u0026#34;caller\u0026#34;:\u0026#34;learn/main.go:20\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;Info\u0026#34;} {\u0026#34;level\u0026#34;:\u0026#34;info\u0026#34;,\u0026#34;ts\u0026#34;:1714398451.851623,\u0026#34;caller\u0026#34;:\u0026#34;learn/main.go:21\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;Infoln\u0026#34;} {\u0026#34;level\u0026#34;:\u0026#34;info\u0026#34;,\u0026#34;ts\u0026#34;:1714398451.8516397,\u0026#34;caller\u0026#34;:\u0026#34;learn/main.go:22\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;Infof: https://arletteb rook.github.io/\u0026#34;} 我们知道，这种方便的写法是有一定代价的，所以开发中是否需要使用 SugaredLogger 来记录日志，需要根据程序的特点来决定。SugaredLogger 与 Logger 的性能对比同样可以在官方 GitHub 仓库中看到。\n# 定制 Logger 通过查看 zap.NewProduction() 和 zap.NewDevelopment() 两个构造函数源码，我们知道可以使用 zap.Config 对象的 Build 方法创建 Logger 对象。那么我们很容易能够想到，如果要定制 Logger，只需要创建一个定制的 zap.Config 即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 package main import ( \u0026#34;go.uber.org/zap\u0026#34; \u0026#34;go.uber.org/zap/zapcore\u0026#34; ) func newCustomLogger() (*zap.Logger, error) { cfg := zap.Config{ Level: zap.NewAtomicLevelAt(zap.DebugLevel), Development: false, Encoding: \u0026#34;json\u0026#34;, EncoderConfig: zapcore.EncoderConfig{ TimeKey: \u0026#34;time\u0026#34;, LevelKey: \u0026#34;level\u0026#34;, NameKey: \u0026#34;logger\u0026#34;, CallerKey: \u0026#34;\u0026#34;, // 不记录日志调用位置 FunctionKey: zapcore.OmitKey, MessageKey: \u0026#34;message\u0026#34;, LineEnding: zapcore.DefaultLineEnding, EncodeLevel: zapcore.LowercaseLevelEncoder, EncodeTime: zapcore.RFC3339TimeEncoder, EncodeDuration: zapcore.SecondsDurationEncoder, EncodeCaller: zapcore.ShortCallerEncoder, }, OutputPaths: []string{\u0026#34;stdout\u0026#34;, \u0026#34;test.log\u0026#34;}, ErrorOutputPaths: []string{\u0026#34;error.log\u0026#34;}, } return cfg.Build() } func main() { logger, _ := newCustomLogger() defer logger.Sync() // 增加一个 skip 选项，触发 zap 内部 error，将错误输出到 error.log logger = logger.WithOptions(zap.AddCallerSkip(100)) logger.Info(\u0026#34;Info msg\u0026#34;) logger.Error(\u0026#34;Error msg\u0026#34;) } 以上代码通过 newCustomLogger 函数创建了一个自定义的 Logger，同样通过先定义一个 zap.Config 然后再调用其 Build 方法来实现。\n配置日志分别输出到标准输出和 test.log 文件，执行以上代码，控制台和 test.log 都会得到如下输出：\n1 2 {\u0026#34;level\u0026#34;:\u0026#34;info\u0026#34;,\u0026#34;time\u0026#34;:\u0026#34;2023-03-19T19:19:18+08:00\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;Info msg\u0026#34;} {\u0026#34;level\u0026#34;:\u0026#34;error\u0026#34;,\u0026#34;time\u0026#34;:\u0026#34;2023-03-19T19:19:18+08:00\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;Error msg\u0026#34;} 另外，我们还通过 logger.WithOptions() 为 Logger 对象增加了一个选项 zap.AddCallerSkip(100)，这个选项的作用是指定在通过调用栈获得行号时跳过的调用深度，因为我们的函数调用栈并不是 100 层，所以会触发 zap 内部错误，zap 会将错误日志输出到 ErrorOutputPaths 配置指定的位置中，即 error.log。\nerror.log 得到的错误日志如下：\n1 2 2023-03-19 11:19:18.438824 +0000 UTC Logger.check error: failed to get caller 2023-03-19 11:19:18.44921 +0000 UTC Logger.check error: failed to get caller # 选项 logger.WithOptions() 支持的选项如下：\nWrapCore(f func(zapcore.Core) zapcore.Core): 使用一个新的 zapcore.Core 替换掉 Logger 内部原有的的 zapcore.Core 属性。 Hooks(hooks ...func(zapcore.Entry) error): 注册钩子函数，用来在日志打印时同时调用注册的钩子函数。 Fields(fs ...Field): 添加公共字段。 ErrorOutput(w zapcore.WriteSyncer): 指定日志组件内部出现异常时的输出位置。 Development(): 将日志记录器设为开发模式，这将使 DPanic 级别日志记录错误后执行 panic()。 AddCaller(): 与 WithCaller(true) 等价。 WithCaller(enabled bool): 指定是否在日志输出内容中增加调用信息，即文件名和行号。 AddCallerSkip(skip int): 指定在通过调用栈获取文件名和行号时跳过的调用深度。 AddStacktrace(lvl zapcore.LevelEnabler): 用来指定某个日志级别及以上级别输出调用堆栈。 IncreaseLevel(lvl zapcore.LevelEnabler): 提高日志级别，如果传入的 lvl 比现有级别低，则不会改变日志级别。 WithFatalHook(hook zapcore.CheckWriteHook): 当出现 Fatal 级别日志时调用的钩子函数。 WithClock(clock zapcore.Clock): 指定日志记录器用来确定当前时间的 zapcore.Clock 对象，默认为 time.Now 的系统时钟。 NewExample()/NewDevelopment()/NewProduction()这 3 个函数可以传入若干类型为zap.Option的选项，从而定制Logger的行为。又一次见到了选项模式！！\nzap提供了丰富的选项供我们选择。\n输出文件名和行号\n调用zap.AddCaller()返回的选项设置输出文件名和行号。但是有一个前提，必须设置配置对象Config中的CallerKey字段。也因此NewExample()不能输出这个信息（它的Config没有设置CallerKey）。\nAddCaller()与zap.WithCaller(true)等价。一般不用\n有时我们稍微封装了一下记录日志的方法，但是我们希望输出的文件名和行号是调用封装函数的位置。这时可以使用zap.AddCallerSkip(skip int)向上跳 1 层。可能会用到。\n输出调用堆栈\n有时候在某个函数处理中遇到了异常情况，因为这个函数可能在很多地方被调用。如果我们能输出此次调用的堆栈，那么分析起来就会很方便。我们可以使用zap.AddStackTrace(lvl zapcore.LevelEnabler)达成这个目的。该函数指定lvl和之上的级别都需要输出调用堆栈：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package main import ( \u0026#34;go.uber.org/zap\u0026#34; \u0026#34;go.uber.org/zap/zapcore\u0026#34; ) func f1() { f2(\u0026#34;hello world\u0026#34;) } func f2(msg string, fields ...zap.Field) { zap.L().Warn(msg, fields...) // zap.L()获取全局logger } func main() { logger, _ := zap.NewDevelopment(zap.AddStacktrace(zapcore.WarnLevel)) defer logger.Sync() zap.ReplaceGlobals(logger) // 替换全局logger f1() } 将zapcore.WarnLevel传入AddStacktrace()，之后Warn()/Error()等级别的日志会输出堆栈，Debug()/Info()这些级别不会。运行结果：\n1 2 3 4 5 6 7 8 9 2024-04-30T10:32:49.798+0800 WARN learn/main.go:13 hello world main.f2 F:/GoProject/learn/main.go:13 main.f1 F:/GoProject/learn/main.go:9 main.main F:/GoProject/learn/main.go:22 runtime.main D:/Go/src/runtime/proc.go:271 很清楚地看到调用路径。\n创建自定义的配置对象，除了在代码中指定配置参数，也可以将这些配置项写入到 JSON 文件中，然后通过 json.Unmarshal 的方式将配置绑定到 zap.Config，可以参考官方示例。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 func main() { rawJSON := []byte(`{ \u0026#34;level\u0026#34;:\u0026#34;debug\u0026#34;, \u0026#34;encoding\u0026#34;:\u0026#34;json\u0026#34;, \u0026#34;outputPaths\u0026#34;: [\u0026#34;stdout\u0026#34;, \u0026#34;server.log\u0026#34;], \u0026#34;errorOutputPaths\u0026#34;: [\u0026#34;stderr\u0026#34;], \u0026#34;initialFields\u0026#34;:{\u0026#34;name\u0026#34;:\u0026#34;dj\u0026#34;}, \u0026#34;encoderConfig\u0026#34;: { \u0026#34;messageKey\u0026#34;: \u0026#34;message\u0026#34;, \u0026#34;levelKey\u0026#34;: \u0026#34;level\u0026#34;, \u0026#34;levelEncoder\u0026#34;: \u0026#34;lowercase\u0026#34; } }`) var cfg zap.Config if err := json.Unmarshal(rawJSON, \u0026amp;cfg); err != nil { panic(err) } logger, err := cfg.Build() if err != nil { panic(err) } defer logger.Sync() logger.Info(\u0026#34;server start work successfully!\u0026#34;) } 上面创建一个输出到标准输出stdout和文件server.log的Logger。观察输出：\n1 {\u0026#34;level\u0026#34;:\u0026#34;info\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;server start work successfully!\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;dj\u0026#34;} # 全局Logger 为了方便使用，zap提供了两个全局的Logger，一个是*zap.Logger，可调用zap.L()获得；另一个是*zap.SugaredLogger，可调用zap.S()获得。需要注意的是，全局的Logger默认并不会记录日志！它是一个无实际效果的Logger。看源码:\n1 2 3 4 5 6 // go.uber.org/zap/global.go var ( _globalMu sync.RWMutex _globalL = NewNop() _globalS = _globalL.Sugar() ) 我们可以使用ReplaceGlobals(logger *Logger) func()将logger设置为全局的Logger，该函数返回一个无参函数，用于恢复全局Logger设置：\n1 2 3 4 5 6 7 8 9 10 11 func main() { zap.L().Info(\u0026#34;global Logger before\u0026#34;) zap.S().Info(\u0026#34;global SugaredLogger before\u0026#34;) logger := zap.NewExample() defer logger.Sync() zap.ReplaceGlobals(logger) zap.L().Info(\u0026#34;global Logger after\u0026#34;) zap.S().Info(\u0026#34;global SugaredLogger after\u0026#34;) } 输出：\n1 2 {\u0026#34;level\u0026#34;:\u0026#34;info\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;global Logger after\u0026#34;} {\u0026#34;level\u0026#34;:\u0026#34;info\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;global SugaredLogger after\u0026#34;} 可以看到在调用ReplaceGlobals之前记录的日志并没有输出。\n# 与标准日志库搭配使用 如果项目一开始使用的是标准日志库log，后面想转为zap。这时不必修改每一个文件。我们可以调用zap.NewStdLog(l *Logger) *log.Logger返回一个标准的log.Logger，内部实际上写入的还是我们之前创建的zap.Logger：\n1 2 3 4 5 6 7 func main() { logger := zap.NewExample() defer logger.Sync() std := zap.NewStdLog(logger) std.Print(\u0026#34;standard logger wrapper\u0026#34;) } 输出：\n1 {\u0026#34;level\u0026#34;:\u0026#34;info\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;standard logger wrapper\u0026#34;} 很方便不是吗？我们还可以使用NewStdLogAt(l *logger, level zapcore.Level) (*log.Logger, error)让标准接口以level级别写入内部的*zap.Logger。\n如果我们只是想在一段代码内使用标准日志库log，其它地方还是使用zap.Logger。可以调用RedirectStdLog(l *Logger) func()。它会返回一个无参函数恢复设置：\n1 2 3 4 5 6 7 8 9 10 func main() { logger := zap.NewExample() defer logger.Sync() undo := zap.RedirectStdLog(logger) log.Print(\u0026#34;redirected standard library\u0026#34;) undo() log.Print(\u0026#34;restored standard library\u0026#34;) } 看前后输出变化：\n1 2 {\u0026#34;level\u0026#34;:\u0026#34;info\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;redirected standard library\u0026#34;} 2020/04/24 22:13:58 restored standard library 当然RedirectStdLog也有一个对应的RedirectStdLogAt以特定的级别调用内部的*zap.Logger方法。\n# 参考 Go 每日一库之 zap zap 源码: https://github.com/uber-go/zap zap 文档: https://pkg.go.dev/go.uber.org/zap Go 第三方 log 库之 zap 使用 如何基于 zap 封装一个更好用的日志库 ","date":"2024-04-29T12:12:52+08:00","permalink":"https://arlettebrook.github.io/p/go%E7%AC%AC%E4%B8%89%E6%96%B9log%E5%BA%93%E4%B9%8Bzap/","title":"Go第三方log库之zap"},{"content":" # 概述 大多数语言都有“依赖”、“包”等概念，Go语言的依赖处理经历了几次变革。\n最早的时候，Go所依赖的所有的第三方库都放在GOPATH这个目录下面。从v1.5开始引入vendor模式，如果项目目录下有vendor目录，那么go工具链会优先使用vendor内的包进行编译、测试等。\n从v1.11开始，引入了Go Modules 作为依赖解决方案，到v1.14宣布Go Modules已经可以用于生产环境，到v1.16版本开始Go Module默认开启。\n# 什么是 Go Modules Go modules 是 Go 语言的依赖解决方案，发布于 Go1.11，成长于 Go1.12，丰富于 Go1.13，正式于 Go1.14 推荐在生产上使用。\nGo Modules使得Go语言开发者能够更方便地管理代码包及其版本，并能够与现有的版本控制工具（如Git、SVN等）集成使用。\n在传统的GOPATH模式中，所有Go代码都必须位于一个全局的GOPATH路径之下，这使得在不同项目中使用不同版本的依赖包变得非常困难。然而，在Go Modules模式下，每个项目都可以独立管理自己的依赖关系，具有更好的兼容性。当使用Go Modules模式后，项目中会自动创建go.mod文件，其中记录了项目所依赖的模块及其版本信息。go.mod是Go语言项目中的模块文件，用于管理项目的依赖关系和版本信息。\nGo Modules也支持语义化版本控制，这意味着开发者可以指定依赖包的版本范围，而不是仅仅依赖最新的版本。这种灵活性有助于确保项目的稳定性和可维护性。\nGo moudles 目前集成在 Go 的工具链中，只要安装了 Go，自然而然也就可以使用 Go moudles 了，而 Go modules 的出现也解决了在 Go1.11 前的几个常见争议问题：\nGo 语言长久以来的依赖管理问题。 “淘汰”现有的 GOPATH 的使用模式。 统一社区中的其它的依赖管理工具（提供迁移功能）。 优势\n首先，研发者能够在任何目录下工作，而不仅仅是在GOPATH指定的目录。 可以安装依赖包的指定版本，而不是只能从master分支安装最新的版本。 可以导入同一个依赖包的多个版本。当我们老项目使用老版本，新项目使用新版本时会非常有用。 要有一个能够罗列当前项目所依赖包的列表。这个的好处是当我们发布项目时不用同时发布所依赖的包。Go能够根据该文件自动下载对应的包。 # GO PATH介绍 安装好go开发环境之后，可以运行go env查看go运行时的环境变量。要修改这些环境变量，可以通过配置环境变量来覆盖默认值(覆盖了就不能通过命令设置)，如临时设置export GO111MODULE=on。或者通过命令go env -w key=value，如go env -w GO111MODULE=on。通过命令修改的环境变量保存在GOENV这个环境变量指向的文件。\n有两个比较重要的环境变量：\nGOROOT：Golang 安装目录的路径，包含编译器程序和系统包，也可以放置三方包（不推荐）。新版本已经不需要配置这个环境变量了，安装了go会自动推断出该变量的值。如果安装之后环境变量中没有$GORROOT/bin,需要手动添加，这样才能直接在命令行中运行go编译程序。 GOPATH：该工作目录，放置编译后二进制和 import 包时的搜索路径，一般有三个目录: bin、pkg、src。并且该环境变量必须手动设置。 bin：用来存放编译后的可执行文件。引入Go modules之后用于存放get install安装的可执行文件。 pkg：存储预编译的目标文件，以加快程序的后续编译速度。引入Go modules之后用于存放第三方包。 src：存储所有.go文件或源代码。在编写 Go 应用程序，程序包和库时，一般会以$GOPATH/src/github.com/foo/bar的路径进行存放。引入Go modules之后用一般不用，go项目可以放在任意目录中，不在是$GOPATH/src 因此在使用 GOPATH 模式下，我们需要将应用代码存放在固定的$GOPATH/src目录下，并且如果执行go get来拉取外部依赖会自动下载并安装到$GOPATH目录下。\n# GOPATH模式的弊端 在 GOPATH 的 $GOPATH/src 下进行 .go 文件或源代码的存储，我们可以称其为 GOPATH 的模式，这个模式拥有一些弊端。\nA. 无版本控制概念. 在执行go get的时候，你无法传达任何的版本信息的期望，也就是说你也无法知道自己当前更新的是哪一个版本，也无法通过指定来拉取自己所期望的具体版本。 B.无法同步一致第三方版本号. 在运行 Go 应用程序的时候，你无法保证其它人与你所期望依赖的第三方库是相同的版本，也就是说在项目依赖库的管理上，你无法保证所有人的依赖版本都一致。 C.无法指定当前项目引用的第三方版本号. 你没办法处理 v1、v2、v3 等等不同版本的引用问题，因为 GOPATH 模式下的导入路径都是一样的，都是github.com/foo/bar。 Go 语言官方从 Go1.11 起开始推进 Go modules（前身vgo，知道即可，不需要深入了解），Go1.13 起不再推荐使用 GOPATH 的使用模式，Go modules 也渐趋稳定，因此新项目也没有必要继续使用GOPATH模式。\n# Go Module 语义化版本规范 Go Module 的设计采用了语义化版本规范，语义化版本规范非常流行且具有指导意义，本文就来聊聊语义化版本规范的设计和在 Go 中的应用。\n# 语义化版本规范 语义化版本规范（SemVer）是由 Gravatars 创办者兼 GitHub 共同创办者 Tom Preston-Werner 所建立，旨在解决 依赖地狱 问题。\n它清楚明了的规定了版本格式、版本号递增规：\n版本格式：采用 X.Y.Z 的格式，X 是主版本号、Y 是次版本号、而 Z 为修订号（即：主版本号.次版本号.修订号），其中 X、Y 和 Z 为非负的整数，且禁止在数字前方补零。\n版本号递增规则：\n主版本号：当做了不兼容的 API 修改。\n次版本号：当做了向下兼容的功能性新增及修改。\n修订号：当做了向下兼容的问题修正。\n另外，先行版本号 及 版本编译信息 可以加到 主版本号.次版本号.修订号 的后面，作为延伸。\n完整版本格式如下：\n先行版本号可以有多个，如第一个为UTC时间，第二个为提交的哈希值：\n1 2 v4.0.1-0.20210109023952-943e75fe5223+incompatible v0.0.0-20240416160154-fe59bbe5cc7f 其中版本号核心部分 X.Y.Z 是必须的，使用 . 连接，先行版本号和版本编译信息是可选的，先行版本号通过 - 与核心部分连接，版本编译信息通过 + 与核心部分或先行版本号连接。\n合法的几种版本号格式如下：\n主版本号.次版本号.修订号 主版本号.次版本号.修订号-先行版本号 主版本号.次版本号.修订号+版本编译信息 主版本号.次版本号.修订号-先行版本号+版本编译信息 主版本号必须在有任何不兼容的修改被加入公共 API 时递增。每当主版本号递增时，次版本号和修订号必须归零。\n次版本号必须在有向下兼容的新功能出现或有改进时递增，或在任何公共 API 的功能被标记为弃用时也必须递增。每当次版本号递增时，修订号必须归零。\n修订号必须在只做了向下兼容的修正时才递增。这里的修正指的是针对不正确结果而进行的内部修改。\n存在先行版本号，意味着当前版本不够稳定，且可能存在兼容性问题。先行版本号是一连串以 . 分隔的标识符，由 ASCII 字母数字和连接号 [0-9A-Za-z-] 组成，禁止出现空白符，数字类型则禁止在前方补零。合法示例：1.0.0-alpha、1.0.0-alpha.1、1.0.0-0.3.7、1.0.0-x.7.z.92。\n版本编译信息标志符规格与先行版本号基本相同，略有差异的是数字类型前方允许补零。合法示例：1.0.0-alpha+001、1.0.0+20130313144700、1.0.0-beta+exp.sha.5114f85。\n除了上面几点说明，还需要额外关注以下几点：\n标记版本号的软件发行后，禁止改变该版本软件的内容。任何修改都必须以新版本发行。 主版本号为零（0.y.z）的软件处于开发初始阶段，一切都可能随时被改变。这样的公共 API 不应该被视为稳定版。 1.0.0 的版本号用于界定公共 API 的形成。这一版本之后所有的版本号更新都基于公共 API 及其修改内容。 社区中还存在一个不成文的规定，对于次版本号，偶数为稳定版本，奇数为开发版本。当然不是所有项目都这样设计。 # 使用语义化版本规范可能遇到的问题 在使用语义化版本规范过程中，可能人为或程序编写错误导致出现如下几种可预见的问题：\n万一不小心把一个不兼容的改版当成了次版本号发行了该怎么办？\n一旦发现自己破坏了语义化版本控制的规范，就要修正这个问题，并发行一个新的次版本号来更正这个问题并且恢复向下兼容。即使是这种情况，也不能去修改已发行的版本。可以的话，将有问题的版本号记录到文档中，告诉使用者问题所在，让他们能够意识到这是有问题的版本。\n注意：不到万不得已，不要也不能去修改已发行的版本。\n如果我变更了公共 API 但无意中未遵循版本号的改动怎么办呢？（意即在修订等级的发布中，误将重大且不兼容的改变加到代码之中）\n自行做最佳的判断。如果你有庞大的使用者群在依照公共 API 的意图而变更行为后会大受影响，那么最好做一次主版本的发布，即使严格来说这个修复仅是修订等级的发布。记住，语义化的版本控制就是透过版本号的改变来传达意义。若这些改变对你的使用者是重要的，那就透过版本号来向他们说明。\nv1.2.3 是一个语义化版本号吗？\nv1.2.3 并不是的一个语义化的版本号。但是，在语义化版本号之前增加前缀 v 是用来表示版本号的常用做法。在版本控制系统中，将 version 缩写为 v 是很常见的。比如：git tag v1.2.3 -m \u0026quot;Release version 1.2.3\u0026quot; 中，v1.2.3 表示标签名称，而 1.2.3 是语义化版本号。go modules的模块版本也是在前面加v\n# 如何验证语义化版本规范正确性 官方提供了两个正则可以检查语义化版本号的正确性。\n支持按组名称提取匹配结果\n1 ^(?P\u0026lt;major\u0026gt;0|[1-9]\\d*)\\.(?P\u0026lt;minor\u0026gt;0|[1-9]\\d*)\\.(?P\u0026lt;patch\u0026gt;0|[1-9]\\d*)(?:-(?P\u0026lt;prerelease\u0026gt;(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+(?P\u0026lt;buildmetadata\u0026gt;[0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$ Go 语言示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 package main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;regexp\u0026#34; ) func main() { version := \u0026#34;0.1.2-alpha+001\u0026#34; pattern := regexp.MustCompile(`^(?P\u0026lt;major\u0026gt;0|[1-9]\\d*)\\.(?P\u0026lt;minor\u0026gt;0|[1-9]\\d*)\\.(?P\u0026lt;patch\u0026gt;0|[1-9]\\d*)(?:-(?P\u0026lt;prerelease\u0026gt;(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+(?P\u0026lt;buildmetadata\u0026gt;[0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$`) r := pattern.FindStringSubmatch(version) m := make(map[string]string) for i, name := range pattern.SubexpNames() { if i == 0 { m[\u0026#34;version\u0026#34;] = r[i] } else { m[name] = r[i] } } result, _ := json.MarshalIndent(m, \u0026#34;\u0026#34;, \u0026#34; \u0026#34;) fmt.Printf(\u0026#34;%s\\n\u0026#34;, result) } /* { \u0026#34;buildmetadata\u0026#34;: \u0026#34;001\u0026#34;, \u0026#34;major\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;minor\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;patch\u0026#34;: \u0026#34;2\u0026#34;, \u0026#34;prerelease\u0026#34;: \u0026#34;alpha\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;0.1.2-alpha+001\u0026#34; } */ 支持按编号提取匹配结果\n1 ^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$ Go 语言示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;regexp\u0026#34; ) func main() { version := \u0026#34;0.1.2-alpha+001\u0026#34; pattern := regexp.MustCompile(`^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$`) r := pattern.FindStringSubmatch(version) for i, s := range r { fmt.Printf(\u0026#34;%d -\u0026gt; %s\\n\u0026#34;, i, s) } } /* 0 -\u0026gt; 0.1.2-alpha+001 1 -\u0026gt; 0 2 -\u0026gt; 1 3 -\u0026gt; 2 4 -\u0026gt; alpha 5 -\u0026gt; 001 */ # Go Modules版本设计 # 依赖地狱 我们先来看下早期 Go 依赖包存在的依赖地狱问题：\n首先存在两个包 pkg1 和 pkg2，分别依赖 pkg3 的 v1.0.0 版本和 v2.0.0 版本，现在我们开发一个 app 包，它依赖 pkg1 和 pkg2，那么此时由于 app 包只允许包含一个 pkg3 依赖，所以 Go 构建工具无法抉择应该使用哪个版本的 pkg3。这就是所谓的依赖地狱问题。\n# 语义导入版本 为了解决依赖地狱问题，Go 在 1.11 版本时引入和 Go Modules：\nGo Module 解决问题的方式是，把 pkg3 的 v1.0.0 版本和 v2.0.0 版本当作两个不同的包，这样也就允许了 app 包能够同时包含多个不同版本的 pkg3。\n在使用时，需要在包的导入路径上加上包的主版本号。这里以 go-micro 包使用为例，展示下 Go Module 语义导入版本的用法：\n1 2 3 4 5 6 7 8 9 10 11 12 import \u0026#34;go-micro.dev/v4\u0026#34; // create a new service service := micro.NewService( micro.Name(\u0026#34;helloworld\u0026#34;), ) // initialise flags service.Init() // start the service service.Run() 可以看到导入路径为 \u0026quot;go-micro.dev/v4\u0026quot;，其中 v4 就代表了需要引入 go-micro 的 v4.y.z 版本。\n# Go Modules基本使用 # go modules相关命令 在 Go modules 中，我们能够使用如下命令进行操作：\n命令 介绍 go mod init \u0026lt;project\u0026gt; 初始化项目依赖，生成go.mod模块文件 go mod download 根据go.mod文件下载依赖 go mod tidy 比对项目文件中引入的依赖与go.mod进行比对,整理模块文件，去除没有用到的依赖 go mod graph 输出依赖关系图、查看现有的依赖结构 go mod edit 编辑go.mod文件 go mod vendor 将项目的所有依赖导出至vendor目录 go mod verify 检验一个依赖包是否被篡改过 go mod why 解释为什么需要某个依赖 # go modules参数配置 GO111MODULE\nGo语言提供了 GO111MODULE 这个环境变量来作为 Go modules 的开关，其允许设置以下参数：\n参数 说明 auto 只要项目包含了 go.mod 文件的话启用 Go modules，目前在 Go1.11 至 Go1.14 中仍然是默认值。 on 启用 Go modules，推荐设置，将会是Go1.16版本之后的默认值。 off 禁用 Go modules，不推荐设置。 你可能会留意到 GO111MODULE 这个名字比较“奇特”，实际上在 Go 语言中经常会有这类阶段性的变量， GO111MODULE 这个命名代表着Go语言在 1.11 版本添加的。后续版本中可能会去掉。\nGOPROXY\n这个环境变量主要是用于设置 Go 模块代理（Go module proxy），其作用是用于使 Go 在后续拉取模块版本时能够脱离传统的 VCS（版本控制系统，如github，就是源地址下载） 方式，直接通过镜像站点来快速拉取。值为off表示禁止模块代理。\n设置GOPROXY可以加速模块下载，确保构建确定性（提供稳定的构建版本），提高安全性，确保模块始终可用。\nGOPROXY 的默认值是：https://proxy.golang.org,direct，由于某些原因国内无法正常访问该地址，所以我们通常需要配置一个可访问的地址。目前国内社区使用比较多的有两个 https://goproxy.cn和 https://goproxy.io，当然如果你的公司有提供GOPROXY地址那么就直接使用。并且修改的代理，通过go get命令下载自己的公共模块，也会同步到 https://pkg.go.dev/。\n设置GOPAROXY的命令如下：\n1 go env -w GOPROXY=https://goproxy.cn,direct GOPROXY 允许设置多个代理地址，多个地址之间需使用英文逗号 “,” 分隔。最后的 “direct” 是一个特殊指示符，用于指示 Go 回源到源地址去抓取（比如 GitHub 等）。当配置有多个代理地址时，如果第一个代理地址返回 404 或 410 错误时，Go 会自动尝试下一个代理地址，当遇见 “direct” 时触发回源，也就是回到源地址去抓取。就是代理失败之后用传统方式（源地址下载模块）。\nGOPRIVATE\nGONOPROXY/GONOSUMDB/GOPRIVATE\n这三个环境变量都是用在当前项目依赖了私有模块，例如像是你公司的私有 git 仓库，又或是 github 中的私有库，都是属于私有模块，都是要进行设置的，否则会拉取失败。\n更细致来讲，就是依赖了由 GOPROXY 指定的 Go 模块代理或由 GOSUMDB 指定 Go checksum database 都无法访问到的模块时的场景。\n而一般建议直接设置 GOPRIVATE，它的值将作为 GONOPROXY 和 GONOSUMDB 的默认值，所以建议的最佳姿势是直接使用 GOPRIVATE。\n设置了GOPROXY 之后，go 命令就会从配置的代理地址拉取和校验依赖包。当我们在项目中引入了非公开的包（公司内部git仓库或 github 私有仓库等），此时便无法正常从代理拉取到这些非公开的依赖包，这个时候就需要配置 GOPRIVATE 环境变量。GOPRIVATE用来告诉 go 命令哪些仓库属于私有仓库，不必通过代理服务器拉取和校验。\nGOPRIVATE 的值也可以设置多个，多个地址之间使用英文逗号 “,” 分隔。我们通常会把自己公司内部的代码仓库设置到 GOPRIVATE 中，例如：\n1 $ go env -w GOPRIVATE=\u0026#34;git.example.com,github.com/arlettebrook/demo\u0026#34; 设置后，前缀为 git.xxx.com 和 github.com/arlettebrook/demo的模块都会被认为是私有模块。\n如果不想每次都重新设置，我们也可以利用通配符，例如：\n1 $ go env -w GOPRIVATE=\u0026#34;*.example.com\u0026#34; 这样子设置的话，所有模块路径为 example.com 的子域名（例如：git.example.com）都将不经过 Go module proxy 和 Go checksum database，需要注意的是不包括 example.com 本身。\n此外，如果公司内部自建了 GOPROXY 服务，那么我们可以通过设置 GONOPROXY=none，允许通内部代理拉取私有仓库的包。\n# go modules模块文件 初识化项目\n在项目的根目录下运行go mod init \u0026lt;project\u0026gt;，如go mod init github.com/arlettebrook/demo，demo是项目名，github.com/arlettebrook/demo是模块导入路径，当导入的时候，如果本地没有，会去该路径下载。\ngo.mod 文件\n在初始化项目时，会生成一个 go.mod 文件，是启用了 Go modules 项目所必须的最重要的标识，同时也是 GO111MODULE 值为 auto 时的识别标识，它描述了当前项目（也就是当前模块）的元信息，每一行都以一个动词开头。\n示例文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 module github.com/arlettebrook/demo go 1.22.1 require ( example.com/apple v0.1.2 example.com/banana v1.2.3 example.com/banana/v2 v2.3.4 example.com/pear // indirect example.com/strawberry // incompatible ) exclude example.com/banana v1.2.4 replace example.com/apple v0.1.2 =\u0026gt; example.com/fried v0.1.0 replace example.com/banana =\u0026gt; example.com/fish 说明\nmodule：用于定义当前项目的模块路径。 go：用于标识当前模块的 Go 语言版本，值为初始化模块时的版本，目前来看还只是个标识作用。 require：用于设置一个特定的模块版本。 exclude：用于从使用中排除一个特定的模块版本。 replace：用于将一个模块版本替换为另外一个模块版本。 另外你会发现 example.com/pear 的后面会有一个 indirect 标识，indirect 标识表示该模块为间接依赖，也就是在当前应用程序中的 import 语句中，并没有发现这个模块的明确引用，有可能是你先手动 go get 拉取下来的，也有可能是你所依赖的模块所依赖的，情况有好几种。incompatible：不兼容的\ngo.sum 文件\n在第一次拉取模块依赖后，会发现多出了一个 go.sum 文件，其详细罗列了当前项目直接或间接依赖的所有模块版本，并写明了那些模块版本的 SHA-256 哈希值以备 Go 在今后的操作中保证项目所依赖的那些模块版本不会被篡改。\n1 2 3 4 github.com/spf13/cobra v1.8.0 h1:7aJaZx1B85qltLMc546zn58BxxfZdR/W22ej9CFoEf0= github.com/spf13/cobra v1.8.0/go.mod h1:WXLWApfZ71AjXPya3WOlMsY9yMs7YeiHhFVlvLyhcho= github.com/spf13/pflag v1.0.5 h1:iy+VFUOCP1a+8yFto/drg2CJ5u0yRoB7fZw3DKv/JXA= github.com/spf13/pflag v1.0.5/go.mod h1:McXfInJRrz4CZXVZOBLb0bTZqETkiAhM9Iw0y3An2Bg= 可以看到一个模块路径可能有如下两种：\n1 2 github.com/spf13/cobra v1.8.0 h1:7aJaZx1B85qltLMc546zn58BxxfZdR/W22ej9CFoEf0= github.com/spf13/cobra v1.8.0/go.mod h1:WXLWApfZ71AjXPya3WOlMsY9yMs7YeiHhFVlvLyhcho= h1 hash 是 Go modules 将目标模块版本的 zip 文件开包后，针对所有包内文件依次进行 hash，然后再把它们的 hash 结果按照固定格式和算法组成总的 hash 值。\n而 h1 hash 和 go.mod hash 两者，要不就是同时存在，要不就是只存在 go.mod hash。那什么情况下会不存在 h1 hash 呢，就是当 Go 认为肯定用不到某个模块版本的时候就会省略它的 h1 hash，就会出现不存在 h1 hash，只存在 go.mod hash 的情况。\ngo.mod和go.sum都应该被提交到git仓库中去。当别人使用你的项目时，mod保证依赖版本一直，sum保证依赖不被篡改。\n# go modules模块下载 我们下载、添加模块使用go get -u \u0026lt;module path\u0026gt;。\n默认下载、添加最新版本，首先会检查本地（pkg：全局模块缓存）是否存在，没有，在去下载。\n在项目中下载会自动添加到go.mod文件中。\n-u选项会更新模块的依赖包到最新版本，推荐加上。\n还可以指定下载版本\n命令 作用 go get golang.org/x/text@latest 拉取最新的版本，若存在tag，则优先使用。可以省略。 go get golang.org/x/text@master 拉取 master 分支的最新 commit。@branch go get golang.org/x/text@v0.3.2 拉取 tag 为 v0.3.2 的 commit。@version，version必须满足语义化版本规范且前面加v。 go get golang.org/x/text@342b2e 拉取 hash 为 342b231 的 commit，最终会被转换为 v0.3.2。@commit go get golang.org/x/text/v2 下载主版本号为2的最新版 最新版本的选择\n分两种情况\n最新版本有发布tags：就以发布的版本，version一般为标签名，如v2.1.2 最新版本没有发布tags:就以提交的最新版本，version一般为已发布标签-最新提交日期-最新提交哈希+版本编译信息，版本编译信息一般没有。如v2.1.2-20240416160154-fe59bbe5cc7f，如果一次tags也没有发布，版本号则为v0.0.0，如v0.0.0-20240416160154-fe59bbe5cc7f 子模块同理 # go modules全局缓存 Go module 会把下载到本地的依赖包会以类似下面的形式保存在 $GOPATH/pkg/mod目录下，每个依赖包都会带有版本号进行区分，这样就允许在本地存在同一个包的多个不同版本。\n1 2 3 4 5 6 7 mod ├── cache ├── github.com ├── golang.org ├── google.golang.org ├── gopkg.in ... 如果想清除所有本地已缓存的依赖包数据，可以执行 go clean -modcache 命令。\n# go modules模块导入 go模块导入用import \u0026quot;模块路径\u0026quot;\n当导入多个模块的时候用\n1 2 3 4 5 import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;path/filepath\u0026#34; ) 别名导入用import 别名 \u0026quot;模块路径\u0026quot;\n1 import f \u0026#34;fmt\u0026#34; 点导入用import . \u0026quot;模块路径\u0026quot;\n点导入是一种特殊的导入方式，它将包中的所有公共标识符（函数、变量、类型等）提升到当前文件的命名空间中，这样在代码中就可以直接使用这些标识符，而不需要加上包名前缀。但是，这种方式可能会导致命名冲突和代码可读性下降，因此一般不建议使用。\n空导入用import _ \u0026quot;模块路径\u0026quot;\n空导入通常用于初始化包中的变量或者执行包中的初始化函数，而不直接使用该包中的其他标识符。\n注意事项\n当模块的主版本号为0或1的时候省略了主版本标识。\n当主版本号为2及以上时，不能省略主版本标识。否则会出现冲突。\n主版本标识只能为/v主版本号，不能用@version，一般使用主版本的最新版，这与语义化版本规范有关。\n如：\n1 2 import \u0026#34;github.com/jordan-wright/email\u0026#34; import \u0026#34;github.com/jordan-wright/email/v4\u0026#34; 为什么忽略 v0 和 v1 的主版本号\n还是与语义化版本规范有关，v0属于开发初始阶段，其公共api不被视为稳定版，当版本到达v1，其公共api基本确定，在此之后如果不出现不兼容api的修改，是不会修改主版本号的。后续的次版本、修订号会向下兼容。这是官方所鼓励的。当api做了不兼容的修改，主版本号就会修改。为了不出现冲突就会加上主版本标识。\n# gopkg.in介绍 gopkg.in是旧go包管理工具中的一个，并不是官方包管理工具。作用是下载时重定向到相应github仓库。优点是： URL 更干净、更短、导入路径稳定、易于使用、支持版本控制。\n浏览器打开链接，会提供对应包的godoc在线链接以及github仓库链接。\ngopkg.in/ini.v1对应github仓库为githu.com/go-ini/ini，当没有指定用户名时，用户名默认为go-包名。\n1 2 gopkg.in/pkg.v3 → github.com/go-pkg/pkg (branch/tag v3, v3.N, or v3.N.M) gopkg.in/user/pkg.v3 → github.com/user/pkg (branch/tag v3, v3.N, or v3.N.M) 版本控制用.vNumber表示.。\n与go modules的区别：\nv1gopkg.in必须指定。go mod不用。 gopkg.in分隔符是.（go mod是/）。 v0为开发版、不稳定版，不指定默认为开发版，go mod不指定默认为v0或v1。 gopkg.in主版本为1就要指定主版本标识。go mod主版本为2才需要指定。 如何让gopkg.in收录自己的模块：\n与go mod一样，当我们使用go get下载已经存在的版本仓库时，会自动同步到在线的godoc中。 建议仓库名与用户名关系是pkg与go-pkg，推荐gopkg.in。当然也可以直接使用github仓库路径。 其他情况可以使用go mod。并通过像 proxy.golang.org 这样的代理服务器来分发你的模块。 gopkg.in版本控制同样遵循[语义化版本控制](#Go Module 语义化版本规范)。\n# 总结 至此我们大致介绍了 Go modules 的前世今生、语义化版本规范以及基本使用。\nGo modules 的成长和发展经历了一定的过程，如果你是刚接触的读者，直接基于 Go modules 的项目开始即可，如果既有老项目，那么是时候考虑切换过来了，Go1.14起已经准备就绪，并推荐你使用。\n# 参考 https://semver.org/lang/zh-CN/ Go Module 语义化版本规范 Go Modules详解 Go module详细介绍 ","date":"2024-04-28T10:57:17+08:00","permalink":"https://arlettebrook.github.io/p/go-modules%E8%AF%A6%E8%A7%A3/","title":"Go modules详解"},{"content":" Go 语言标准库中的 log 包设计简洁明了，易于上手，可以轻松记录程序运行时的信息、调试错误以及跟踪代码执行过程中的问题等。使用 log 包无需繁琐的配置即可直接使用。本文旨在深入探究 log 包的使用和原理，帮助读者更好地了解和掌握它。\n# 使用 先来看一个 log 包的使用示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main import \u0026#34;log\u0026#34; func main() { log.Print(\u0026#34;Print\u0026#34;) log.Printf(\u0026#34;Printf: %s\u0026#34;, \u0026#34;print\u0026#34;) log.Println(\u0026#34;Println\u0026#34;) log.Fatal(\u0026#34;Fatal\u0026#34;) log.Fatalf(\u0026#34;Fatalf: %s\u0026#34;, \u0026#34;fatal\u0026#34;) log.Fatalln(\u0026#34;Fatalln\u0026#34;) log.Panic(\u0026#34;Panic\u0026#34;) log.Panicf(\u0026#34;Panicf: %s\u0026#34;, \u0026#34;panic\u0026#34;) log.Panicln(\u0026#34;Panicln\u0026#34;) } 假设以上代码存放在 main.go 中，通过 go run main.go 执行代码将会得到如下输出：\n1 2 3 4 5 6 $ go run main.go 2023/03/08 22:33:22 Print 2023/03/08 22:33:22 Printf: print 2023/03/08 22:33:22 Println 2023/03/08 22:33:22 Fatal exit status 1 以上示例代码中使用 log 包提供的 9 个函数分别对日志进行输出，最终得到 4 条打印日志。我们来分析下每个日志函数的作用，来看看为什么出现这样的结果。\nlog 包提供了 3 类共计 9 种方法来输出日志内容。\n函数名 作用 使用示例 Print 打印日志 log.Print(“Print”) Printf 打印格式化日志 log.Printf(“Printf: %s”, “print”) Println 打印日志并换行 log.Println(“Println”) Panic 打印日志后执行 panic(s)（s 为日志内容） log.Panic(“Panic”) Panicf 打印格式化日志后执行 panic(s) log.Panicf(“Panicf: %s”, “panic”) Panicln 打印日志并换行后执行 panic(s) log.Panicln(“Panicln”) Fatal 打印日志后执行 os.Exit(1) log.Fatal(“Fatal”) Fatalf 打印格式化日志后执行 os.Exit(1) log.Fatalf(“Fatalf: %s”, “fatal”) Fatalln 打印日志并换行后执行 os.Exit(1) log.Panicln(“Panicln”) 实际上log包每打印一句日志，都会换行，无论有没有ln或者\\n。\n根据以上表格说明，我们可以知道，log 包在执行 log.Fatal(\u0026quot;Fatal\u0026quot;) 时，程序打印完日志就通过 os.Exit(1) 退出了。这也就可以解释上面的示例程序，为什么打印了 9 次日志，却只输出了 4 条日志，并且最后程序退出码为 1 了。\n以上是 log 包最基本的使用方式，如果我们想对日志输出做一些定制，可以使用 log.New 创建一个自定义 logger：\n1 logger := log.New(os.Stdout, \u0026#34;[Debug] - \u0026#34;, log.Lshortfile) log.New 函数接收三个参数，分别用来指定：日志输出位置（一个 io.Writer 对象）、日志前缀（字符串，每次打印日志都会跟随输出）、日志属性（定义好的常量，稍后会详细讲解）。\n使用示例：\n1 2 3 4 5 6 7 8 9 10 11 package main import ( \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; ) func main() { logger := log.New(os.Stdout, \u0026#34;[Debug] - \u0026#34;, log.Lshortfile) logger.Println(\u0026#34;custom logger\u0026#34;) } 示例输出：\n1 [Debug] - main.go:10: custom logger 以上示例中，指定日志输出到 os.Stdout，即标准输出；日志前缀 [Debug] - 会自动被加入到每行日志的行首；这条日志没有打印当前时间，而是打印了文件名和行号，这是 log.Lshortfile 日志属性的作用。\n日志属性可选项如下：\n属性 说明 Ldate 当前时区的日期，格式：2009/01/23 Ltime 当前时区的时间，格式：01:23:23 Lmicroseconds 当前时区的时间，格式：01:23:23.123123，精确到微妙 Llongfile 全文件名和行号，格式：/a/b/c/d.go:23 Lshortfile 当前文件名和行号，格式：d.go:23，会覆盖 Llongfile LUTC 使用 UTC 而非本地时区，推荐日志全部使用 UTC 时间 Lmsgprefix 将 prefix 内容从行首移动到日志内容前面 LstdFlags 标准 logger 对象的初始值（等于：`Ldate 这些属性都是预定义好的常量，不能修改，可以通过 | 运算符组合使用（如：log.Ldate|log.Ltime|log.Lshortfile）。\n使用 log.New 函数创建 logger 对象以后，依然可以通过 logger 对象的方法修改其属性值（默认的log也同样有下列同名函数）：\n方法 作用 SetOutput 设置日志输出位置 SetPrefix 设置日志输出前缀 SetFlags 设置日志属性 现在我们来看一个更加完整的使用示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package main import ( \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; ) func main() { // 准备日志文件 logFile, _ := os.Create(\u0026#34;demo.log\u0026#34;) defer func() { _ = logFile.Close() }() // 初始化日志对象 logger := log.New(logFile, \u0026#34;[Debug] - \u0026#34;, log.Lshortfile|log.Lmsgprefix) logger.Print(\u0026#34;Print\u0026#34;) logger.Println(\u0026#34;Println\u0026#34;) // 修改日志配置 logger.SetOutput(os.Stdout) logger.SetPrefix(\u0026#34;[Info] - \u0026#34;) logger.SetFlags(log.Ldate|log.Ltime|log.LUTC) logger.Print(\u0026#34;Print\u0026#34;) logger.Println(\u0026#34;Println\u0026#34;) } 执行以上代码，得到 demo.log 日志内容如下：\n1 2 main.go:15: [Debug] - Print main.go:16: [Debug] - Println 控制台输出内容如下：\n1 2 [Info] - 2023/03/11 01:24:56 Print [Info] - 2023/03/11 01:24:56 Println 可以发现，在 demo.log 日志内容中，因为指定了 log.Lmsgprefix 属性，所以日志前缀 [Debug] - 被移动到了日志内容前面，而非行首。\n因为后续通过 logger.SetXXX 对 logger 对象的属性进行了动态修改，所以最后两条日志输出到系统的标准输出。\n以上，基本涵盖了 log 包的所有常用功能。接下来我们就通过走读源码的方式来更深入的了解 log 包了。\n# 源码 注意：本文以 Go 1.19.4 源码为例，其他版本可能存在差异。\nGo 标准库的 log 包代码量非常少，算上注释也才 400+ 行，非常适合初学者阅读学习。\n在上面介绍的第一个示例中，我们使用 log 包提供的 9 个公开函数对日志进行输出，并通过表格的形式分别介绍了函数的作用和使用示例，那么现在我们就来看看这几个函数是如何定义的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 func Print(v ...any) { if atomic.LoadInt32(\u0026amp;std.isDiscard) != 0 { return } std.Output(2, fmt.Sprint(v...)) } func Printf(format string, v ...any) { if atomic.LoadInt32(\u0026amp;std.isDiscard) != 0 { return } std.Output(2, fmt.Sprintf(format, v...)) } func Println(v ...any) { if atomic.LoadInt32(\u0026amp;std.isDiscard) != 0 { return } std.Output(2, fmt.Sprintln(v...)) } func Fatal(v ...any) { std.Output(2, fmt.Sprint(v...)) os.Exit(1) } func Fatalf(format string, v ...any) { std.Output(2, fmt.Sprintf(format, v...)) os.Exit(1) } func Fatalln(v ...any) { std.Output(2, fmt.Sprintln(v...)) os.Exit(1) } func Panic(v ...any) { s := fmt.Sprint(v...) std.Output(2, s) panic(s) } func Panicf(format string, v ...any) { s := fmt.Sprintf(format, v...) std.Output(2, s) panic(s) } func Panicln(v ...any) { s := fmt.Sprintln(v...) std.Output(2, s) panic(s) } 可以发现，这些函数代码主逻辑基本一致，都是通过 std.Output 输出日志。不同的是，PrintX 输出日志后程序就执行结束了；Fatal 输出日志后会执行 os.Exit(1)；而 Panic 输出日志后会执行 panic(s)。\n那么接下来就是要搞清楚这个 std 对象是什么，以及它的 Output 方法是如何定义的。\n我们先来看下 std 是什么：\n1 2 3 4 5 6 7 8 9 var std = New(os.Stderr, \u0026#34;\u0026#34;, LstdFlags) func New(out io.Writer, prefix string, flag int) *Logger { l := \u0026amp;Logger{out: out, prefix: prefix, flag: flag} if out == io.Discard { l.isDiscard = 1 } return l } 可以看到，std 其实就是使用 New 创建的一个 Logger 对象，日志输出到标准错误输出，日志前缀为空，日志属性为 LstdFlags。\n这跟我们上面讲的自定义日志对象 logger := log.New(os.Stdout, \u0026quot;[Debug] - \u0026quot;, log.Lshortfile) 方式如出一辙。也就是说，当我们通过 log.Print(\u0026quot;Print\u0026quot;) 打印日志时，其实使用的是 log 包内部已经定义好的 Logger 对象。\nLogger 定义如下：\n1 2 3 4 5 6 7 8 type Logger struct { mu sync.Mutex // 锁，保证并发情况下对其属性操作是原子性的 prefix string // 日志前缀，即 Lmsgprefix 参数值 flag int // 日志属性，用来控制日志输出格式 out io.Writer // 日志输出位置，实现了 io.Writer 接口即可，如 文件、os.Stderr buf []byte // 存储日志输出内容 isDiscard int32 // 当 out = io.Discard 是，此值为 1 } 其中，flag 和 isDiscard 这两个属性有必要进一步解释下。\n首先是 flag 用来记录日志属性，其合法值如下：\n1 2 3 4 5 6 7 8 9 10 const ( Ldate = 1 \u0026lt;\u0026lt; iota // the date in the local time zone: 2009/01/23 Ltime // the time in the local time zone: 01:23:23 Lmicroseconds // microsecond resolution: 01:23:23.123123. assumes Ltime. Llongfile // full file name and line number: /a/b/c/d.go:23 Lshortfile // final file name element and line number: d.go:23. overrides Llongfile LUTC // if Ldate or Ltime is set, use UTC rather than the local time zone Lmsgprefix // move the \u0026#34;prefix\u0026#34; from the beginning of the line to before the message LstdFlags = Ldate | Ltime // initial values for the standard logger ) 具体含义我就不再一一解释了，前文的表格已经写的很详细了。\n值得注意的是，这里在定义常量时，巧妙的使用了左移运算符 1 \u0026lt;\u0026lt; iota，使得常量的值呈现 1、2、4、8… 这样的递增效果。其实是为了位运算方便，通过对属性进行位运算，来决定输出内容，其本质上跟基于位运算的权限管理是一样的。所以在使用 log.New 新建 Logger 对象时可以支持 log.Ldate|log.Ltime|log.Lshortfile 这种形式设置多个属性。\nstd 对象的属性初始值 LstdFlags 也是在这里定义的。\n其次还有一个属性 isDiscard，是用来丢弃日志的。在上面介绍 PrintX 函数定义时，在输出日志前有一个 if atomic.LoadInt32(\u0026amp;std.isDiscard) != 0 的判断，如果结果为真，则直接 return 不记录日志。\n在 Go 标准库的 io 包里，有一个 io.Discard 对象，io.Discard 实现了 io.Writer，它执行 Write 操作后不会产生任何实际的效果，是一个用于丢弃数据的对象。比如有时候我们不在意数据内容，但可能存在数据不读出来就无法关闭连接的情况，这时候就可以使用 io.Copy(io.Discard, io.Reader) 将数据写入 io.Discard 实现丢弃数据的效果。\n使用 New 创建 Logger 对象时，如果 out == io.Discard 则 l.isDiscard 的值会被置为 1，所以使用 PrintX 函数记录的日志将会被丢弃，而 isDiscard 属性之所以是 int32 类型而不是 bool，是因为方便原子操作。\n现在，我们终于可以来看 std.Output 的实现了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 func (l *Logger) Output(calldepth int, s string) error { now := time.Now() // 获取当前时间 var file string var line int // 加锁，保证并发安全 l.mu.Lock() defer l.mu.Unlock() // 通过位运算来判断是否需要获取文件名和行号 if l.flag\u0026amp;(Lshortfile|Llongfile) != 0 { // 运行 runtime.Caller 获取文件名和行号比较耗时，所以先释放锁 l.mu.Unlock() var ok bool _, file, line, ok = runtime.Caller(calldepth) if !ok { file = \u0026#34;???\u0026#34; line = 0 } // 获取到文件行号后再次加锁，保证下面代码并发安全 l.mu.Lock() } // 清空上次缓存的内容 l.buf = l.buf[:0] // 格式化日志头信息（如：日期时间、文件名和行号、前缀）并写入 buf l.formatHeader(\u0026amp;l.buf, now, file, line) // 追加日志内容到 buf l.buf = append(l.buf, s...) // 保证输出日志以 \\n 结尾 if len(s) == 0 || s[len(s)-1] != \u0026#39;\\n\u0026#39; { l.buf = append(l.buf, \u0026#39;\\n\u0026#39;) } // 调用 Logger 对象的 out 属性的 Write 方法输出日志 _, err := l.out.Write(l.buf) return err } Output 方法代码并不多，基本逻辑也比较清晰，首先根据日志属性来决定是否需要获取文件名和行号，因为调用 runtime.Caller 是一个耗时操作，开销比较大，为了增加并发性，暂时将锁释放，获取到文件名和行号后再重新加锁。\n接下来就是准备日志输出内容了，首先清空 buf 中保留的上次日志信息，然后通过 formatHeader 方法格式化日志头信息，接着把日志内容也追加到 buf 中，在这之后有一个保证输出日志以 \\n 结尾的逻辑，来保证输出的日志都是单独一行的。不知道你有没有注意到，在前文的 log 包使用示例中，我们使用 Print 和 Println 两个方法时，最终日志输出效果并无差别，使用 Print 打印日志也会换行，其实就是这里的逻辑决定的。\n最后，通过调用 l.out.Write 方法，将 buf 内容输出。\nfunc Caller(skip int) (pc uintptr, file string, line int, ok bool)\n当skip为0时，获取调用该函数的函数信息，返回值包括程序计数器（pc：program counter栈帧的入口地址）、file调用函数所在文件的绝对路径、line调用行号，ok是否获取成功 当skip为1时，获取调用该函数的调用函数的信息，返回值包括程序计数器（pc：program counter栈帧的入口地址）、调用函数所在文件的绝对路径、调用行号，是否获取成功 以此类推 func FuncForPC(pc uintptr) *Func\n根据pc获取调用函数对象，name属性可以获取调用函数名. func CallersFrames(callers []uintptr) *Frames\n根据pc字节切片获取调用栈帧。next()方法获取栈帧。然后通过栈帧可以获取函数名，函数所在文件的绝对路径。调用行号。 1 2 3 4 5 6 7 8 9 frames := runtime.CallersFrames([]uintptr{pc}) // 遍历栈帧 for { frame, more := frames.Next() if !more { break } fmt.Printf(\u0026#34;函数名: %s, 文件: %s, 行号: %d\\n\u0026#34;, frame.Function, frame.File, frame.Line) } 我们来看下用来格式化日志头信息的 formatHeader 方法是如何定义：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 func (l *Logger) formatHeader(buf *[]byte, t time.Time, file string, line int) { // 如果没有设置 Lmsgprefix 属性，将日志前缀内容设置到行首 if l.flag\u0026amp;Lmsgprefix == 0 { *buf = append(*buf, l.prefix...) } // 判断是否设置了日期时间相关的属性 if l.flag\u0026amp;(Ldate|Ltime|Lmicroseconds) != 0 { // 是否设置 UTC 时间 if l.flag\u0026amp;LUTC != 0 { t = t.UTC() } // 是否设置日期 if l.flag\u0026amp;Ldate != 0 { year, month, day := t.Date() itoa(buf, year, 4) *buf = append(*buf, \u0026#39;/\u0026#39;) itoa(buf, int(month), 2) *buf = append(*buf, \u0026#39;/\u0026#39;) itoa(buf, day, 2) *buf = append(*buf, \u0026#39; \u0026#39;) } // 是否设置时间 if l.flag\u0026amp;(Ltime|Lmicroseconds) != 0 { hour, min, sec := t.Clock() itoa(buf, hour, 2) *buf = append(*buf, \u0026#39;:\u0026#39;) itoa(buf, min, 2) *buf = append(*buf, \u0026#39;:\u0026#39;) itoa(buf, sec, 2) if l.flag\u0026amp;Lmicroseconds != 0 { *buf = append(*buf, \u0026#39;.\u0026#39;) itoa(buf, t.Nanosecond()/1e3, 6) } *buf = append(*buf, \u0026#39; \u0026#39;) } } // 是否设置文件名和行号 if l.flag\u0026amp;(Lshortfile|Llongfile) != 0 { if l.flag\u0026amp;Lshortfile != 0 { short := file for i := len(file) - 1; i \u0026gt; 0; i-- { if file[i] == \u0026#39;/\u0026#39; { short = file[i+1:] break } } file = short } *buf = append(*buf, file...) *buf = append(*buf, \u0026#39;:\u0026#39;) itoa(buf, line, -1) *buf = append(*buf, \u0026#34;: \u0026#34;...) } // 如果设置了 Lmsgprefix 属性，将日志前缀内容放到日志头信息最后，也就是紧挨着日志内容前面 if l.flag\u0026amp;Lmsgprefix != 0 { *buf = append(*buf, l.prefix...) } } formatHeader 方法是 log 包里面代码量最多的一个方法，主要通过按位与（\u0026amp;）来计算是否设置了某个日志属性，然后根据日志属性来格式化头信息。\n其中多次调用 itoa 函数，itoa 顾名思义，将 int 转换成 ASCII 码，itoa 定义如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func itoa(buf *[]byte, i int, wid int) { // Assemble decimal in reverse order. var b [20]byte bp := len(b) - 1 for i \u0026gt;= 10 || wid \u0026gt; 1 { wid-- q := i / 10 b[bp] = byte(\u0026#39;0\u0026#39; + i - q*10) bp-- i = q } // i \u0026lt; 10 b[bp] = byte(\u0026#39;0\u0026#39; + i) *buf = append(*buf, b[bp:]...) } 这个函数短小精悍，它接收三个参数，buf 用来保存转换后的内容，i 就是带转换的值，比如 year、month 等，wid 表示转换后 ASCII 码字符串宽度，如果传进来的 i 宽度不够，则前面补零。比如传入 itoa(\u0026amp;b, 12, 3)，最终输出字符串为 012。\n'0'+i会隐式触发字符和ASCII之间的转换，0的ASCII码是48，加0~9就是对应0~9的ASCII码，超过57就是别的字符。\n至此，我们已经理清了 log.Print(\u0026quot;Print\u0026quot;) 是如何打印一条日志的，其函数调用流程如下：\n上面我们讲解了使用 log 包中默认的 std 这个 Logger 对象打印日志的调用流程。当我们使用自定义的 Logger 对象（logger := log.New(os.Stdout, \u0026quot;[Debug] - \u0026quot;, log.Lshortfile)）来打印日志时，调用的 loggger.Print 是一个方法，而不是 log.Print 这个包级别的函数，所以其实 Logger 结构体也实现了 9 种输出日志方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 func (l *Logger) Print(v ...any) { if atomic.LoadInt32(\u0026amp;l.isDiscard) != 0 { return } l.Output(2, fmt.Sprint(v...)) } func (l *Logger) Printf(format string, v ...any) { if atomic.LoadInt32(\u0026amp;l.isDiscard) != 0 { return } l.Output(2, fmt.Sprintf(format, v...)) } func (l *Logger) Println(v ...any) { if atomic.LoadInt32(\u0026amp;l.isDiscard) != 0 { return } l.Output(2, fmt.Sprintln(v...)) } func (l *Logger) Fatal(v ...any) { l.Output(2, fmt.Sprint(v...)) os.Exit(1) } func (l *Logger) Fatalf(format string, v ...any) { l.Output(2, fmt.Sprintf(format, v...)) os.Exit(1) } func (l *Logger) Fatalln(v ...any) { l.Output(2, fmt.Sprintln(v...)) os.Exit(1) } func (l *Logger) Panic(v ...any) { s := fmt.Sprint(v...) l.Output(2, s) panic(s) } func (l *Logger) Panicf(format string, v ...any) { s := fmt.Sprintf(format, v...) l.Output(2, s) panic(s) } func (l *Logger) Panicln(v ...any) { s := fmt.Sprintln(v...) l.Output(2, s) panic(s) } 这 9 个方法跟 log 包级别的函数一一对应，用于自定义 Logger 对象。\n有一个值得注意的点，在这些方法内部，调用 l.Output(2, s) 时，第一个参数 calldepth 传递的是 2，这跟 runtime.Caller(calldepth) 函数内部实现有关，runtime.Caller 函数签名如下：\n1 func Caller(skip int) (pc uintptr, file string, line int, ok bool) runtime.Caller 返回当前 Goroutine 的栈上的函数调用信息（程序计数器、文件信息、行号），其参数 skip 表示当前向上层的栈帧数，0 代表当前函数，也就是调用 runtime.Caller 的函数，1 代表上一层调用者，以此类推。\n因为函数调用链为 main.go -\u0026gt; log.Print -\u0026gt; std.Output -\u0026gt; runtime.Caller，所以 skip 值即为 2：\n0: 表示 std.Output 中调用 runtime.Caller 所在的源码文件和行号。 1: 表示 log.Print 中调用 std.Output 所在的源码文件和行号。 2: 表示 main.go 中调用 log.Print 所在的源码文件和行号。 这样当代码出现问题时，就能根据日志中记录的函数调用栈来找到报错的源码位置了。\n另外，前文介绍过三个设置 Logger 对象属性的方法，分别是 SetOutput、SetPrefix、SetFlags，其实这三个方法各自还有与之对应的获取相应属性的方法，定义如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 func (l *Logger) Flags() int { l.mu.Lock() defer l.mu.Unlock() return l.flag } func (l *Logger) SetFlags(flag int) { l.mu.Lock() defer l.mu.Unlock() l.flag = flag } func (l *Logger) Prefix() string { l.mu.Lock() defer l.mu.Unlock() return l.prefix } func (l *Logger) SetPrefix(prefix string) { l.mu.Lock() defer l.mu.Unlock() l.prefix = prefix } func (l *Logger) Writer() io.Writer { l.mu.Lock() defer l.mu.Unlock() return l.out } func (l *Logger) SetOutput(w io.Writer) { l.mu.Lock() defer l.mu.Unlock() l.out = w isDiscard := int32(0) if w == io.Discard { isDiscard = 1 } atomic.StoreInt32(\u0026amp;l.isDiscard, isDiscard) } 其实就是针对每个私有属性，定义了 getter、setter 方法，并且每个方法内部为了保证并发安全，都进行了加锁操作。\n当然，log 包级别的函数，也少不了这几个功能：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 func Default() *Logger { return std } func SetOutput(w io.Writer) { std.SetOutput(w) } func Flags() int { return std.Flags() } func SetFlags(flag int) { std.SetFlags(flag) } func Prefix() string { return std.Prefix() } func SetPrefix(prefix string) { std.SetPrefix(prefix) } func Writer() io.Writer { return std.Writer() } func Output(calldepth int, s string) error { return std.Output(calldepth+1, s) // +1 for this frame. } 至此，log 包的全部代码我们就一起走读完成了。\n总结一下：log 包主要设计了 Logger 对象和其方法，并且为了开箱即用，在包级别又对外提供了默认的 Logger 对象 std 和一些包级别的对外函数。Logger 对象的方法，和包级别的函数基本上是一一对应的，签名一样，这样就大大降低了使用难度。并且log包是并发安全的。\n# 使用建议 关于 log 包的使用，我还有几条建议分享给你：\nlog 默认不支持 Debug、Info、Warn 等更细粒度级别的日志输出方法，不过我们可以通过创建多个 Logger 对象的方式来实现，只需要给每个 Logger 对象指定不同的日志前缀即可：\n1 2 3 4 loggerDebug = log.New(os.Stdout, \u0026#34;[Debug]\u0026#34;, log.LstdFlags) loggerInfo = log.New(os.Stdout, \u0026#34;[Info]\u0026#34;, log.LstdFlags) loggerWarn = log.New(os.Stdout, \u0026#34;[Warn]\u0026#34;, log.LstdFlags) loggerError = log.New(os.Stdout, \u0026#34;[Error]\u0026#34;, log.LstdFlags) log 包作为 Go 标准库，仅支持日志的基本功能，不支持记录结构化日志、日志切割、Hook 等高级功能，所以更适合小型项目使用，比如一个单文件的脚本。对于中大型项目，则推荐使用一些主流的第三方日志库，如 logrus、zap、glog 等。\n另外，如果你对 Go 标准日志库有所期待，Go 官方还打造了另一个日志库 slog 现已进入实验阶段，如果项目发展顺利，将可能成为 log 包的替代品。\n# 总结 本文我与读者一起深入探究了 Go log 标准库，首先向大家介绍了 log 包如何使用，接着又带领大家一起走读了 log 包的源码，最后我也给出了一些自己对 log 包的使用建议。\n参考：\nGo log 源码 Go 每日一库之 log 搬运自深入探究 Go log 标准库 ","date":"2024-04-27T16:54:38+08:00","permalink":"https://arlettebrook.github.io/p/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%A9%B6-go-log-%E6%A0%87%E5%87%86%E5%BA%93/","title":"深入探究 Go log 标准库"},{"content":" 在程序开发中，有些场景是我们经常会遇到的，软件行业的先行者们帮我们总结了一些解决常见场景编码问题的最佳实践，于是就有了设计模式。选项模式在 Go 语言开发中会经常用到，所以今天我们来介绍一下选项模式的应用。\n熟悉 Python 开发的同学都知道，Python 有默认参数的存在，使得我们在实例化一个对象的时候，可以根据需要来选择性的覆盖某些默认参数，以此来决定如何实例化对象。当一个对象有多个默认参数时，这个特性非常好用，能够优雅的简化代码。\n而 Go 语言从语法上是不支持默认参数的，所以为了实现既能通过默认参数创建对象，又能通过传递自定义参数创建对象，我们就需要通过一些编程技巧来实现。\n# 通过多构造函数实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 package main import \u0026#34;fmt\u0026#34; const ( defaultAddr = \u0026#34;127.0.0.1\u0026#34; defaultPort = 8000 ) type Server struct { Addr string Port int } func NewServer() *Server { return \u0026amp;Server{ Addr: defaultAddr, Port: defaultPort, } } func NewServerWithOptions(addr string, port int) *Server { return \u0026amp;Server{ Addr: addr, Port: port, } } func main() { s1 := NewServer() s2 := NewServerWithOptions(\u0026#34;localhost\u0026#34;, 8001) fmt.Println(s1) // \u0026amp;{127.0.0.1 8000} fmt.Println(s2) // \u0026amp;{localhost 8001} } 这里我们为 Server 结构体实现了两个构造函数，其中 NewServer 无需传递参数即可直接返回 Server 对象，NewServerWithOptions 则需要传递 addr 和 port 两个参数来构造 Server 对象。当我们无需对 Server 进行定制，通过默认参数创建的对象即可满足需求时，我们可以使用 NewServer 来生成对象（s1），而当我们需要对其进行定制时，则可以使用 NewServerWithOptions 来生成对象（s2）。\n# 通过默认参数选项实现 另外一种实现默认参数的方案是，我们可以为要生成的结构体对象定义一个选项结构体，用来生成要创建对象的默认参数，代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 package main import \u0026#34;fmt\u0026#34; const ( defaultAddr = \u0026#34;127.0.0.1\u0026#34; defaultPort = 8000 ) type Server struct { Addr string Port int } type ServerOptions struct { Addr string Port int } func NewServerOptions() *ServerOptions { return \u0026amp;ServerOptions{ Addr: defaultAddr, Port: defaultPort, } } func NewServerWithOptions(opts *ServerOptions) *Server { return \u0026amp;Server{ Addr: opts.Addr, Port: opts.Port, } } func main() { s1 := NewServerWithOptions(NewServerOptions()) s2 := NewServerWithOptions(\u0026amp;ServerOptions{ Addr: \u0026#34;localhost\u0026#34;, Port: 8001, }) fmt.Println(s1) // \u0026amp;{127.0.0.1 8000} fmt.Println(s2) // \u0026amp;{localhost 8001} } 我们为 Server 结构体专门实现了一个 ServerOptions 用来生成默认参数，调用 NewServerOptions 函数即可获得默认参数配置，构造函数 NewServerWithOptions 接收一个 *ServerOptions 类型作为参数，所以我们可以直接将调用 NewServerOptions 函数的返回值传递给 NewServerWithOptions 来实现通过默认参数生成对象（s1），也可以通过手动构造 ServerOptions 配置来生成定制对象（s2）。\n# 通过选项模式实现 以上两种方式虽然都能够完成功能，但实现上却都不够优雅，接下来我们一起来看下如何通过选项模式更优雅的解决这个问题，代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 package main import \u0026#34;fmt\u0026#34; const ( defaultAddr = \u0026#34;127.0.0.1\u0026#34; defaultPort = 8000 ) type Server struct { Addr string Port int } type ServerOptions struct { Addr string Port int } type ServerOption interface { apply(*ServerOptions) } type FuncServerOption struct { f func(*ServerOptions) } func (fo FuncServerOption) apply(option *ServerOptions) { fo.f(option) } func WithAddr(addr string) ServerOption { return FuncServerOption{ f: func(options *ServerOptions) { options.Addr = addr }, } } func WithPort(port int) ServerOption { return FuncServerOption{ f: func(options *ServerOptions) { options.Port = port }, } } func NewServer(opts ...ServerOption) *Server { options := ServerOptions{ Addr: defaultAddr, Port: defaultPort, } for _, opt := range opts { opt.apply(\u0026amp;options) } return \u0026amp;Server{ Addr: options.Addr, Port: options.Port, } } func main() { s1 := NewServer() s2 := NewServer(WithAddr(\u0026#34;localhost\u0026#34;), WithPort(8001)) s3 := NewServer(WithPort(8001)) fmt.Println(s1) // \u0026amp;{127.0.0.1 8000} fmt.Println(s2) // \u0026amp;{localhost 8001} fmt.Println(s3) // \u0026amp;{127.0.0.1 8001} } 乍一看，我们的代码复杂了很多，但其实都是定义上的复杂，调用构造函数生成对象的代码复杂度是没有改变的。\n在这里我们定义了 ServerOptions 结构体用来配置默认参数，因为这里 Addr 和 Port 都有默认参数，所以 ServerOptions 的定义和 Server 定义是一样的，但有一定复杂性的结构体中可能会有些参数没有默认参数，必须让用户来配置，这时 ServerOptions 的字段就会少一些，大家可以按需定义。\n同时，我们还定义了一个 ServerOption 接口和实现了此接口的 FuncServerOption 结构体，它们的作用是让我们能够通过 apply 方法为 ServerOptions 结构体单独配置某项参数。\n我们可以分别为每个默认参数都定义一个 WithXXX 函数用来配置参数，如这里定义的 WithAddr 和 WithPort ，这样用户就可以通过调用 WithXXX 函数来定制需要覆盖的默认参数。\n此时默认参数定义在构造函数 NewServer 中，构造函数的接收一个不定长参数，类型为 ServerOption，在构造函数内部通过一个 for 循环调用每个传进来的 ServerOption 对象的 apply 方法，将用户配置的参数依次赋值给构造函数内部的默认参数对象 options 中，以此来替换默认参数，for 循环执行完成后，得到的 options 对象将是最终配置，将其属性依次赋值给 Server 即可生成新的对象。\n# 总结 通过 s2 和 s3 的打印结果可以发现，使用选项模式实现的构造函数更加灵活，相较于前两种实现，选项模式中我们可以自由的更改其中任意一项或多项默认配置。\n虽然选项模式确实会多写一些代码，但多数情况下这是值得的，Google 的 gRPC 框架 Go 语言实现中创建 gRPC server 的构造函数 NewServer 就使用了选项模式，感兴趣的同学可以看下其源码的实现思想其实和这里的示例程序如出一辙。\n希望今天的分享能够给你带来一点帮助。\n原文地址：Go 常见设计模式之选项模式\n","date":"2024-04-25T23:22:54+08:00","permalink":"https://arlettebrook.github.io/p/go%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E9%80%89%E9%A1%B9%E6%A8%A1%E5%BC%8F/","title":"Go常见设计模式：选项模式"},{"content":" 单例模式是设计模式中最简单的一种模式，单例模式能够确保无论对象被实例化多少次，全局都只有一个实例存在。根据单例模式的特性，我们可以将其应用到全局唯一性配置、数据库连接对象、文件访问对象等。Go 语言有多种方式可以实现单例模式，我们今天就来一起学习下。\n# 饿汉式 饿汉式实现单例模式非常简单，直接看代码：\n1 2 3 4 5 6 7 8 9 package singleton type Singleton struct{} var instance = \u0026amp;Singleton{} func GetSingleton() *Singleton { return instance } singleton 包在被导入时会自动初始化 instance 实例，使用时通过调用 singleton.GetSingleton() 函数即可获得 Singleton 这个结构体的单例对象。\n由于单例对象是在包加载时立即被创建出来，所以也就有了这个形象的名称叫作饿汉式。与之对应的另一种实现方式叫作懒汉式，当实例被第一次使用时才会被创建。\n需要注意的是，尽管饿汉式实现单例模式如此简单，但大多数情况下仍不被推荐使用，因为如果单例实例化时初始化内容过多，可能造成程序加载用时较长。\n# 懒汉式 接下来我们再来看下如何通过懒汉式实现单例模式：\n1 2 3 4 5 6 7 8 9 10 11 12 package singleton type Singleton struct{} var instance *Singleton func GetSingleton() *Singleton { if instance == nil { instance = \u0026amp;Singleton{} } return instance } 相较于饿汉式的实现，我们把实例化 Singleton 结构体部分的代码移到了 GetSingleton() 函数内部。这样一来，就将对象实例化的步骤延迟到了 GetSingleton() 被第一次调用时。\n通过 instance == nil 的判断来实现单例并不十分可靠，当有多个 goroutine 同时调用 GetSingleton() 时无法保证并发安全。\n# 支持并发的单例 如果你用 Go 语言写过并发编程，那么应该可以很快想到解决懒汉式单例模式并发安全问题的方案：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package singleton import \u0026#34;sync\u0026#34; type Singleton struct{} var instance *Singleton var mu sync.Mutex func GetSingleton() *Singleton { mu.Lock() defer mu.Unlock() if instance == nil { instance = \u0026amp;Singleton{} } return instance } 我们对代码的主要修改就是在 GetSingleton() 函数最开始加了如下两行代码：\n1 2 mu.Lock() defer mu.Unlock() 通过加锁的机制，就可以保证这个实现单例模式的函数是并发安全的。\n不过这样也有些问题，因为用了锁机制，每次调用 GetSingleton() 时程序都会进行加锁、解锁的步骤，这样会导致程序性能的下降。\n# 双重锁定 加锁导致程序性能下降，但我们又不得不用锁来保证程序的并发安全，于是有人想出了双重锁定（Double-Check Locking）的方案：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package singleton import \u0026#34;sync\u0026#34; type Singleton struct{} var instance *Singleton var mu sync.Mutex func GetSingleton() *Singleton { if instance == nil { mu.Lock() defer mu.Unlock() if instance == nil { instance = \u0026amp;Singleton{} } } return instance } 可以看到，所谓的双重锁定实际上就是在程序加锁前又加了一层 instance == nil 判断，这样就兼顾了性能和安全两个方面。\n不过这段代码看起来有些奇怪，既然外层已经判断了 instance == nil，加锁后却又进行了第二次 instance == nil 判断。其实外层的 instance == nil 判断是为了提高程序的执行效率，因为如果 instance 已经存在，则无需进入 if 逻辑，程序直接返回 instance 即可。这样就免去了原来每次调用 GetSingleton() 都上锁的操作，将加锁的粒度更加精细化。而内层的 instance == nil 判断则是考虑了并发安全，在极端情况下，多个 goroutine 同时走到了加锁这一步，内层判断就起到作用了。\n# Gopher 惯用方案 gopher原意地鼠，在golang 的世界里解释为地道的go程序员。在其他语言的世界里也有PHPer，Pythonic的说法，反而Java是个例外。虽然也有Javaer之类的说法，但似乎并不被认可。而地道或者说道地，说的是gopher写的代码无不透露出go的独特气息，比如项目结构、命名方式、代码格式、编码风格、构建方式等等。用gopher的话说，用go编写代码就像是在画一幅中国山水画，成品美不胜收，心旷神怡。\n虽然我们通过双重锁定机制兼顾和性能和并发安全，但代码有些丑陋，不符合广大 Gopher 的期待。好在 Go 语言在 sync 包中提供了 Once 机制能够帮助我们写出更加优雅的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package singleton import \u0026#34;sync\u0026#34; type Singleton struct{} var instance *Singleton var once sync.Once func GetSingleton() *Singleton { once.Do(func() { instance = \u0026amp;Singleton{} }) return instance } Once 是一个结构体，在执行 Do 方法的内部通过 atomic 操作和加锁机制来保证并发安全，且 once.Do 能够保证多个 goroutine 同时执行时 \u0026amp;singleton{} 只被创建一次。\n其实 Once 并不神秘，其内部实现跟上面使用的双重锁定机制非常类似，只不过把 instance == nil 换成了 atomic 操作，感兴趣的同学可以查看下其对应源码。\n# 总结 以上就是 Go 语言中实现单例模式的几种常用套路，经过对比可以得出结论，最推荐的方式是使用 once.Do 来实现，sync.Once 包帮我们隐藏了部分细节，却可以让代码可读性得到很大提升。\n# 参考 不一样的go语言-gopher Go 常见设计模式之单例模式 ","date":"2024-04-25T18:00:25+08:00","permalink":"https://arlettebrook.github.io/p/go%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","title":"Go常见设计模式：单例模式"},{"content":" # 引子 在工作中，我时不时地会需要在Go中调用外部命令。前段时间我做了一个工具，在钉钉群中添加了一个机器人，@这个机器人可以让它执行一些写好的脚本程序完成指定的任务。机器人倒是不难，照着钉钉开发者文档添加好机器人，然后@这个机器人就会向一个你指定的服务器发送一个POST请求，请求中会附带文本消息。所以我要做的就是搭一个Web服务器，可以用go原生的net/http包，也可以用gin/fasthttp/fiber这些Web框架。收到请求之后，检查附带文本中的关键字去调用对应的程序，然后返回结果。\ngo标准库中的os/exec包对调用外部程序提供了支持，本文详细介绍os/exec的使用姿势。\n# 运行命令 Linux中有个cal命令，它可以显示指定年、月的日历，如果不指定年、月，默认为当前时间对应的年月。如果使用的是Windows，推荐安装msys2，这个软件包含了绝大多数的Linux常用命令。\n那么，在Go代码中怎么调用这个命令呢？其实也很简单：\n1 2 3 4 5 6 7 func main() { cmd := exec.Command(\u0026#34;cal\u0026#34;) err := cmd.Run() if err != nil { log.Fatalf(\u0026#34;cmd.Run() failed: %v\\n\u0026#34;, err) } } 首先，我们调用exec.Command传入命令名，创建一个命令对象exec.Cmd。接着调用该命令对象的Run()方法运行它。\n如果你实际运行了，你会发现什么也没有发生，哈哈。事实上，使用os/exec执行命令，标准输出和标准错误默认会被丢弃。\n# 显示输出 exec.Cmd对象有两个字段Stdout和Stderr，类型皆为io.Writer。我们可以将任意实现了io.Writer接口的类型实例赋给这两个字段，继而实现标准输出和标准错误的重定向。io.Writer接口在 Go 标准库和第三方库中随处可见，例如*os.File、*bytes.Buffer、net.Conn。所以我们可以将命令的输出重定向到文件、内存缓存甚至发送到网络中。\n# 显示到标准输出 将exec.Cmd对象的Stdout和Stderr这两个字段都设置为os.Stdout，那么输出内容都将显示到标准输出：\n1 2 3 4 5 6 7 8 9 func main() { cmd := exec.Command(\u0026#34;cal\u0026#34;) cmd.Stdout = os.Stdout cmd.Stderr = os.Stderr err := cmd.Run() if err != nil { log.Fatalf(\u0026#34;cmd.Run() failed: %v\\n\u0026#34;, err) } } 运行程序。我在git bash运行，得到如下结果：\n输出了中文，检查一下环境变量LANG的值，果然是zh_CN.UTF-8。如果想输出英文，可以将环境变量LANG设置为en_US.UTF-8：\n1 2 3 $ echo $LANG zh_CN.UTF-8 $ LANG=en_US.UTF-8 go run main.go 得到输出：\n# 输出到文件 打开或创建文件，然后将文件句柄赋给exec.Cmd对象的Stdout和Stderr这两个字段即可实现输出到文件的功能。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 func main() { f, err := os.OpenFile(\u0026#34;out.txt\u0026#34;, os.O_WRONLY|os.O_CREATE, os.ModePerm) if err != nil { log.Fatalf(\u0026#34;os.OpenFile() failed: %v\\n\u0026#34;, err) } cmd := exec.Command(\u0026#34;cal\u0026#34;) cmd.Stdout = f cmd.Stderr = f err = cmd.Run() if err != nil { log.Fatalf(\u0026#34;cmd.Run() failed: %v\\n\u0026#34;, err) } } os.OpenFile打开一个文件，指定os.O_CREATE标志让操作系统在文件不存在时自动创建一个，返回该文件对象*os.File。*os.File实现了io.Writer接口。\n运行程序：\n1 2 3 4 5 6 7 8 9 $ go run main.go $ cat out.txt November 2022 Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 # 发送到网络 现在我们来编写一个日历服务，接收年、月信息，返回该月的日历。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func cal(w http.ResponseWriter, r *http.Request) { year := r.URL.Query().Get(\u0026#34;year\u0026#34;) month := r.URL.Query().Get(\u0026#34;month\u0026#34;) cmd := exec.Command(\u0026#34;cal\u0026#34;, month, year) cmd.Stdout = w cmd.Stderr = w err := cmd.Run() if err != nil { log.Fatalf(\u0026#34;cmd.Run() failed: %v\\n\u0026#34;, err) } } func main() { http.HandleFunc(\u0026#34;/cal\u0026#34;, cal) http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil) } 这里为了简单，错误处理都省略了。正常情况下，year和month参数都需要做合法性校验。exec.Command函数接收一个字符串类型的可变参数作为命令的参数：\n1 func Command(name string, arg ...string) *Cmd # 保存到内存对象中 *bytes.Buffer同样也实现了io.Writer接口，故如果我们创建一个*bytes.Buffer对象，并将其赋给exec.Cmd的Stdout和Stderr这两个字段，那么命令执行之后，该*bytes.Buffer对象中保存的就是命令的输出。\n1 2 3 4 5 6 7 8 9 10 11 12 func main() { buf := bytes.NewBuffer(nil) cmd := exec.Command(\u0026#34;cal\u0026#34;) cmd.Stdout = buf cmd.Stderr = buf err := cmd.Run() if err != nil { log.Fatalf(\u0026#34;cmd.Run() failed: %v\\n\u0026#34;, err) } fmt.Println(buf.String()) } 运行：\n1 2 3 4 5 6 7 8 $ go run main.go November 2022 Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 运行命令，然后得到输出的字符串或字节切片这种模式是如此的普遍，并且使用便利，os/exec包提供了一个便捷方法：CombinedOutput。\n# 输出到多个目的地 有时，我们希望能输出到文件和网络，同时保存到内存对象。使用go提供的io.MultiWriter可以很容易实现这个需求。io.MultiWriter很方便地将多个io.Writer转为一个io.Writer。\n我们稍微修改上面的web程序：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func cal(w http.ResponseWriter, r *http.Request) { year := r.URL.Query().Get(\u0026#34;year\u0026#34;) month := r.URL.Query().Get(\u0026#34;month\u0026#34;) f, _ := os.OpenFile(\u0026#34;out.txt\u0026#34;, os.O_CREATE|os.O_WRONLY, os.ModePerm) buf := bytes.NewBuffer(nil) mw := io.MultiWriter(w, f, buf) cmd := exec.Command(\u0026#34;cal\u0026#34;, month, year) cmd.Stdout = mw cmd.Stderr = mw err := cmd.Run() if err != nil { log.Fatalf(\u0026#34;cmd.Run() failed: %v\\n\u0026#34;, err) } fmt.Println(buf.String()) } 调用io.MultiWriter将多个io.Writer整合成一个io.Writer，然后将cmd对象的Stdout和Stderr都赋值为这个io.Writer。这样，命令运行时产出的输出会分别送往http.ResponseWriter、*os.File以及*bytes.Buffer。\n# 运行命令，获取输出 前面提到，我们常常需要运行命令，返回输出。exec.Cmd对象提供了一个便捷方法：CombinedOutput()。该方法运行命令，将输出内容以一个字节切片返回便于后续处理。所以，上面获取输出的程序可以简化为：\n1 2 3 4 5 6 7 8 9 func main() { cmd := exec.Command(\u0026#34;cal\u0026#34;) output, err := cmd.CombinedOutput() if err != nil { log.Fatalf(\u0026#34;cmd.Run() failed: %v\\n\u0026#34;, err) } fmt.Println(string(output)) } So easy!\nCombinedOutput()方法的实现很简单，先将标准输出和标准错误重定向到*bytes.Buffer对象，然后运行程序，最后返回该对象中的字节切片：\n1 2 3 4 5 6 7 8 9 10 11 12 13 func (c *Cmd) CombinedOutput() ([]byte, error) { if c.Stdout != nil { return nil, errors.New(\u0026#34;exec: Stdout already set\u0026#34;) } if c.Stderr != nil { return nil, errors.New(\u0026#34;exec: Stderr already set\u0026#34;) } var b bytes.Buffer c.Stdout = \u0026amp;b c.Stderr = \u0026amp;b err := c.Run() return b.Bytes(), err } CombinedOutput方法前几行判断表明，Stdout和Stderr必须是未设置状态。这其实很好理解，一般情况下，如果已经打算使用CombinedOutput方法获取输出内容，不会再自找麻烦地再去设置Stdout和Stderr字段了。\n与CombinedOutput类似的还有Output方法，区别是Output只会返回运行命令产出的标准输出内容。\n# 分别获取标准输出和标准错误 创建两个*bytes.Buffer对象，分别赋给exec.Cmd对象的Stdout和Stderr这两个字段，然后运行命令即可分别获取标准输出和标准错误。\n1 2 3 4 5 6 7 8 9 10 11 12 func main() { cmd := exec.Command(\u0026#34;cal\u0026#34;, \u0026#34;15\u0026#34;, \u0026#34;2012\u0026#34;) var stdout, stderr bytes.Buffer cmd.Stdout = \u0026amp;stdout cmd.Stderr = \u0026amp;stderr err := cmd.Run() if err != nil { log.Fatalf(\u0026#34;cmd.Run() failed: %v\\n\u0026#34;, err) } fmt.Printf(\u0026#34;output:\\n%s\\nerror:\\n%s\\n\u0026#34;, stdout.String(), stderr.String()) } # 标准输入 exec.Cmd对象有一个类型为io.Reader的字段Stdin。命令运行时会从这个io.Reader读取输入。先来看一个最简单的例子：\n1 2 3 4 5 6 7 8 9 func main() { cmd := exec.Command(\u0026#34;cat\u0026#34;) cmd.Stdin = bytes.NewBufferString(\u0026#34;hello\\nworld\u0026#34;) cmd.Stdout = os.Stdout err := cmd.Run() if err != nil { log.Fatalf(\u0026#34;cmd.Run() failed: %v\\n\u0026#34;, err) } } 如果不带参数运行cat命令，则进入交互模式，cat按行读取输入，并且原样发送到输出。\n再来看一个复杂点的例子。Go标准库中compress/bzip2包只提供解压方法，并没有压缩方法。我们可以利用Linux命令bzip2实现压缩。bzip2从标准输入中读取数据，将其压缩，并发送到标准输出。\n1 2 3 4 5 6 7 8 9 10 11 12 func bzipCompress(d []byte) ([]byte, error) { var out bytes.Buffer cmd := exec.Command(\u0026#34;bzip2\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;-9\u0026#34;) cmd.Stdin = bytes.NewBuffer(d) cmd.Stdout = \u0026amp;out err := cmd.Run() if err != nil { log.Fatalf(\u0026#34;cmd.Run() failed: %v\\n\u0026#34;, err) } return out.Bytes(), nil } 参数-c表示压缩，-9表示压缩等级，9为最高。为了验证函数的正确性，写个简单的程序，先压缩\u0026quot;hello world\u0026quot;字符串，然后解压，看看是否能得到原来的字符串：\n1 2 3 4 5 6 7 func main() { data := []byte(\u0026#34;hello world\u0026#34;) compressed, _ := bzipCompress(data) r := bzip2.NewReader(bytes.NewBuffer(compressed)) decompressed, _ := ioutil.ReadAll(r) fmt.Println(string(decompressed)) } 运行程序，输出\u0026quot;hello world\u0026quot;。\n# 环境变量 环境变量可以在一定程度上微调程序的行为，当然这需要程序的支持。例如，设置ENV=production会抑制调试日志的输出。每个环境变量都是一个键值对。exec.Cmd对象中有一个类型为[]string的字段Env。我们可以通过修改它来达到控制命令运行时的环境变量的目的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;os/exec\u0026#34; ) func main() { cmd := exec.Command(\u0026#34;bash\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;./test.sh\u0026#34;) nameEnv := \u0026#34;NAME=darjun\u0026#34; ageEnv := \u0026#34;AGE=18\u0026#34; newEnv := append(os.Environ(), nameEnv, ageEnv) cmd.Env = newEnv out, err := cmd.CombinedOutput() if err != nil { log.Fatalf(\u0026#34;cmd.Run() failed: %v\\n\u0026#34;, err) } fmt.Println(string(out)) } 上面代码获取系统的环境变量，然后又添加了两个环境变量NAME和AGE。最后使用bash运行脚本test.sh：\n1 2 3 4 5 #!/bin/bash echo $NAME echo $AGE echo $GOPATH 程序运行结果：\n1 2 3 4 $ go run main.go darjun 18 D:\\workspace\\code\\go # 检查命令是否存在 一般在运行命令之前，我们通过希望能检查要运行的命令是否存在，如果存在则直接运行，否则提示用户安装此命令。os/exec包提供了函数LookPath可以获取命令所在目录，如果命令不存在，则返回一个error。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func main() { path, err := exec.LookPath(\u0026#34;ls\u0026#34;) if err != nil { fmt.Printf(\u0026#34;no cmd ls: %v\\n\u0026#34;, err) } else { fmt.Printf(\u0026#34;find ls in path:%s\\n\u0026#34;, path) } path, err = exec.LookPath(\u0026#34;not-exist\u0026#34;) if err != nil { fmt.Printf(\u0026#34;no cmd not-exist: %v\\n\u0026#34;, err) } else { fmt.Printf(\u0026#34;find not-exist in path:%s\\n\u0026#34;, path) } } 运行：\n1 2 3 $ go run main.go find ls in path:C:\\Program Files\\Git\\usr\\bin\\ls.exe no cmd not-exist: exec: \u0026#34;not-exist\u0026#34;: executable file not found in %PATH% # 封装 执行外部命令的流程比较固定：\n调用exec.Command()创建命令对象； 调用Cmd.Run()执行命令 可以自己封装成一个工具包。\n# 总结 本文介绍了使用os/exec这个标准库调用外部命令的各种姿势。\n# 参考 Advanced command execution in go with os/exec: https://blog.kowalczyk.info/article/wOYk/advanced-command-execution-in-go-with-osexec.html Go中调用外部命令的几种姿势搬运自该篇文章。 ","date":"2024-04-24T23:41:31+08:00","permalink":"https://arlettebrook.github.io/p/go%E8%B0%83%E7%94%A8%E5%A4%96%E9%83%A8%E5%91%BD%E4%BB%A4os/exec%E5%BA%93%E4%BB%8B%E7%BB%8D/","title":"Go调用外部命令os/exec库介绍"},{"content":" # 简介 今天我们来看一个很小，很实用的库go-homedir。顾名思义，go-homedir用来获取用户的主目录。 实际上，使用标准库os/user或者os.UserHomeDir()我们也可以得到这个信息：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os/user\u0026#34; ) func main() { u, err := user.Current() if err != nil { log.Fatal(err) } fmt.Println(\u0026#34;Home dir:\u0026#34;, u.HomeDir) } 那么为什么还要go-homedir库？\n在 Darwin 系统上，标准库os/user的使用需要 cgo。所以，任何使用os/user的代码都不能交叉编译。 但是，大多数人使用os/user的目的仅仅只是想获取主目录。因此，go-homedir库出现了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func UserHomeDir() (string, error) { env, enverr := \u0026#34;HOME\u0026#34;, \u0026#34;$HOME\u0026#34; switch runtime.GOOS { case \u0026#34;windows\u0026#34;: env, enverr = \u0026#34;USERPROFILE\u0026#34;, \u0026#34;%userprofile%\u0026#34; case \u0026#34;plan9\u0026#34;: env, enverr = \u0026#34;home\u0026#34;, \u0026#34;$home\u0026#34; } if v := Getenv(env); v != \u0026#34;\u0026#34; { return v, nil } // On some geese the home directory is not always defined. switch runtime.GOOS { case \u0026#34;android\u0026#34;: return \u0026#34;/sdcard\u0026#34;, nil case \u0026#34;ios\u0026#34;: return \u0026#34;/\u0026#34;, nil } return \u0026#34;\u0026#34;, errors.New(enverr + \u0026#34; is not defined\u0026#34;) } 还有就是官方的库也只是从环境变量中获取用户的家目录，没有考虑$HOME不存在的情况。\n# 快速使用 go-homedir是第三方包，使用前需要先安装：\n1 $ go get -u github.com/mitchellh/go-homedir 使用非常简单：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;github.com/mitchellh/go-homedir\u0026#34; ) func main() { dir, err := homedir.Dir() if err != nil { log.Fatal(err) } fmt.Println(\u0026#34;Home dir:\u0026#34;, dir) dir = \u0026#34;~/golang/src\u0026#34; expandedDir, err := homedir.Expand(dir) if err != nil { log.Fatal(err) } fmt.Printf(\u0026#34;Expand of %s is: %s\\n\u0026#34;, dir, expandedDir) } go-homedir有两个功能：\nDir：获取用户主目录； Expand：将路径中的第一个~扩展成用户主目录。 # 高级用法 由于Dir的调用可能涉及一些系统调用和外部执行命令，多次调用费性能。所以go-homedir提供了缓存的功能。默认情况下，缓存是开启的。 我们也可以将DisableCache设置为true来关闭它。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;github.com/mitchellh/go-homedir\u0026#34; ) func main() { homedir.DisableCache = true # 关闭了缓存 dir, err := homedir.Dir() if err != nil { log.Fatal(err) } fmt.Println(\u0026#34;Home dir:\u0026#34;, dir) } 使用缓存时，如果程序运行中修改了主目录，再次调用Dir还是返回之前的目录。如果需要获取最新的主目录，可以先调用Reset清除缓存。\n# 实现 go-homedir源码只有一个文件homedir.go，今天我们大概看一下Dir的实现，去掉缓存相关代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func Dir() (string, error) { var result string var err error if runtime.GOOS == \u0026#34;windows\u0026#34; { result, err = dirWindows() } else { // Unix-like system, so just assume Unix result, err = dirUnix() } if err != nil { return \u0026#34;\u0026#34;, err } return result, nil } 判断当前的系统是windows还是类 Unix，分别调用不同的方法。先看 windows 的，比较简单：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func dirWindows() (string, error) { // First prefer the HOME environmental variable if home := os.Getenv(\u0026#34;HOME\u0026#34;); home != \u0026#34;\u0026#34; { return home, nil } // Prefer standard environment variable USERPROFILE if home := os.Getenv(\u0026#34;USERPROFILE\u0026#34;); home != \u0026#34;\u0026#34; { return home, nil } drive := os.Getenv(\u0026#34;HOMEDRIVE\u0026#34;) path := os.Getenv(\u0026#34;HOMEPATH\u0026#34;) home := drive + path if drive == \u0026#34;\u0026#34; || path == \u0026#34;\u0026#34; { return \u0026#34;\u0026#34;, errors.New(\u0026#34;HOMEDRIVE, HOMEPATH, or USERPROFILE are blank\u0026#34;) } return home, nil } 流程如下：\n读取环境变量HOME，如果不为空，返回这个值； 读取环境变量USERPROFILE，如果不为空，返回这个值； 读取环境变量HOMEDRIVE和HOMEPATH，如果两者都不为空，拼接这两个值返回。 类 Unix 系统的实现稍微复杂一点：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 func dirUnix() (string, error) { homeEnv := \u0026#34;HOME\u0026#34; if runtime.GOOS == \u0026#34;plan9\u0026#34; { // On plan9, env vars are lowercase. homeEnv = \u0026#34;home\u0026#34; } // First prefer the HOME environmental variable if home := os.Getenv(homeEnv); home != \u0026#34;\u0026#34; { return home, nil } var stdout bytes.Buffer // If that fails, try OS specific commands if runtime.GOOS == \u0026#34;darwin\u0026#34; { cmd := exec.Command(\u0026#34;sh\u0026#34;, \u0026#34;-c\u0026#34;, `dscl -q . -read /Users/\u0026#34;$(whoami)\u0026#34; NFSHomeDirectory | sed \u0026#39;s/^[^ ]*: //\u0026#39;`) cmd.Stdout = \u0026amp;stdout if err := cmd.Run(); err == nil { result := strings.TrimSpace(stdout.String()) if result != \u0026#34;\u0026#34; { return result, nil } } } else { cmd := exec.Command(\u0026#34;getent\u0026#34;, \u0026#34;passwd\u0026#34;, strconv.Itoa(os.Getuid())) cmd.Stdout = \u0026amp;stdout if err := cmd.Run(); err != nil { // If the error is ErrNotFound, we ignore it. Otherwise, return it. if err != exec.ErrNotFound { return \u0026#34;\u0026#34;, err } } else { if passwd := strings.TrimSpace(stdout.String()); passwd != \u0026#34;\u0026#34; { // username:password:uid:gid:gecos:home:shell passwdParts := strings.SplitN(passwd, \u0026#34;:\u0026#34;, 7) if len(passwdParts) \u0026gt; 5 { return passwdParts[5], nil } } } } // If all else fails, try the shell stdout.Reset() cmd := exec.Command(\u0026#34;sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;cd \u0026amp;\u0026amp; pwd\u0026#34;) cmd.Stdout = \u0026amp;stdout if err := cmd.Run(); err != nil { return \u0026#34;\u0026#34;, err } result := strings.TrimSpace(stdout.String()) if result == \u0026#34;\u0026#34; { return \u0026#34;\u0026#34;, errors.New(\u0026#34;blank output when reading home directory\u0026#34;) } return result, nil } 流程如下：\n先读取环境变量HOME（注意 plan9 系统上为home），如果不为空，返回这个值； 使用getnet命令查看系统的数据库中的相关记录，我们知道passwd文件中存储了用户信息，包括用户的主目录。使用getent命令查看passwd中当前用户的那条记录，然后从中找到主目录部分返回； 如果上一个步骤失败了，我们知道cd后不加参数是直接切换到用户主目录的，而pwd可以显示当前目录。那么就可以结合这两个命令返回主目录。 这里分析源码并不是表示使用任何库都要熟悉它的源码，毕竟使用库就是为了方便开发。 但是源码是我们学习和提高的一个非常重要的途径。我们在使用库遇到问题的时候也要有能力从文档或甚至源码中查找原因。\n# 参考 home-dir GitHub 仓库 Go 每日一库之 go-homedir ","date":"2024-04-24T22:47:45+08:00","permalink":"https://arlettebrook.github.io/p/go-homedir%E5%BA%93%E4%BB%8B%E7%BB%8D/","title":"Go-homedir库介绍"},{"content":" 注意：要学会使用-h \u0026ndash;help选项，查看命令，看不懂在查阅。git help \u0026lt;command\u0026gt;可进入官方文档。Git入门参考。以下常用命令个人收集总结。\n# git简单命令 # git init git init \u0026lt;directory\u0026gt;在指定的⽬录下创建⼀个空的git repo。不带参数将在当前⽬录下创建⼀个git repo。 # git clone git clone \u0026lt;repo\u0026gt;克隆⼀个指定repo到本地。指定的repo可以是本地⽂件系统或者由HTTP或SSH指定的远程路径。 git clone -b \u0026lt;branch\u0026gt; \u0026lt;repo\u0026gt;克隆指定仓库的分支 git clone --recursive \u0026lt;repo\u0026gt;递归地克隆，克隆带有子模块的仓库 git clone --recurse-submodules \u0026lt;repository_url\u0026gt;同理 可组合使用 # git add git add \u0026lt;directory\u0026gt;将指定⽬录的所有修改加⼊到下⼀次 commit中。把\u0026lt;directory\u0026gt;替换成\u0026lt;file\u0026gt;将添加指定⽂件的修改。 git add *、git add .、git add -A三条命令但是一样的，将所以修改提交到暂存区。 # git commit 这个命令通常带-m选项git commit -m \u0026quot;\u0026lt;message\u0026gt;\u0026quot;提交暂存区的修改，使⽤指定的 \u0026lt;message\u0026gt;作为提交信息，⽽不是打开⽂本编辑器输⼊提交信息。 git commit -m \u0026lt;message\u0026gt; --amend将当前staged修改合并到最近⼀次的commit中。 # git status git status显示哪些⽂件已被staged、以及未跟踪(untracked)。 # git reflog git reflog显示本地repo的所有commit⽇志。 与git log的区别 log项目的提交历史，reflog本地仓库的引用提交日志。 引用会保留所以的提交历史，如何重置的历史。主要目的是提供一个安全网，以便在误操作（如错误的 git reset）后可以恢复丢失的提交或分支。 git log 的输出是永久性的，而 reflog 会在一段时间后自动过期（默认是 30 天），以节省空间。 # git rm git rm fileName删除指定的文件。 与rm fileName的区别。 git rm不能删除未跟踪的文件， git rm删除之后直接到暂存区，而rm是到工作区 注意删除之后都需要提交操作。 撤销操作不用记，git都会有提示 # git switch 该命令适用于特定git版本。\ngit switch \u0026lt;branch\u0026gt;切换到指定分支，\ngit checkout \u0026lt;branch\u0026gt;同理，但这个都适用。 git switch -c \u0026lt;branch\u0026gt;创建并切换指定分支\n# git branch git branch显示本地repo的所有分⽀。\n-v显示详细信息 带*的为当前分支 git branch -r显示远程仓库的所以分支。\n可以使用git checkout \u0026lt;branch\u0026gt;检出远程分支，可以省略origin/。 git branch -a显示本地和远程的所有分支\ngit branch -m \u0026lt;old_branch_name\u0026gt; \u0026lt;new_branch_name\u0026gt;重命名分支\n新分支名已经存在， -M 强制重命名。 git branch \u0026lt;name\u0026gt;创建指定分支\ngit branch -D \u0026lt;branch\u0026gt;强制删除指定分支，无论是否合并到当前分支。\ngit branch -d \u0026lt;branch\u0026gt;删除指定的分支，如果没有合并到当前分支，git会阻止操作。\n# git merge git merge \u0026lt;branch\u0026gt;合并指定分支。将指定\u0026lt;branch\u0026gt;分⽀合并到当前分⽀。 是在当前分支合并指定分支。 合并分支可能会出现冲突。要解决冲突之后才能合并。 git merge --abort放弃本次合并 # git一般命令 # git revert git revert \u0026lt;commit\u0026gt; 对指定\u0026lt;commit\u0026gt;创建⼀个undo的commit，并应⽤到当前分⽀。就是撤销指定的提交并保留记录 效果：撤销指定的提交，回到了撤销提交的是上个版本，保留了撤销历史。会打开编辑器显示具体效果 一般不用 # git reset git reset \u0026lt;commit\u0026gt;重置到指定的提交，不会保留commit历史。工作区和暂存区会变成未跟踪。--hard选项完全重置到指定提交。未跟踪的重置不了。重置历史可以通过git reflog查看，利用这个可以重置已经重置的版本库。\n\u0026lt;commit\u0026gt;可以是： HEAD表示最新的提交或者这个版本库，HEAD^、HEAD~1上上次提交或者上个版本 或者使用commit_hash，提交的哈希值可以使用git log查看，只需要前几位就行。 git reset（重置到最新的提交）移除所有暂存区、工作区的修改，到未跟踪。这些命令其实省略了HEAD\ngit reset --hard 重置到最新的提交，删除工作区和暂存区\ngit reset \u0026lt;file\u0026gt;将\u0026lt;file\u0026gt;从暂存区移除，但保持⼯作区不变。此操作不会修改⼯作区的任何⽂件。\n# git restore git restore \u0026lt;file\u0026gt;...撤销对工作区的修改，是对以跟踪的文件当未添加到暂存区的文件。多个文件用空格分开。 git checkout -- \u0026lt;file\u0026gt;...同理，--可以省略 git restore --staged \u0026lt;file\u0026gt;...撤销对暂存区的修改到未跟踪。针对添加到暂存区的文件。 git reset HEAD \u0026lt;file\u0026gt;...同理，HEAD可以省略。 具体用哪一个，git都会有提示，不用记。 # git checkout git checkout \u0026lt;branch\u0026gt;切换到指定的分支\n如果分支为远程分支，则检出远程分支 git checkout -b \u0026lt;new-branch\u0026gt;切换并创建指定的分支\ngit checkout \u0026lt;file\u0026gt;撤销工作区的修改\ngit restore \u0026lt;file\u0026gt;同理 git checkout \u0026lt;commit\u0026gt;根据指定的提交创建一个分支,处于游离态。一般不用。\ngit checkout -b \u0026lt;local_branch_name\u0026gt; origin/\u0026lt;remote_branch_name\u0026gt;切换到远程分支\ngit checkout \u0026lt;branch\u0026gt;差不多，可以使用git fetch origin获取仓库所以信息，在检出分支。 git checkout -切换到前一个分支。\n# git remote 用来管理远程仓库列表，origin为远程仓库的默认别名。这些远端仓库的信息都被保存在./git/config 文件中。\ngit remote列出所有已配置的远程仓库的信息。\n-v显示详细信息 git remote add \u0026lt;remote_name\u0026gt; \u0026lt;remote_url\u0026gt;添加远程仓库\n添加⼀个新的远程连接。添加后可使⽤ \u0026lt;name\u0026gt;作为指定\u0026lt;url\u0026gt;远程连接的名称。 只有配置了这个才能推送到远程仓库。 git remote rename \u0026lt;old_name\u0026gt; \u0026lt;new_name\u0026gt;重命名远程仓库。 git remote set-url \u0026lt;remote_name\u0026gt; \u0026lt;new_url\u0026gt;修改远程仓库的url。 git remote remove \u0026lt;remote_name\u0026gt;或git remote rm \u0026lt;remote_name\u0026gt;删除远程仓库。 git remote show \u0026lt;remote_name\u0026gt;显示远程仓库的详细信息，包括 URL、跟踪的分支等。\n补充如何创建远程仓库\n创建远程仓库可以先在github上创建好，然后在本地pull下来，在进行修改后push上去。\n可以建一个空白仓库，在本地push上去，但需要进行绑定。\n1 2 3 git remote add origin https://github.com/username/null-project.git git branch -M main git push -u origin main # gjit push 将本地仓库推送到远程仓库\ngit push \u0026lt;remote_repository\u0026gt; \u0026lt;本地分支名\u0026gt;:\u0026lt;远程分支名\u0026gt;推送本地分支到指定的远程分支。如果远程分支不存在，会自动创建。:前后不能有空格。\n当分支同名，可以简写成git push \u0026lt;remote_repository\u0026gt; \u0026lt;本地分支名\u0026gt; 果无法提交的话执行，-f、--force选项强制推送，一般不用。 git push -u \u0026lt;remote_repository\u0026gt; \u0026lt;本地分支名\u0026gt;设置默认推送分支。\n作用：这样设置以后，推送到远程仓库可以简写成git push git push 代替 git push origin master -u是--set-upstream的短形式。 git push \u0026lt;remote_repository\u0026gt; -d \u0026lt;远程分支名\u0026gt;删除远程分支 。\n--delete长选项。 git push origin :test同理，没有写本地分支，就是删除远程分支。 git push \u0026lt;remote\u0026gt; \u0026lt;tagname\u0026gt;推送指定标签到指定远程仓库，一般为`origin``\n``git push \u0026ndash;tags`推送所用标签到远程\n# git pull git pull \u0026lt;remote_repository\u0026gt; \u0026lt;远程分支名\u0026gt;:\u0026lt;本地分支名\u0026gt;从远程仓库拉取最新代码到本地仓库。 git pull会拉取并合并，出现冲突要解决之后才能合并。 git fetch获取当前远程仓库的最新信息，不会合并。 通常可以简写成git pull,远程仓库默认是origin，分支默认是当前分支。 git pull --rebase\u0026lt;remote\u0026gt; 抓取远程分⽀，并以rebase模式并⼊本地repo⽽不是merge。 # git fetch git fetch origin获取远程仓库最新的更改。不会合并。默认仓库是origin，分支是当前分支，这里可以省略origin git fetch origin \u0026lt;branch\u0026gt;获取特定分支的更改. git fetch --all获取所用仓库远程仓库的最新更改。 与git pull的区别 都会获取远程仓库最新的更改。 但是fetch不会合并，而pull会合并。可以理解为git pull 是 git fetch 和 git merge 的组合 获取最新更改之后可以： git checkout \u0026lt;branch\u0026gt;检出指定分支，如果加origin要这样git checkout -b \u0026lt;branch\u0026gt; origin/\u0026lt;branch\u0026gt; git merge origin/master合并远程 master 分支的更改到当前的分支 git rebase origin/master使用 rebase 来整合更改（这可能会改变提交历史） # git stash git stash保存工作区、暂存区，可以切换分支去完成别的任务。不保存修改，未提交的修改会错乱到别的分支。并且只能保存已追踪的文件。 git stash list查看保存的工作区以及暂存区。 git stash apply恢复保存的工作区以及暂存区。 这个命令执行之后不会删除存储的工作区以及暂存区。 要用git stash drop才能删除。 git stash pop恢复并删除保存的工作区以及暂存区。 默认都是保存、恢复第一个stash即stash@{0}。若要指定第几个在后面加stash@{num}。 如恢复第二个stash：git stash pop stash@{1} 每个分支共用一个stash。 # git tag 作用：用于标记项目的版本发布或重要的里程碑。 分类 git tag \u0026lt;tagname\u0026gt; \u0026lt;commit ID\u0026gt;轻量标签 git tag vn.n.n打标签，n.n.n表示对应的版本号，版本号前面一般加v，遵循一定的命名规范，如v1.0.1。 默认是打在最新的一次提交。 后面跟提交的哈希值可以指定给那次提交打标签。如git tag v0.9.0 f52c633。 哈希值可以通过git log查看 git tag -a \u0026lt;tagname\u0026gt; -m \u0026quot;\u0026lt;tag message\u0026gt;\u0026quot; \u0026lt;commit ID\u0026gt;附注标签 如git tag -a v0.1 -m \u0026quot;version 0.1 released\u0026quot; 1094adb 推荐id省略默认最新提交。 查看标签 git tag显示所有的本地tag列表，按照字母顺序排序。如果tag数量较多，可能会显示不全。省略选项-l、--list git show \u0026lt;tagname\u0026gt;显示指定tag的详细信息，包括提交的作者、提交时间、提交信息等。 git tag -n：显示tag列表，并同时显示每个tag对应的提交信息。 git ls-remote --tags origin：显示远程仓库中的所有tag信息。更推荐这种。 或者先git fetch获取最新的更改，然后git tag检出所有标签。 删除标签 git tag -d \u0026lt;tagname\u0026gt;删除本地标签 删除远程标签：首先需要在本地删除标签，然后推送到远程仓库 git push origin :refs/tags/\u0026lt;tagname\u0026gt; 远程标签是refs/tags/v0.0.1这样存在的，跟删除远程分支差不多。 标签一旦创建，就不能直接修改,如果需要修改标签，通常需要删除原标签，并重新创建一个新标签。 推送标签 打的标签不会自动推送到远程仓库，需要手动推送。 git push \u0026lt;remote\u0026gt; \u0026lt;tagname\u0026gt;推送指定标签到指定远程仓库，一般为origin git push \u0026lt;remote\u0026gt; --tags推送所用标签到远程 # git复杂命令 # git log git log以缺省格式显示全部commit历史。更多⾃定义参数请参考后续部分。q退出，空格下一页，h查看帮助 git log --stat：显示详细的commit历史。 git log -\u0026lt;limit\u0026gt;限制log的显示数量。例如：”git log -5”仅显示最新5条commit。 git log --oneline每⾏显示⼀条commit，简化信息。与--pretty=oneline等效 git log --author= \u0026quot;\u0026lt;pattern\u0026gt;\u0026quot;按提交者名字搜索并显示commit。 git log --grep= \u0026quot;\u0026lt;pattern\u0026gt;\u0026quot;按指定内容搜索并显示commit。 git log \u0026lt;since\u0026gt;..\u0026lt;until\u0026gt;显示指定范围的commit。范围参数可以是commit ID、分⽀名称、HEAD或任意相对位置。 git log -- \u0026lt;file\u0026gt;仅显示包含指定⽂件修改的commit。 git log --graph使⽤\u0026ndash;graph参数显示图形化的branch信息。 # git diff git diff⽐较⼯作区和暂存区的修改。 git diff HEAD⽐较⼯作区和上⼀次commit后的修改。 HEAD指向当前分支最新的commit版本库 git diff --cached⽐较暂存区和上⼀次commit后的修改。 git diff --stashed查看暂存区与最新提交的差异，与上面一样 git diff \u0026lt;commit1\u0026gt; \u0026lt;commit2\u0026gt;查看两个提交之间的差异。 git diff \u0026lt;filename\u0026gt;后面指定文件，只查看该文件的修改情况，没有参数查询全部 用git diff HEAD -- readme.txt命令可以查看版本库和工作区里面最新版本的区别 # git config 作用：通过git config命令配置git的配置文件\ngit配置文件级别分为：\n仓库级别 --local 【优先级最高】。文件所在位置仓库下的.git/config 当前用户级别 --global【优先级次之】一般配置它。文件所在位置用户家目录下的.gitconfig 系统所有用户级别 --system【优先级最低】。文件所在位置git安装目录下的 ./etc/gitconfig -l、--list查看配置。常用\ngit config -l查看所有的配置信息，依次是系统级别、用户级别、仓库级别 git config --local -l 查看仓库级别配置。必须要进入到具体的目录下。 git config --global -l 查看当前用户配置 git config --system -l 查看系统所有用户配置 可以与--show-origin 显示文件位置，--show-scope显示文件级别组合使用 -e、--edit打开编辑器编辑指定级别的配置文件，没有指定默认仓库级别，会使用默认编辑器打开编辑。安装的时候设置的。\n添加配置、修改配置：直接配置对应的配置参数就行。一般配置用户级别就行。省略了--add选项。没有指定级别，默认仓库基本。常用的添加配置命令:\n用户邮箱和用户名。安装git之后必设置的配置\ngit config --global user.email \u0026quot;Your mail\u0026quot;\ngit config --global user.name \u0026quot;Your name\u0026quot;\n如果我们没有配置，在提交代码时会有如下错误：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 xxx@DESKTOP-MD21325 MINGW64 /d/test/test (master) $ git commit -m \u0026#34;feature: add readme\u0026#34; Author identity unknown *** Please tell me who you are. Run git config --global user.email \u0026#34;you@example.com\u0026#34; git config --global user.name \u0026#34;Your Name\u0026#34; to set your account\u0026#39;s default identity. Omit --global to set the identity only in this repository. fatal: unable to auto-detect email address (got \u0026#39;xxx@DESKTOP-MD21325.(none)\u0026#39;) 设置自己的代理。网速慢必设置的配置\ngit config --global http.proxy \u0026quot;http://proxy_ip:port\u0026quot;\ngit config --global https.proxy \u0026quot;https://proxy_ip:port\u0026quot;\n--unset取消配置，注意要指定取消的配置级别。常用取消配置命令：\n取消代理配置\ngit config --global --unset http.proxy\ngit config --global --unset https.proxy\n--get查看指定级别、指定配置项的配置，默认仓库级别。如：\n查看代理配置\ngit config --global --get http.proxy\ngit config --global --get https.proxy\ngit config --global alias.\u0026lt;alias-name\u0026gt; \u0026lt;git-command\u0026gt;配置⼀个git命令的快捷⽅式。例如：配置”alias.glog log \u0026ndash;graph \u0026ndash;oneline”使”git glog”相当于”git log \u0026ndash;graph \u0026ndash;oneline”.\ngit config --global core.editor \u0026lt;editor\u0026gt;配置⽂本编辑器，例如vi，在必要时⾃动打开此⽂本编辑器。安装的时候也可以指定默认编辑器。\n# git submodule git submodule init初始化子模块，将子模块的配置信息存储在父仓库中。\n通常执行之后再执行更新子模块使用，如克隆带有子模块的仓库，没有加--recursive，是不会克隆子模块的 初始化子模块之后，执行更新子模块就会根据配置信息下载子模块 git submodule update根据父仓库子模块的配置信息更新子模块，如果没有初始化子模块可以加参数--init，会下载与父项目绑定版本的子模块，若要更新加--remote\n--init初识化子模块 --recursive会递归下载子模块的子模块 --remote根据子模块远程仓库的配置信息更新子模块，会下载最新版本的子模块 注意更新之后要提交更新的版本，否则当在执行更新命令没有加--remote时会退回与父仓库绑定的版本 git submodule add \u0026lt;repository\u0026gt; \u0026lt;path\u0026gt;添加子模块。其中，\u0026lt;repository\u0026gt;是子模块的远程仓库地址，\u0026lt;path\u0026gt;是子模块在主项目中的路径。\n子模块可以当正常仓库使用。创建时\u0026lt;path\u0026gt;路径不能存在文件，更克隆差不多。 # git subtree 作用：将一个仓库中的目录作为另一个仓库，可以指定分支 用途：搭建项目网站时，将项目网站资源推送到gh-pages分支上 git subtree push --prefix=dist origin gh-pages将目录添加到gh-pages分支上，dist为项目网站的目录 git subtree push --prefix=\u0026lt;prefix\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;branch\u0026gt;将子目录的内容推送到远程仓库。它会将当前仓库中子目录的修改推送到指定的远程仓库和分支中。 注意：以这种推送的方式添加的subtree不能执行subtree pull命令，只有通过subtree add添加的才能都执行，但能够执行subtree push命令 git subtree pull --prefix=\u0026lt;prefix\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;branch\u0026gt;这个命令用于从远程仓库更新子目录的内容。它会拉取远程仓库的最新代码，并更新到当前仓库的子目录中。 git subtree add --prefix=\u0026lt;prefix\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;branch\u0026gt;这个命令用于将远程仓库的内容作为子目录添加到当前仓库中。\u0026lt;prefix\u0026gt;是子目录的名称，\u0026lt;repository\u0026gt;是远程仓库的地址，\u0026lt;branch\u0026gt;是要合并的分支。 # git rebase 作用：rebase翻译成变基，顾名思义：改变基准点。可以使提交历史更加清晰和线性。\n原因：通过合并两个不同的分支，提交历史会很错乱。而通过变基，会使得提交历史更加整洁和可读。\n如何实现：就是修改创建分支的起点（基准点），到最新的提交。起点变了，提交历史就简化了。\n命令：\ngit rebase \u0026lt;base\u0026gt;基于\u0026lt;base\u0026gt;对当前分⽀进⾏rebase。\u0026lt;base\u0026gt;可以是commit、分⽀名称、tag或相对于HEAD的commit。 git rebase -i \u0026lt;base\u0026gt;以交互模式对当前分⽀做rebase。 rebase的过程中可能会出现冲突，解决冲突之后需要使用git add命令将解决冲突后的文件标记为已解决，然后，使用git rebase --continue命令继续rebase过程。Git会尝试继续应用剩余的提交。如果再次出现冲突，你需要重复上述解决冲突和继续rebase的步骤。 如果在rebase过程中出现了问题，或者你决定放弃rebase操作，你可以使用git rebase --abort命令来撤销整个rebase操作。 git rebase的注意事项\n避免对已经推送到远程仓库的提交执行rebase操作：这可能会导致提交历史的不一致，给其他协作者带来困扰。 保持工作目录干净：在执行rebase之前，确保你的工作目录中没有未提交的更改。 谨慎使用：由于rebase会改变提交历史，因此在与他人共享分支时要特别小心。通常，在公共分支上应该使用merge而不是rebase。 通过掌握git rebase的用法和注意事项，你可以更有效地管理你的Git仓库，保持代码的清晰和整洁。\n​\n# 扩展 # .gitignore文件 Git提供了.gitignore文件，用于指定哪些文件或目录应该被Git忽略，不纳入版本控制系统中。.gitignore文件是一个文本文件，可以包含一些简单的规则，指定应该忽略哪些文件或目录。以下是一些.gitignore文件的示例规则：\n忽略所有以.tmp结尾的文件：\n1 *.tmp 忽略所有的log文件：\n1 *.log 忽略所有的.idea目录：\n1 .idea/ 忽略所有的build目录及其内容：\n1 build/ 忽略根目录下的config.json文件，但不忽略子目录中的config.json文件：\n1 /config.json 忽略所有的node_modules目录及其内容：\n1 node_modules/ 忽略所有的DS_Store文件（Mac OS X系统中的文件）：\n1 .DS_Store 可以将这些规则写入.gitignore文件中，并将该文件添加到Git仓库中，以使Git忽略这些文件或目录。需要注意的是，即使某些文件或目录已经被添加到Git仓库中，也可以通过修改.gitignore文件来让Git忽略它们，但需要执行以下命令才能使.gitignore文件生效：\n1 2 3 4 git rm -r --cached . git add . git commit -m \u0026#34;update .gitignore\u0026#34; git push 这些命令会删除Git缓存中已经添加的文件，然后重新添加文件并提交更改，以使.gitignore文件生效。\n总结：\n当Git执行提交操作时，它会检查.gitignore文件中列出的文件和目录，并将它们从提交中排除。这是非常有用的，因为有些文件或目录不应该被纳入版本控制系统中，例如编译生成的文件、日志文件、临时文件等。\n.gitignore文件的语法是基于模式匹配的，其中的特殊字符有：\n*：匹配任意字符，但不包括路径分隔符（/）。 ?：匹配任意单个字符，但不包括路径分隔符（/）。 /：路径分隔符，用于指定目录。 !：用于否定模式，即不忽略指定的文件或目录。 可以在.gitignore文件中使用通配符、路径、注释等语法，以更精确地指定需要忽略的文件或目录。同时，可以在仓库的根目录下创建一个.gitignore文件，也可以在子目录中创建独立的.gitignore文件。\n# git账户认证 当我们对远程仓库就行修改时，需要对应的权限，不是什么人都能够修改仓库。只有通过了git账户认证，才能修改对应的仓库。 常见git账户认证的方式： SSH秘钥认证 这是Git中最常见的认证方式之一。用户首先生成一对公钥和私钥，然后将公钥添加到Git服务器上的用户帐户中。当用户尝试与Git服务器进行通信时，Git将使用私钥进行身份验证。这种方式相对安全，因为私钥是保存在用户本地机器上的，不会被传输到Git服务器。 秘钥生成命令：bash中运行ssh-keygen,一直回车就行，秘钥位置：主目录下的.ssh目录 公钥设置位置：github账户Settings-\u0026gt;SSH and GPG keys-\u0026gt;New SSH key将公钥复制粘贴保存就行。 HTTPS认证 在这种方式中，用户需要提供用户名和密码进行身份验证。用户需要在Git服务器上创建一个用户帐户，并将其关联到本地的Git仓库中。当用户执行需要身份验证的操作时，Git会要求输入用户名和密码。这种方式相对简单，适用于个人项目或小型团队。 设置位置：在使用Git进行操作时，如push或pull，系统会提示你输入用户名和密码进行身份验证。 访问令牌（Personal Access Token）认证：不常用 访问令牌提供了一种更安全、更灵活的身份验证方式，因为它可以限制令牌的使用权限，并且可以随时撤销或重新生成令牌。 设置位置：github账户Settings-\u0026gt;Developer Settings-\u0026gt;Personal access tokens-\u0026gt;Tokens (classic)-\u0026gt;Generate new token，然后根据自己的需求设置token的权限。 # ssh-keygen ssh-keygen命令是一个用于生成、管理和转换SSH认证密钥的工具。它支持RSA和DSA两种认证密钥类型，并且提供了多种选项和参数，以满足不同的需求。\n使用ssh-keygen命令，你可以生成新的密钥对，指定密钥的长度、类型以及保存的文件名。生成的私钥将保存在本地，而公钥则用于在SSH服务器上进行身份验证。\n以下是一些常用的ssh-keygen命令选项：\n-t：指定要创建的密钥类型，默认为RSA。 -b：指定密钥长度（以位为单位）。对于RSA密钥，最小要求是768位，默认是2048位。对于DSA密钥，长度必须是1024位（根据FIPS 1862标准规定）。 -f：指定用于保存密钥的文件名。如果不指定，将使用默认值id_rsa（对于私钥）和id_rsa.pub（对于公钥）。 -C：提供一个新注释，通常用于标识密钥的用途或所有者。 -P 和 -N：分别用于提供旧密码和新密码，以保护私钥文件。如果留空，则表示不需要密码。 在生成密钥对后，你可以将公钥复制到需要访问的SSH服务器上，通常是将公钥内容追加到服务器的~/.ssh/authorized_keys文件中。这样，当你使用SSH客户端连接到服务器时，客户端将使用私钥进行身份验证，如果验证成功，你将能够无需输入密码即可登录到服务器。\n请注意，私钥的安全性至关重要。私钥应该妥善保管，并且不应该与其他人共享。同时，定期更换密钥对也是保持安全性的好习惯。\n除了生成和管理密钥对，ssh-keygen还提供了其他功能，如转换密钥格式、读取密钥文件等。你可以通过查看ssh-keygen的帮助文档或手册页（通过运行man ssh-keygen命令）来获取更详细的信息和用法示例。\n","date":"2024-04-22T22:18:17+08:00","permalink":"https://arlettebrook.github.io/p/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","title":"Git常用命令"},{"content":" # 简介 flag用于解析命令行选项。有过类 Unix 系统使用经验的童鞋对命令行选项应该不陌生。例如命令ls -al列出当前目录下所有文件和目录的详细信息，其中-al就是命令行选项。\n命令行选项在实际开发中很常用，特别是在写工具的时候。\n指定配置文件的路径，如redis-server ./redis.conf以当前目录下的配置文件redis.conf启动 Redis 服务器； 自定义某些参数，如python -m SimpleHTTPServer 8080启动一个 HTTP 服务器，监听 8080 端口。如果不指定，则默认监听 8000 端口。 # 快速使用 学习一个库的第一步当然是使用它。我们先看看flag库的基本使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;flag\u0026#34; ) var ( intflag int boolflag bool stringflag string ) func init() { flag.IntVar(\u0026amp;intflag, \u0026#34;intflag\u0026#34;, 0, \u0026#34;int flag value\u0026#34;) flag.BoolVar(\u0026amp;boolflag, \u0026#34;boolflag\u0026#34;, false, \u0026#34;bool flag value\u0026#34;) flag.StringVar(\u0026amp;stringflag, \u0026#34;stringflag\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;string flag value\u0026#34;) } func main() { flag.Parse() fmt.Println(\u0026#34;int flag:\u0026#34;, intflag) fmt.Println(\u0026#34;bool flag:\u0026#34;, boolflag) fmt.Println(\u0026#34;string flag:\u0026#34;, stringflag) } 可以先编译程序，然后运行（我使用的是 Win10 + Git Bash）：\n1 2 $ go build -o main.exe main.go $ ./main.exe -intflag 12 -boolflag 1 -stringflag test 输出：\n1 2 3 int flag: 12 bool flag: true string flag: test 如果不设置某个选项，相应变量会取默认值：\n1 $ ./main.exe -intflag 12 -boolflag 1 输出：\n1 2 3 int flag: 12 bool flag: true string flag: default 可以看到没有设置的选项stringflag为默认值default。\n还可以直接使用go run，这个命令会先编译程序生成可执行文件，然后执行该文件，将命令行中的其它选项传给这个程序。\n1 go run main.go -intflag 12 -boolflag 1 可以使用-h显示选项帮助信息：\n1 2 3 4 5 6 7 8 $ ./main.exe -h Usage of D:\\code\\golang\\src\\github.com\\darjun\\cmd\\flag\\main.exe: -boolflag bool flag value -intflag int int flag value -stringflag string string flag value (default \u0026#34;default\u0026#34;) 总结一下，使用flag库的一般步骤：\n定义一些全局变量存储选项的值，如这里的intflag/boolflag/stringflag； 在init方法中使用flag.TypeVar方法定义选项，这里的Type可以为基本类型Int/Uint/Float64/Bool，还可以是时间间隔time.Duration。定义时传入变量的地址、选项名、默认值和帮助信息； 在main方法中调用flag.Parse从os.Args[1:]中解析选项。因为os.Args[0]为可执行程序路径，会被剔除。 注意点：\nflag.Parse方法必须在所有选项都定义之后调用，且flag.Parse调用之后不能再定义选项。如果按照前面的步骤，基本不会出现问题。 因为init在所有代码之前执行，将选项定义都放在init中，main函数中执行flag.Parse时所有选项都已经定义了。\n# 选项格式 flag库支持三种命令行选项格式。\n1 2 3 -flag -flag=x -flag x -和--都可以使用，它们的作用是一样的。有些库使用-表示短选项，--表示长选项。相对而言，flag使用起来更简单。\n第一种形式只支持布尔类型的选项，出现即为true，不出现为默认值。 第三种形式不支持布尔类型的选项。因为这种形式的布尔选项在类 Unix 系统中可能会出现意想不到的行为。看下面的命令：\n1 cmd -x * 其中，*是 shell 通配符。如果有名字为 0、false的文件，布尔选项-x将会取false。反之，布尔选项-x将会取true。而且这个选项消耗了一个参数。 如果要显示设置一个布尔选项为false，只能使用-flag=false这种形式。\n遇到第一个非选项参数（即不是以-和--开头的）或终止符--，解析停止。运行下面程序：\n1 $ ./main.exe noflag -intflag 12 将会输出：\n1 2 3 int flag: 0 bool flag: false string flag: default 因为解析遇到noflag就停止了，后面的选项-intflag没有被解析到。所以所有选项都取的默认值。\n运行下面的程序：\n1 $ ./main.exe -intflag 12 -- -boolflag=true 将会输出：\n1 2 3 int flag: 12 bool flag: false string flag: default 首先解析了选项intflag，设置其值为 12。遇到--后解析终止了，后面的--boolflag=true没有被解析到，所以boolflag选项取默认值false。\n解析终止之后如果还有命令行参数，flag库会存储下来，通过flag.Args方法返回这些参数的切片。 可以通过flag.NArg方法获取未解析的参数数量，flag.Arg(i)访问位置i（从 0 开始）上的参数。 选项个数也可以通过调用flag.NFlag方法获取。\n稍稍修改一下上面的程序：\n1 2 3 4 5 6 7 8 9 10 11 func main() { flag.Parse() fmt.Println(flag.Args()) fmt.Println(\u0026#34;Non-Flag Argument Count:\u0026#34;, flag.NArg()) for i := 0; i \u0026lt; flag.NArg(); i++ { fmt.Printf(\u0026#34;Argument %d: %s\\n\u0026#34;, i, flag.Arg(i)) } fmt.Println(\u0026#34;Flag Count:\u0026#34;, flag.NFlag()) } 编译运行该程序：\n1 2 $ go build -o main.exe main.go $ ./main.exe -intflag 12 -- -stringflag test 输出：\n1 2 3 4 [-stringflag test] Non-Flag Argument Count: 2 Argument 0: -stringflag Argument 1: test 解析遇到--终止后，剩余参数-stringflag test保存在flag中，可以通过Args/NArg/Arg等方法访问。\n整数选项值可以接受 1234（十进制）、0664（八进制）和 0x1234（十六进制）的形式，并且可以是负数。实际上flag在内部使用strconv.ParseInt方法将字符串解析成int。 所以理论上，ParseInt接受的格式都可以。\n布尔类型的选项值可以为：\n取值为true的：1、t、T、true、TRUE、True； 取值为false的：0、f、F、false、FALSE、False。 # 另一种定义选项的方式 上面我们介绍了使用flag.TypeVar定义选项，这种方式需要我们先定义变量，然后变量的地址。 还有一种方式，调用flag.Type（其中Type可以为Int/Uint/Bool/Float64/String/Duration等）会自动为我们分配变量，返回该变量的地址。用法与前一种方式类似：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;flag\u0026#34; ) var ( intflag *int boolflag *bool stringflag *string ) func init() { intflag = flag.Int(\u0026#34;intflag\u0026#34;, 0, \u0026#34;int flag value\u0026#34;) boolflag = flag.Bool(\u0026#34;boolflag\u0026#34;, false, \u0026#34;bool flag value\u0026#34;) stringflag = flag.String(\u0026#34;stringflag\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;string flag value\u0026#34;) } func main() { flag.Parse() fmt.Println(\u0026#34;int flag:\u0026#34;, *intflag) fmt.Println(\u0026#34;bool flag:\u0026#34;, *boolflag) fmt.Println(\u0026#34;string flag:\u0026#34;, *stringflag) } 编译并运行程序：\n1 2 $ go build -o main.exe main.go $ ./main.exe -intflag 12 将输出：\n1 2 3 int flag: 12 bool flag: false string flag: default 除了使用时需要解引用，其它与前一种方式基本相同。\n# 高级用法 # 定义短选项 flag库并没有显示支持短选项，但是可以通过给某个相同的变量设置不同的选项来实现。即两个选项共享同一个变量。 由于初始化顺序不确定，必须保证它们拥有相同的默认值。否则不传该选项时，行为是不确定的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;flag\u0026#34; ) var logLevel string func init() { const ( defaultLogLevel = \u0026#34;DEBUG\u0026#34; usage = \u0026#34;set log level value\u0026#34; ) flag.StringVar(\u0026amp;logLevel, \u0026#34;log_type\u0026#34;, defaultLogLevel, usage) flag.StringVar(\u0026amp;logLevel, \u0026#34;l\u0026#34;, defaultLogLevel, usage + \u0026#34;(shorthand)\u0026#34;) } func main() { flag.Parse() fmt.Println(\u0026#34;log level:\u0026#34;, logLevel) } 编译、运行程序：\n1 2 3 $ go build -o main.exe main.go $ ./main.exe -log_type WARNING $ ./main.exe -l WARNING 使用长、短选项均输出：\n1 log level: WARNING 不传入该选项，输出默认值：\n1 2 $ ./main.exe log level: DEBUG # 解析时间间隔 除了能使用基本类型作为选项，flag库还支持time.Duration类型，即时间间隔。时间间隔支持的格式非常之多，例如\u0026quot;300ms\u0026quot;、\u0026quot;-1.5h\u0026quot;、“2h45m\u0026quot;等等等等。 时间单位可以是 ns/us/ms/s/m/h/day 等。实际上flag内部会调用time.ParseDuration。具体支持的格式可以参见time（需fq）库的文档。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import ( \u0026#34;flag\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) var ( period time.Duration ) func init() { flag.DurationVar(\u0026amp;period, \u0026#34;period\u0026#34;, 1*time.Second, \u0026#34;sleep period\u0026#34;) } func main() { flag.Parse() fmt.Printf(\u0026#34;Sleeping for %v...\u0026#34;, period) time.Sleep(period) fmt.Println() } 根据传入的命令行选项period，程序睡眠相应的时间，默认 1 秒。编译、运行程序：\n1 2 3 4 5 6 $ go build -o main.exe main.go $ ./main.exe Sleeping for 1s... $ ./main.exe -period 1m30s Sleeping for 1m30s... # 自定义选项 除了使用flag库提供的选项类型，我们还可以自定义选项类型。我们分析一下标准库中提供的案例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 package main import ( \u0026#34;errors\u0026#34; \u0026#34;flag\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;time\u0026#34; ) type interval []time.Duration func (i *interval) String() string { return fmt.Sprint(*i) } func (i *interval) Set(value string) error { if len(*i) \u0026gt; 0 { return errors.New(\u0026#34;interval flag already set\u0026#34;) } for _, dt := range strings.Split(value, \u0026#34;,\u0026#34;) { duration, err := time.ParseDuration(dt) if err != nil { return err } *i = append(*i, duration) } return nil } var ( intervalFlag interval ) func init() { flag.Var(\u0026amp;intervalFlag, \u0026#34;deltaT\u0026#34;, \u0026#34;comma-seperated list of intervals to use between events\u0026#34;) } func main() { flag.Parse() fmt.Println(intervalFlag) } 首先定义一个新类型，这里定义类型interval。\n新类型必须实现flag.Value接口：\n1 2 3 4 5 // src/flag/flag.go type Value interface { String() string Set(string) error } 其中String方法格式化该类型的值，flag.Parse方法在执行时遇到自定义类型的选项会将选项值作为参数调用该类型变量的Set方法。 这里将以,分隔的时间间隔解析出来存入一个切片中。\n自定义类型选项的定义必须使用flag.Var方法。\n编译、执行程序：\n1 2 3 4 5 $ go build -o main.exe main.go $ ./main.exe -deltaT 30s [30s] $ ./main.exe -deltaT 30s,1m,1m30s [30s 1m0s 1m30s] 如果指定的选项值非法，Set方法返回一个error类型的值，Parse执行终止，打印错误和使用帮助。\n1 2 3 4 5 $ ./main.exe -deltaT 30x invalid value \u0026#34;30x\u0026#34; for flag -deltaT: time: unknown unit x in duration 30x Usage of D:\\code\\golang\\src\\github.com\\darjun\\go-daily-lib\\flag\\self-defined\\main.exe: -deltaT value comma-seperated list of intervals to use between events # 解析程序中的字符串 有时候选项并不是通过命令行传递的。例如，从配置表中读取或程序生成的。这时候可以使用flag.FlagSet结构的相关方法来解析这些选项。\n实际上，我们前面调用的flag库的方法，都会间接调用FlagSet结构的方法。flag库中定义了一个FlagSet类型的全局变量CommandLine专门用于解析命令行选项。 前面调用的flag库的方法只是为了提供便利，它们内部都是调用的CommandLine的相应方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // src/flag/flag.go var CommandLine = NewFlagSet(os.Args[0], ExitOnError) func Parse() { CommandLine.Parse(os.Args[1:]) } func IntVar(p *int, name string, value int, usage string) { CommandLine.Var(newIntValue(value, p), name, usage) } func Int(name string, value int, usage string) *int { return CommandLine.Int(name, value, usage) } func NFlag() int { return len(CommandLine.actual) } func Arg(i int) string { return CommandLine.Arg(i) } func NArg() int { return len(CommandLine.args) } 同样的，我们也可以自己创建FlagSet类型变量来解析选项。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package main import ( \u0026#34;flag\u0026#34; \u0026#34;fmt\u0026#34; ) func main() { args := []string{\u0026#34;-intflag\u0026#34;, \u0026#34;12\u0026#34;, \u0026#34;-stringflag\u0026#34;, \u0026#34;test\u0026#34;} var intflag int var boolflag bool var stringflag string fs := flag.NewFlagSet(\u0026#34;MyFlagSet\u0026#34;, flag.ContinueOnError) fs.IntVar(\u0026amp;intflag, \u0026#34;intflag\u0026#34;, 0, \u0026#34;int flag value\u0026#34;) fs.BoolVar(\u0026amp;boolflag, \u0026#34;boolflag\u0026#34;, false, \u0026#34;bool flag value\u0026#34;) fs.StringVar(\u0026amp;stringflag, \u0026#34;stringflag\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;string flag value\u0026#34;) fs.Parse(args) fmt.Println(\u0026#34;int flag:\u0026#34;, intflag) fmt.Println(\u0026#34;bool flag:\u0026#34;, boolflag) fmt.Println(\u0026#34;string flag:\u0026#34;, stringflag) } NewFlagSet方法有两个参数，第一个参数是程序名称，输出帮助或出错时会显示该信息。第二个参数是解析出错时如何处理，有几个选项：\nContinueOnError：发生错误后继续解析，CommandLine就是使用这个选项； ExitOnError：出错时调用os.Exit(2)退出程序； PanicOnError：出错时产生 panic。 随便看一眼flag库中的相关代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // src/flag/flag.go func (f *FlagSet) Parse(arguments []string) error { f.parsed = true f.args = arguments for { seen, err := f.parseOne() if seen { continue } if err == nil { break } switch f.errorHandling { case ContinueOnError: return err case ExitOnError: os.Exit(2) case PanicOnError: panic(err) } } return nil } 与直接使用flag库的方法有一点不同，FlagSet调用Parse方法时需要显示传入字符串切片作为参数。因为flag.Parse在内部调用了CommandLine.Parse(os.Args[1:])。 示例代码都放在GitHub上了。\n# 参考 flag库文档 Go 每日一库之 flag 深入探究 Go flag 标准库附源码分析 ","date":"2024-04-22T18:02:17+08:00","permalink":"https://arlettebrook.github.io/p/go-flag%E5%BA%93%E4%BB%8B%E7%BB%8D/","title":"Go flag库介绍"},{"content":" # 静态网页生成器 无论您需要搭建个人博客还是为您的项目创建文档，静态网页生成器（static site generator）都是一个不错的选择。无需服务器、数据库，只要你熟悉 Markdown，喜欢GitHub，使用生成器创建静态 HTML 文件，然后推送到 GitHub Pages 等免费服务即可。\n# 常见的静态网页生成器 Hugo是由Go语言实现的静态网站生成器。简单、易用、高效、易扩展、快速部署。 jekyll 是一个静态网页、博客生成器 vuepress是基于 Vue 的静态网页生成器 Hexo 是一个由Nodejs驱动的快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 参考：静态网页生成器\n# 快速使用Hugo搭建个人博客站点 # 安装Hugo 根据自己的操作系统，下载已经构建好的Hugo二进制文件官方地址\n官方推荐下载扩展版，支持的功能更多 解压之后，将hugo可执行文件加入到PATH环境变量中，即可使用\n1 2 3 hugo version # 查看版本，扩展版含这个extended标签 hugo -h # 显示帮助信息 hugo subcommand -h # 获取子命令的帮助信息 # 使用Hugo hugo需要配合git一起使用，并且官方推荐使用bash作为终端\n创建项目并安装主题hugo-theme-stack\n1 2 3 4 5 hugo new site quickstart # 创建目录结构 cd quickstart git init git submodule add https://github.com/CaiJimmy/hugo-theme-stack/ themes/hugo-theme-stack # 安装主题 添加内容并使用安装主题的默认配置\n使用安装主题的实例进行快速添加内容 只需要进入主题文件中的exampleSite中的content拷贝到quickstart根目录中 同理，在主题文件中的exampleSite中的hugo.yaml拷贝到quickstart根目录中，重命名为,并删除hugo.toml 最后运行\n1 2 hugo server # 本地启动一个http服务器，便于开发和测试站点，默认热更新 hugo server --navigateToChanged # 自动重定向：编辑内容时，浏览器会自动重定向到上次修改的页面 会使用到的命令\n1 2 3 4 5 6 7 8 9 10 11 hugo new content post/fist-post.md # 会在content目录下创建post/fist-post.md文件 # 执行完后，会在content/post目录自动生成一个MarkDown格式的first.md文件： +++ date = \u0026#34;2015-01-08T08:36:54-07:00\u0026#34; draft = true title = \u0026#34;Fist Post\u0026#34; +++ # draft 默认为true，构建网站时不会构建该文档 # 要构建草稿文档可以用-D或--buildDrafts选项启动服务 hugo server -D # title 默认为文件名首字母大写 构建命令\n进入项目目录，运行\n1 hugo hugo命令会构建生成静态文件，会将文件发布项目的public目录下\n要将站点发布到其他目录，请使用该标志--destination或在站点配置中设置publishDir\n注意：每次构建不会清空public目录，只会覆盖旧内容。\n这样做是为了防止，构建之后在public添加的文件被删除\n草稿、未来和过期内容\nHugo 允许在内容的前面设置draft、date、publishDate和expiryDate。默认情况下，Hugo 在以下情况下不会发布内容：\n其draft值为true\n是date在未来\n是publishDate在未来\n已经expiryDate过去了\n下面的行为可以取消\n1 2 3 hugo --buildDrafts # or -D hugo --buildExpired # or -E hugo --buildFuture # or -F 注意：当这样构建之后，需要手动删除不期望构建的文件，在推送站点\n否则当推送到远程会出现意外的内容\n所以建议运行上面的命令之后，前提public中没有手动添加的文件，在构建之前手动清空public目录，防止出现草稿、过期和未来的内容\n最后将public中的所以文件推送到静态网站托管平台即可\n也可以使用自动构建和部署 更多内容参考：\n使用hugo搭建个人博客站点 （1）带着Stack主题入坑Hugo （2）部署你的Hugo博客 （3）Stack主题的自定义 自定义主题添加了assets/scss、layouts/_default/、layouts/index.html,不用了删了就行 # 目录结构 archetypes目录包含新内容的模板\n目录下的default.md由标记（markdown）和内容格式\n内容格式：\u0026mdash;yaml\u0026mdash;、+++toml+++、{json}\n1 2 3 4 5 --- # +++/{ date: \u0026#39;{{ .Date }}\u0026#39; # yaml draft: true title: \u0026#39;{{ replace .File.ContentBaseName `-` ` ` | title }}\u0026#39; --- # +++/{ 当运行hugo new content post/my-first-post.md命令时会根据default.md创建内容文件\n1 2 3 4 5 --- date: \u0026#34;2023-08-24T11:49:46-07:00\u0026#34; draft: true title: My First Post --- 可以创建新内容的模版\n1 2 3 archetypes/ ├── default.md └── post.md 若运行hugo new content post/my-first-post.md查找模版的顺序 archetypes/post.md archetypes/default.md themes/my-theme/archetypes/post.md themes/my-theme/archetypes/default.md 如果这些都不存在，Hugo 将使用内置的默认原型 assets目录包含通常通过资产管道传递的全局资源，包括图像、CSS、Sass、JavaScript 和 TypeScript 等资源。\nconfig目录包含站点配置，可能分为多个子目录和文件。对于具有最少配置的项目或不需要在不同环境中表现不同的项目，hugo.toml在项目根目录中命名的单个配置文件就足够了\ncontent目录包含构成站点内容的标记文件（通常是 Markdown）和页面资源。\n对应stack主题： post存放发布的文章格式md page存放导航区域的md格式配置 不同的语言结尾用.en.md等表示 根据模版进行修改即可，根据自己的需求，没有的需要自己补充和修改文件内容 categories存放类别的md格式配置 data目录包含增强内容、配置、本地化和导航的数据文件（JSON、TOML、YAML 或 XML）。\ni18n目录包含多语言站点的翻译表。\ncontent目录包含将内容、数据和资源转换为完整网站的模板。\npublic目录包含运行hugo或hugo server命令时生成的已发布网站。 Hugo 根据需要重新创建该目录及其内容\nresources目录包含 Hugo 资产管道的缓存输出，这些输出是在运行hugo或hugo server命令时生成的。默认情况下，此缓存目录包括 CSS 和图像。 Hugo 根据需要重新创建该目录及其内容。\nstatic目录包含在您构建站点时将复制到公共目录的文件。例如：favicon.ico、robots.txt和 验证站点所有权的文件.与assets差不多\nthemes目录包含一个或多个主题，每个主题都位于其自己的子目录中。\n联合文件系统：\n这样理解：安装的主题里面同样有自己站点的目录结构，hugo构建时会将主题里面的文件挂载到站点，优先级是站点的高 # 配置文件 hugo支持三种配置文件hugo.tomal、hugo.yaml、hugo.json，喜欢用那个就用那个。\n每种文件格式的规范：TOML、YAML和JSON。\n配置文件可以有多个，可以放到config目录下，默认都是使用hugo开头的文件\n指定配置文件构建\n1 2 hugo server --config other.toml hugo --config a.toml,b.yaml,c.json # 可以指定多个，左边的优先级高 更多内容配置参考\n额外的一些关于配置文件的总结\n默认语言修改为zh-cn，意味着index.md表示中文，index.zh-cn.md也表示中文，此时的英文要用index.en.md表示 更多内容参考：\nHugo官方文档 Hugo中文文档 Hugo theme # 文章评论 使用Waline，其教程很完整。\n根据Waline教程从头完成到使用Vercel部署完成。\n最后在config.yaml中的waline的serverURL给上你的Vercel服务器地址。\n以及开启评论，最后waline还可以配置评论通知渠道。\n将cloudflare解析的域名绑定到vercel文档 概括：添加一条CNAME记录值为cname.vercel-dns.com，开启代理，将SSL/TLS修改为完全 将cloudflare解析的域名绑定到github-pages文档 概括：添加一条子域，类型CNAME记录值为username.github.io，开启代理，将SSL/TLS修改为完全,username为你的用户名 更多内容请查阅文档 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 comments: enabled: true provider: waline waline: serverURL: url lang: zh-cn pageview: true copyright: false emoji: - https://unpkg.com/@waline/emojis@1.0.1/weibo requiredMeta: - name - email locale: admin: 👻Hi! placeholder: 🎉留下你的脚印... # 搜索引擎优化（SEO） 本网站使用Hugo搭建，而且使用的stack主题支持自动生成基于Open Graph协议（OG协议）的标签，此处记录一下如何在Hugo搭建的网站中做搜索引擎优化（SEO）。\n目的：提升网站在搜索引擎中的排名\nOpen Graph（开放图谱）协议，简称OG协议，是Facebook在2010年公布的一项协议，用来标记网页内容。简单来讲，OG协议就是嵌在网页头部的一些标签，这些标签标记了网页的标题、描述等特征，使得网页成为一个“富媒体对象”，可以被其他社交网站引用。\n很多搜索引擎都支持OG协议，在网页中使用OG协议的标签，就更有利于提升我们的网页在搜索引擎中的排名。\nOG协议的标签在网页中通常表示为类似下面所示的格式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;meta property=\u0026#34;og:title\u0026#34; content=\u0026#34;The Rock\u0026#34; /\u0026gt; \u0026lt;meta property=\u0026#34;og:type\u0026#34; content=\u0026#34;video.movie\u0026#34; /\u0026gt; \u0026lt;meta property=\u0026#34;og:url\u0026#34; content=\u0026#34;https://www.imdb.com/title/tt0117500/\u0026#34; /\u0026gt; \u0026lt;meta property=\u0026#34;og:image\u0026#34; content=\u0026#34;https://ia.media-imdb.com/images/rock.jpg\u0026#34; /\u0026gt; \u0026lt;meta property=\u0026#39;og:url\u0026#39; content=\u0026#39;https://arlettebrook.github.io/search/\u0026#39;\u0026gt; \u0026lt;meta property=\u0026#39;og:site_name\u0026#39; content=\u0026#39;Arlettebrook\u0026amp;#39;s blog\u0026#39;\u0026gt; \u0026lt;meta property=\u0026#39;og:type\u0026#39; content=\u0026#39;article\u0026#39;\u0026gt;\u0026lt;meta property=\u0026#39;article:section\u0026#39; content=\u0026#39;P age\u0026#39; /\u0026gt; -\u0026lt;meta name=\u0026#34;twitter:title\u0026#34; content=\u0026#34;搜索\u0026#34;\u0026gt; +\u0026lt;meta name=\u0026#34;twitter:site\u0026#34; content=\u0026#34;@arlettebrook\u0026#34;\u0026gt; + \u0026lt;meta name=\u0026#34;twitter:creator\u0026#34; content=\u0026#34;@arlettebrook\u0026#34;\u0026gt;\u0026lt;meta name=\u0026#34;twitter:title\u0026#34; co ntent=\u0026#34;搜索\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;twitter:description\u0026#34; content=\u0026#34;\u0026#34;\u0026gt;\u0026lt;link rel=\u0026#34;alternate\u0026#34; type=\u0026#34;application/js on\u0026#34; href=\u0026#34;https://arlettebrook.github.io/search/index.json\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;shortcut icon\u0026#34; href=\u0026#34;/img/favicon.ico\u0026#34; /\u0026gt; stack主题提供了对OG协议的支持，只需要在网站根目录下的config/_default/params.en.yaml和config/_default/params.zh-cn.yaml配置文件中开启即可：\n1 2 3 4 5 6 7 opengraph: twitter: # Your Twitter username site: arlettebrook # Available values: summary, summary_large_image card: summary_large_image 这样，Hugo在生成和部署网站时就会在网页HTML文件中自动嵌入OG标签。\n# 谷歌搜索优化 在将我们的站点信息提交给谷歌时，谷歌需要验证我们对网站的所有权。验证方式有好几种，例如\n在网站根目录下放一个谷歌生成的验证文件 在网页HTML文件头部嵌入谷歌生成的特定标签 使用谷歌分析的Tracking ID（或者Measurement ID） 由于stack主题集成了对谷歌分析的支持，这里我们使用第三种验证方式。\n# 开启谷歌分析 谷歌分析（Google Analytics）是一个分析网站流量的工具，用它可以统计网站的访问量等信息。\n首先前往谷歌分析官网注册谷歌分析的账号，也可以直接用已有的谷歌账号登录。现在的谷歌分析一般是谷歌分析4（Google Analytics 4），使用Measurement ID而非之前的Tracking ID来跟踪网站。\n参考：谷歌分析（Google Analytics）最新使用教程\n获取Measurement ID。具体可参见谷歌分析的帮助文档。下面是具体操作：\n在用户首页找到“Admin“选项，新建一个“Property”，按照说明填入必要的信息。 然后点击“Property”这一列中的“Data Streams”选项。 点击“Add stream”，选择“Web”，填入你的网站域名和网站名字。 再在“Property”页面点击刚添加的stream，就能看到一个以“G-”开头的Measurement ID。记录下你的网站的Measurement ID。 在网站根目录下的config/_default/config.yaml配置文件中找到“googleAnalytics\u0026quot;配置项，填入你的Measurement ID。\n1 2 # GA Tracking ID googleAnalytics: G-measuremntID # 提交站点地图 站点地图（Site Map）是一个存储有站点网页信息的XML数据文件，通常命名为sitemap.xml，将它提交给搜索引擎，搜索引擎将可以获取我们网站的网页信息。\nHugo会在生成和部署网站时在public文件夹下自动生成sitemap.xml文件。\n我们把站点地图提交到谷歌搜索，具体说明可参见谷歌站长页面的说明，下面是具体操作：\n登录谷歌搜索控制台（Google Search Console）https://search.google.com/search-console，可以使用在谷歌分析注册的账号。\n点击左上角的“Add property”，选择右侧的“URL prefix”方式，输入以https开头的网站网址。在验证所有权的选项中选择“Google Analytics”，点击验证。如果你在上一步开启谷歌分析后使用Hugo重新部署了网站的话，就可以直接验证通过。\n提交站点地图文件sitemap.xml。在左侧菜单栏点击“Sitemaps”选项，然后在添加站点地图的页面填入sitemap.xml所在的URL。例如对于本站，由于是双语站点，Hugo在部署网站时会生成3个sitemap.xml文件，分别是/public/sitemap.xml、/public/zh-cn/sitemap.xml以及/public/en/sitemap.xml。\n注意，添加sitemap时不要漏了路径开头的斜杠/，即使网站域名后面已经有一个斜杠了，也不能省略。\n提交成功之后“status”会显示“success”。\nHugo生成的3个站点地图中，/public/sitemap.xml中的内容其实是指向/public/zh-cn/sitemap.xml和/public/en/sitemap.xml的，所以我们只提交一个/public/sitemap.xml就可以。\n一般在站点地图成功提交之后大约1到2天后，就可以看到自己的网站已经被谷歌收录了。可以在谷歌搜索框中输入site:xxx.com来查看某个网站是否被谷歌搜索收录。\n# 百度搜索优化 针对百度搜索的优化是在百度资源搜索平台上完成的。\n前往百度资源搜索平台，登录百度账号。\n点击“链接提交”，然后点击\u0026quot;添加站点\u0026quot;。输入你的网站域名，同样需要验证站点的所有权，这里选择下载验证文件，然后把验证文件放在网站static文件夹内，在上传到Github。最后点击“验证”即可。\n然后点击左侧菜单栏“资源提交”中的“普通收录”，在资源提交的页面下选择“sitemap”，输入sitemap.xml所在的URL就可以了。\n不过在百度提交sitemap有两个限制：\n不允许提交索引型sitemap 对新账号每天只允许提交一个sitemap文件 # 其他平台收录 其他平台收录就不仔细讲解了，提供一下链接供大家参考。都差不多一样的验证方式。\n搜狗收录\n搜狗收录不支持站点地图提交，需要你列出所有的url批量提交，每次提交20条，所以没有其他平台那么智能。每次新加新的网页还需要自己主动提交。\n搜狗搜索资源平台\nBing收录\nMicrosoft Bing Webmaster Tools\n360提交入口： https://info.so.com/site_submit.html\nBackdata 搜索引擎网址提交入口： https://backdata.net/submit-site.html\n参考：\n个人网站的建立过程（四）：网站的搜索引擎优化（SEO） 从零开始搭建个人博客网站系列 五、让搜索引擎收录你的个人博客网站 # 额外的一些知识 gh-pages 是GitHub 所提供的一个服务，简单来讲就是可以让你不用花钱也可以部署一个静态网页作为展示用，因此对于前端工程师来讲就非常方便而且很实用，但是部署方式有很多。\ngh-pages是github-pages的缩写，可以用于个人博客和项目介绍的网站服务。\ngh-pages也是github特殊的分支，用来存放网站相关的一些资源，通常网站地址为username.github.io/仓库名\n项目名与username.github.io一样的话，可以省略仓库名，跟github个人资料页面一样，所以这个仓库是一个特殊的仓库，默认会自动开启gh-pages服务。别的需要手动。\n虽然gh-pages 是属于免费的服务，基本上只要你持有GitHub 帐号就可以使用，但是它基本上有几个重点可以稍微注意一下：\n只能放置纯静态网页，也就是说没有后端的网页，例如PHP、Node.js、Python 等等，只能是纯HTML、CSS、JavaScript 等等，因为它并没有运算能力。 gh-pages 是以储存库为单位，也就是说每个储存库都可以有一个gh-pages 分支，但是每个储存库只能有一个gh-pages 分支，因此如果你想要部署多个网页，那么你就需要建立多个储存库。 gh-pages 的容量是有限制的，每个储存库的容量是1GB，如果你的网页超过这个容量，那么就无法部署。 gh-pages 的流量为每月100GB gh-pages 每小时只能部署10 次，如果是使用自己写的GitHub Actions 就没有这个限制（毕竟要花钱）。 免费的ssh 凭证 预设的网域是https://\u0026lt;username\u0026gt;.github.io/\u0026lt;repository\u0026gt;，如果你想要使用自己的网域，那么你就需要花钱购买网域，并且设定DNS 最后要稍微注意一下gh-pages 虽然是免费提供的静态网页托管服务，但是它并不能拿来作为商业用途或是违法用途，否则你的帐号可能会被封锁\n简单说一下如何查看一个仓库是否启用gh-pages：进入项目settings-pages查看即可，有绿色钩就启动成功，没有需要指定分支和根目录，保存，稍等一会就行。\n# 用gh-pages分支展示自己的项目 我们只需要将网页资源上传至gh-pages分支即可\n搭建项目网站：将项目网站资源推送到gh-pages分支上,静态资源必须提交了才会成功\n1 git subtree push --prefix=dist origin gh-pages # dist为项目网站的目录 拉取指定分支\n1 2 3 4 5 6 7 8 git fetch origin # 获取origin仓库的信息 git checkout -b aaa origin/aaa # 创建并检出分支 # git clone之后也也可以检出分支 git checkout gh-page # 失败用上面办法 # 在git clone 的时候可以指定分支-b选项 git clone -b url 如果要项目中不含自己网站的源码，可以忽略public目录，将public目录创建为一个私有仓库的子目录，然后将子目录作为，项目的gh-pages分支。\n# 通过GitHub Actions自动部署gh-pages 简单介绍一下GitHub Actions:\nGitHub Actions是一个自动化工具。 可以实现自动化构建、测试、和部署项目。 定义自动化过程是通过编写workflows（工作流）实现的，格式是yaml。 推送部署的github-pages需要git账户认证，方式是SSH秘钥认证。\n所以需要设置ssh秘钥。\n生成秘钥：在bash中运行ssh-keygen,秘钥类型默认为rsa。可以给这个秘钥设置备注加-C选项，参数一般为拥有者邮箱，一直回车就行。秘钥保存位置：默认用户主目录下的.ssh。公钥就是id_rsa.pub\n建议将生成的这个秘钥对与本机认证的ssh秘钥对分开，保存到另外的一个地方。回车的时候修改位置就行。 设置公钥：\ngithub账户Settings-\u0026gt;SSH and GPG keys-\u0026gt;New SSH key将公钥复制粘贴保存就行。这种方式，只有有私钥，就能操作所有仓库，不推荐使用。 (自动构建之后)选择要推送的仓库Settings-\u0026gt;Deploy keys-\u0026gt;Add deploy key将公钥复制粘贴保存就行。title随意。注意勾选Allow write access。只针对该仓库有权限。推荐使用。 设置私钥：\n进入Actions所在的仓库Settings-\u0026gt;Secrets and variables-\u0026gt;Actions-\u0026gt;New repository secret。秘钥名称为ACTIONS_DEPLOY_KEY，值为私钥id_rsa的文件内容。最后保存就行。 添加workflows配置文件\n在构建仓库的根目录下创建.github/workflows目录，然后创建auto-deploy-gh-pages.yaml文件，内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 name: Deploy github pages on: push: branches: - main # main 更新触发 # Allows you to run this workflow manually from the Actions tab workflow_dispatch: jobs: auto-deploy-github-pages: runs-on: ubuntu-latest steps: - name: Checkout code uses: actions/checkout@v4 with: submodules: true # clone submodules fetch-depth: 0 # 克隆所有历史信息 - name: Setup Hugo uses: peaceiris/actions-hugo@v3 with: hugo-version: \u0026#34;0.125.4\u0026#34; # Hugo 版本 extended: true # hugo插件版 Stack主题 必须启用 - name: Cache resources # 缓存 resource 文件加快生成速度 uses: actions/cache@v4 with: path: resources # 检查照片文件变化 key: ${{ runner.os }}-hugocache-${{ hashFiles(\u0026#39;content/**/*\u0026#39;) }} restore-keys: ${{ runner.os }}-hugocache- - name: Build # 生成网页 删除无用 resource 文件 削减空行 run: hugo --minify --gc - name: Deploy # 部署到 GitHub Page uses: peaceiris/actions-gh-pages@v3 with: # 如果在同一个仓库下使用请使用 github_token 并注释 deploy_key # github_token: ${{ secrets.GITHUB_TOKEN }} deploy_key: ${{ secrets.ACTIONS_DEPLOY_KEY }} # 如果在同一个仓库请注释 external_repository: arlettebrook/arlettebrook.github.io # 你的 GitHub page 仓库 example/example.github.io publish_branch: main # 默认gh-pages # cname: blog.trojan123.top # 自定义域名 publish_dir: ./public user_name: \u0026#34;github-actions[bot]\u0026#34; user_email: \u0026#34;github-actions[bot]@users.noreply.github.com\u0026#34; # full_commit_message: ${{ github.event.head_commit.message }} # 不带提交哈希 # full_commit_message: Deploy from ${{ github.repository }}@${{ github.sha }} 🚀 commit_message: ${{ github.event.head_commit.message }}🚀 # 带提交哈希 # full_commit_message: Deploy from ${{ github.repository }}@${{ github.sha }}🚀 ${{ github.event.head_commit.message }} 注意你要将external_repository项里的arlettebrook/arlettebrook.github.io改为你要推送的仓库。cname为你绑定的自定义域名。\n忽略不必要的文件\n在构建项目根目录下创建.gitignore文件，内容如下：\n1 2 3 4 public resources assets/jsconfig.json .hugo_build.lock 最后将构建项目推送到远程就行，这样每次推送构建项目的main分支到远程，就会自动构建并推送到指定仓库。\n查看是否构建成功：进入构建项目的Actions选项里面即可查看。\n参考：（2）部署你的Hugo博客\n","date":"2024-04-22T16:12:26+08:00","image":"https://arlettebrook.github.io/p/%E5%9F%BA%E4%BA%8Ehugo%E5%92%8Cgh-pages%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99/hugo_hu45a5e3ad5e058da6a00650ed8fd40bea_15530_120x120_fill_q75_box_smart1.jpg","permalink":"https://arlettebrook.github.io/p/%E5%9F%BA%E4%BA%8Ehugo%E5%92%8Cgh-pages%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99/","title":"基于Hugo和gh-pages快速搭建静态网站"}]