[{"content":" 在使用 Go 进行开发的过程中，命令行参数解析是我们经常遇到的需求。尽管 Go 标准库提供了 flag 包用于实现命令行参数解析，但只能满足基本需要，不支持高级特性。于是 Go 社区中出现了一个叫 pflag 的第三方包，功能更加全面且足够强大。在本文中，我们将学习并掌握如何使用 pflag。\n# 特点 pflag 作为 Go 内置 flag 包的替代品，具有如下特点：\n实现了 POSIX/GNU 风格的 –flags。 pflag 与《The GNU C Library》 中「25.1.1 程序参数语法约定」章节中 POSIX 建议语法兼容。 兼容 Go 标准库中的 flag 包。如果直接使用 flag 包定义的全局 FlagSet 对象 CommandLine，则完全兼容；否则当你手动实例化了 FlagSet 对象，这时就需要为每个标志设置一个简短标志（Shorthand）。 # 使用 # 基本用法 安装\n1 go get -u github.com/spf13/pflag 导入\n1 import \u0026#34;github.com/spf13/pflag\u0026#34; 使用\n我们可以像使用 Go 标准库中的 flag 包一样使用 pflag。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/spf13/pflag\u0026#34; ) type host struct { value string } func (h *host) String() string { return h.value } func (h *host) Set(v string) error { h.value = v return nil } func (h *host) Type() string { return \u0026#34;host\u0026#34; } func main() { var ip *int = pflag.Int(\u0026#34;ip\u0026#34;, 1234, \u0026#34;help message for ip\u0026#34;) var port int pflag.IntVar(\u0026amp;port, \u0026#34;port\u0026#34;, 8080, \u0026#34;help message for port\u0026#34;) var h host pflag.Var(\u0026amp;h, \u0026#34;host\u0026#34;, \u0026#34;help message for host\u0026#34;) // 解析命令行参数 pflag.Parse() fmt.Printf(\u0026#34;ip: %d\\n\u0026#34;, *ip) fmt.Printf(\u0026#34;port: %d\\n\u0026#34;, port) fmt.Printf(\u0026#34;host: %+v\\n\u0026#34;, h) fmt.Printf(\u0026#34;NFlag: %v\\n\u0026#34;, pflag.NFlag()) // 返回已设置的命令行标志个数 fmt.Printf(\u0026#34;NArg: %v\\n\u0026#34;, pflag.NArg()) // 返回处理完标志后剩余的参数个数 fmt.Printf(\u0026#34;Args: %v\\n\u0026#34;, pflag.Args()) // 返回处理完标志后剩余的参数列表 fmt.Printf(\u0026#34;Arg(1): %v\\n\u0026#34;, pflag.Arg(1)) // 返回处理完标志后剩余的参数列表中第 i 项 } 以上示例演示的 pflag 用法跟 flag 包用法一致，可以做到二者无缝替换。\n示例分别使用 pflag.Int()、pflag.IntVar()、pflag.Var() 三种不同方式来声明标志。其中 ip 和 port 都是 int 类型标志，host 标志则为自定义的 host 类型，它实现了 pflag.Value 接口，通过实现接口类型，标志能够支持任意类型，增加灵活性。\n通过 --help/-h 参数查看命令行程序使用帮助：\n1 2 3 4 5 6 7 $ go run main.go --help Usage of ./main: --host host help message for host --ip int help message for ip (default 1234) --port int help message for port (default 8080) pflag: help requested exit status 2 可以发现，帮助信息中的标志位置是经过重新排序的，并不是标志定义的顺序。\n与 flag 包不同的是，pflag 包参数定界符是两个 -，而不是一个 -，在 pflag 中 -- 和 - 具有不同含义，这点稍后会进行介绍。\nip 标志的默认参数为 1234，port 标志的默认参数为 8080。\n注意：在有些终端下执行程序退出后，还会多打印一行 exit status 2，这并不意味着程序没有正常退出，而是因为 --help 意图就是用来查看使用帮助，所以程序在打印使用帮助信息后，主动调用 os.Exit(2) 退出了。\n通过如下方式使用命令行程序：\n1 2 3 4 5 6 7 8 $ go run main.go --ip 1 x y --host localhost a b ip: 1 port: 8080 host: {value:localhost} NFlag: 2 NArg: 4 Args: [x y a b] Arg(1): y ip 标志的默认值已被命令行参数 1 所覆盖，由于没有传递 port 标志，所以打印结果为默认值 8080，host 标志的值也能够被正常打印。\n还有 4 个非选项参数数 x、y、a、b 也都被 pflag 识别并记录了下来。这点比 flag 要强大，在 flag 包中，非选项参数数只能写在所有命令行参数最后，x、y 出现在这里程序是会报错的。\n# 进阶用法 除了像 flag 包一样的用法，pflag 还支持一些独有的用法，以下是用法示例。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;github.com/spf13/pflag\u0026#34; ) type host struct { value string } func (h *host) String() string { return h.value } func (h *host) Set(v string) error { h.value = v return nil } func (h *host) Type() string { return \u0026#34;host\u0026#34; } func main() { flagSet := pflag.NewFlagSet(\u0026#34;test\u0026#34;, pflag.ExitOnError) var ip = flagSet.IntP(\u0026#34;ip\u0026#34;, \u0026#34;i\u0026#34;, 1234, \u0026#34;help message for ip\u0026#34;) var boolVar bool flagSet.BoolVarP(\u0026amp;boolVar, \u0026#34;boolVar\u0026#34;, \u0026#34;b\u0026#34;, true, \u0026#34;help message for boolVar\u0026#34;) var h host flagSet.VarP(\u0026amp;h, \u0026#34;host\u0026#34;, \u0026#34;H\u0026#34;, \u0026#34;help message for host\u0026#34;) flagSet.SortFlags = false parseErr := flagSet.Parse(os.Args[1:]) if parseErr != nil { log.Fatal(\u0026#34;解析命令行参数出错：\u0026#34;, parseErr) } fmt.Printf(\u0026#34;ip: %d\\n\u0026#34;, *ip) fmt.Printf(\u0026#34;boolVar: %t\\n\u0026#34;, boolVar) fmt.Printf(\u0026#34;host: %#v\\n\u0026#34;, h) i, err := flagSet.GetInt(\u0026#34;ip\u0026#34;) fmt.Printf(\u0026#34;i: %d, err: %v\\n\u0026#34;, i, err) } 首先我们通过 pflag.NewFlagSet 自定义了 FlagSet 对象 flagset，之后的标志定义和解析都通过 flagset 来完成。\n前文示例中 pflag.Int() 这种用法，实际上使用的是全局 FlagSet 对象 CommandLine，CommandLine 定义如下：\n1 var CommandLine = NewFlagSet(os.Args[0], ExitOnError) 现在同样使用三种不同方式来声明标志，分别为 flagset.IntP()、flagset.BoolVarP()、flagset.VarP()。不难发现，这三个方法的命名结尾都多了一个 P，它们的能力也得以升级，三个方法都多了一个 shorthand string 参数（flagset.IntP 的第 2 个参数，flagset.BoolVarP 和 flagset.VarP 的第 3 个参数）用来设置简短标志。\n从声明标志的方法名中我们能够总结出一些规律：\npflag.\u0026lt;Type\u0026gt; 类方法名会将标志参数值存储在指针中并返回。 pflag.\u0026lt;Type\u0026gt;Var 类方法名中包含 Var 关键字的，会将标志参数值绑定到第一个指针类型的参数。 pflag.\u0026lt;Type\u0026gt;P、pflag.\u0026lt;Type\u0026gt;VarP 类方法名以 P 结尾的，支持简短标志。 一个完整标志在命令行传参时使用的分界符为 --，而一个简短标志的分界符则为 -。\nflagset.SortFlags = false 作用是禁止打印帮助信息时对标志进行重排序。\n示例最后，使用 flagset.GetInt() 获取参数的值。\n通过 --help/-h 参数查看命令行程序使用帮助：\n1 2 3 4 5 6 7 $ go run main.go --help Usage of test: -i, --ip int help message for ip (default 1234) -b, --boolVar help message for boolVar (default true) -H, --host host help message for host pflag: help requested exit status 2 这次的帮助信息中，标志顺序没有被改变，就是声明的顺序。\n每一个标志都会对应一个简短标志，如 -b 和 --boolVar 是等价的，可以更加方便的设置参数。\n指定如下命令行参数运行示例：\n1 2 3 4 5 $ go run main.go --ip 1 -H localhost --boolVar=false ip: 1 boolVar: false host: main.host{value:\u0026#34;localhost\u0026#34;} i: 1, err: \u0026lt;nil\u0026gt; 通过 --ip 1 使用完整标志指定 ip 参数值。\n通过 -H localhost 使用简短标志指定 host 参数值。\n布尔类型的标志指定参数 --boolVar=false 需要使用等号 = 而非空格。\n# 命令行标志语法 命令行标志遵循如下语法：\n语法 说明 --flag 适用于 bool 类型标志，或具有 NoOptDefVal 属性的标志。 --flag x 适用于非 bool 类型标志，或没有 NoOptDefVal 属性的标志。 --flag=x 适用于 bool 类型标志。 -n 1234/-n=1234/-n1234 简短标志，非 bool 类型且没有 NoOptDefVal 属性，三者等价。 标志解析在终止符 -- 之后停止。\n整数标志接受 1234、0664、0x1234，并且可能为负数。\n布尔标志接受 1, 0, t, f, true, false, TRUE, FALSE, True, False。\nDuration 标志接受任何对 time.ParseDuration 有效的输入。\n# 标志名 Normalize 标准化Normalize\n借助 pflag.NormalizedName 我们能够给标志起一个或多个别名、规范化标志名等。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;github.com/spf13/pflag\u0026#34; ) func normalizeFunc(f *pflag.FlagSet, name string) pflag.NormalizedName { // alias switch name { case \u0026#34;old-flag-name\u0026#34;: name = \u0026#34;new-flag-name\u0026#34; break } // --my-flag == --my_flag == --my.flag from := []string{\u0026#34;-\u0026#34;, \u0026#34;_\u0026#34;} to := \u0026#34;.\u0026#34; for _, sep := range from { name = strings.Replace(name, sep, to, -1) } return pflag.NormalizedName(name) } func main() { flagSet := pflag.NewFlagSet(\u0026#34;test\u0026#34;, pflag.ExitOnError) var ip = flagSet.IntP(\u0026#34;new-flag-name\u0026#34;, \u0026#34;i\u0026#34;, 1234, \u0026#34;help message for new-flag-name\u0026#34;) var myFlag = flagSet.IntP(\u0026#34;my-flag\u0026#34;, \u0026#34;m\u0026#34;, 1234, \u0026#34;help message for my-flag\u0026#34;) flagSet.SetNormalizeFunc(normalizeFunc) err := flagSet.Parse(os.Args[1:]) if err != nil { log.Fatal(\u0026#34;命令行参数解析失败：\u0026#34;, err) } fmt.Printf(\u0026#34;ip: %d\\n\u0026#34;, *ip) fmt.Printf(\u0026#34;myFlag: %d\\n\u0026#34;, *myFlag) } 要使用 pflag.NormalizedName，我们需要创建一个函数 normalizeFunc，然后将其通过 flagset.SetNormalizeFunc(normalizeFunc) 注入到 flagset 使其生效。\n在 normalizeFunc 函数中，我们给 new-flag-name 标志起了一个别名 old-flag-name。\n另外，还对标志名进行了规范化处理，带有 - 和 _ 分割符的标志名，会统一规范化成以 . 作为分隔符的标志名。\n使用示例如下：\n1 2 3 4 5 6 7 8 9 10 11 $ go run pflag.go --old-flag-name 2 --my-flag 200 ip: 2 myFlag: 200 $ go run pflag.go --new-flag-name 3 --my_flag 300 ip: 3 myFlag: 300 $ go run pflag.go --new-flag_name 2 --my.flag 200 ip: 2 myFlag: 200 # NoOptDefVal NoOptDefVal 是 no option default values 的简写。\n创建标志后，可以为标志设置 NoOptDefVal 属性，如果标志具有 NoOptDefVal 属性并且在命令行上设置了标志而没有参数选项，则标志将设置为 NoOptDefVal 指定的值。\n如下示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/spf13/pflag\u0026#34; ) func main() { var ip = pflag.IntP(\u0026#34;flagName\u0026#34;, \u0026#34;f\u0026#34;, 1234, \u0026#34;help message\u0026#34;) pflag.Lookup(\u0026#34;flagName\u0026#34;).NoOptDefVal = \u0026#34;4321\u0026#34; pflag.Parse() fmt.Println(*ip) } 不同参数结果如下：\n命令行参数 结果值 –flagname=1357 ip=1357 –flagname ip=4321 [nothing] ip=1234 1 2 3 4 5 var ip = pflag.BoolP(\u0026#34;flagName\u0026#34;, \u0026#34;f\u0026#34;, false, \u0026#34;help message\u0026#34;) //pflag.Lookup(\u0026#34;flagName\u0026#34;).NoOptDefVal = \u0026#34;false\u0026#34; pflag.Parse() fmt.Println(*ip) bool类型的NoOptDefValue默认值是true，可以修改为false\n1 2 $ go run main.go -f true # 弃用/隐藏标志 使用 flags.MarkDeprecated 可以弃用一个标志，使用 flags.MarkShorthandDeprecated 可以弃用一个简短标志，使用 flags.MarkHidden 可以隐藏一个标志。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;github.com/spf13/pflag\u0026#34; ) func main() { flags := pflag.NewFlagSet(\u0026#34;test\u0026#34;, pflag.ExitOnError) var ip = flags.IntP(\u0026#34;ip\u0026#34;, \u0026#34;i\u0026#34;, 1234, \u0026#34;help message for ip\u0026#34;) var boolVar bool flags.BoolVarP(\u0026amp;boolVar, \u0026#34;boolVar\u0026#34;, \u0026#34;b\u0026#34;, true, \u0026#34;help message for boolVar\u0026#34;) var h string flags.StringVarP(\u0026amp;h, \u0026#34;host\u0026#34;, \u0026#34;H\u0026#34;, \u0026#34;127.0.0.1\u0026#34;, \u0026#34;help message for host\u0026#34;) // 弃用标志 _ = flags.MarkDeprecated(\u0026#34;ip\u0026#34;, \u0026#34;deprecated\u0026#34;) _ = flags.MarkShorthandDeprecated(\u0026#34;boolVar\u0026#34;, \u0026#34;please use --boolVar only\u0026#34;) // 隐藏标志 _ = flags.MarkHidden(\u0026#34;host\u0026#34;) err := flags.Parse(os.Args[1:]) if err != nil { log.Fatalln(\u0026#34;解析命令行出错了：\u0026#34;, err) } fmt.Printf(\u0026#34;ip: %d\\n\u0026#34;, *ip) fmt.Printf(\u0026#34;boolVar: %t\\n\u0026#34;, boolVar) fmt.Printf(\u0026#34;host: %+v\\n\u0026#34;, h) } 查看使用帮助：\n1 2 3 4 5 $ go run main.go -h Usage of test: --boolVar help message for boolVar (default true) pflag: help requested exit status 2 从打印结果可以发现，弃用标志 ip 时，其对应的简短标志 i 也会跟着被弃用；弃用 boolVar 所对应的简短标志 b 时，boolVar 标志会被保留；host 标志则完全被隐藏。\n指定如下命令行参数运行示例：\n1 2 3 4 5 $ go run main.go --ip 1 --boolVar=false -H localhost Flag --ip has been deprecated, deprecated ip: 1 boolVar: false host: localhost 打印信息中会提示用户 ip 标志已经弃用，不过使用 --ip 1 指定的参数值依然能够生效。\n隐藏的 host 标志使用 -H localhost 指定参数值同样能够生效。\n指定如下命令行参数运行示例：\n1 2 3 4 5 6 $ go run main.go -i 1 -b=false --host localhost Flag --ip has been deprecated, deprecated Flag shorthand -b has been deprecated, please use --boolVar only ip: 1 boolVar: false host: localhost 打印信息中增加了一条简短标志 -b 已被弃用的提示，指定参数值依然生效。\n对于弃用的 ip 标志，使用简短标志形式传惨 -i 1 同样生效。\n# 支持 flag 类型 由于 pflag 对 flag 包兼容，所以可以在一个程序中混用二者：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package main import ( \u0026#34;flag\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/spf13/pflag\u0026#34; ) func main() { var ip *int = pflag.Int(\u0026#34;ip\u0026#34;, 1234, \u0026#34;help message for ip\u0026#34;) var port *int = flag.Int(\u0026#34;port\u0026#34;, 80, \u0026#34;help message for port\u0026#34;) pflag.CommandLine.AddGoFlagSet(flag.CommandLine) pflag.Parse() fmt.Printf(\u0026#34;ip: %d\\n\u0026#34;, *ip) fmt.Printf(\u0026#34;port: %d\\n\u0026#34;, *port) } 其中，ip 标志是使用 pflag.Int() 声明的，port 标志则是使用 flag.Int() 声明的。只需要通过 AddGoFlagSet 方法将 flag.CommandLine 注册到 pflag 中，那么 pflag 就可以使用 flag 中声明的标志集合了。\n运行示例结果如下：\n1 2 3 $ go run main.go --ip 10 --port 8000 ip: 10 port: 8000 # 总结 本文主要介绍了 Go第三方标志包 pflag 的特点及用法。\n首先介绍了 pflag 的基本使用方法，包括声明标志、解析命令行参数、获取标志值等。接着介绍了 pflag 的进阶用法，例如自定义 FlagSet、使用 pflag.\u0026lt;Type\u0026gt;P 方法来支持简短标志。之后又对命令行标志语法进行了讲解，对于布尔值、非布尔值和简短标志，都有各自不同的语法。我们还讲解了如何借助 pflag.NormalizedName 给标志起一个或多个别名、规范化标志名。然后介绍了 NoOptDefVal 的作用和如何弃用/隐藏标志。最后通过示例演示了如何在一个程序中混用 flag 和 pflag。\n彩蛋：不知道你有没有发现，示例中的 ip 标志的名称其实代表的是 int pointer 而非 Internet Protocol Address。ip 标志源自官方示例，不过我顺势而为又声明了 port、host 标志，算是一个程序中的谐音梗 :)。\n# 参考 pflag 源码: https://github.com/spf13/pflag pflag 文档: https://pkg.go.dev/github.com/spf13/pflag 程序参数语法约定: https://www.gnu.org/software/libc/manual/html_node/Argument-Syntax.html Go 命令行参数解析工具 pflag 使用 ","date":"2024-05-02T15:21:19+08:00","permalink":"https://arlettebrook.github.io/p/go%E8%A7%A3%E6%9E%90%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%80%89%E9%A1%B9%E4%B9%8B%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93pflag/","title":"Go解析命令行选项之第三方库pflag"},{"content":" # 简介 在Go flag库介绍中，我们介绍了flag库。flag库是用于解析命令行选项的标准库。但是flag有几个缺点：\n不显示支持短选项。当然在Go flag库介绍文章中也提到过可以通过将两个选项共享同一个变量迂回实现，但写起来比较繁琐； 选项变量的定义比较繁琐，每个选项都需要根据类型调用对应的Type或TypeVar函数； 默认只支持有限的数据类型，当前只有基本类型bool/int/uint/string和time.Duration； 为了解决这些问题，出现了不少第三方解析命令行选项的库，今天的主角go-flags就是其中一个。第一次看到go-flags库是在阅读pgweb源码的时候。\ngo-flags提供了比标准库flag更多的选项。它利用结构标签（struct tag）和反射提供了一个方便、简洁的接口。它除了基本的功能，还提供了丰富的特性：\n支持短选项（-v）和长选项（–verbose）； 支持短选项合写，如-aux； 同一个选项可以设置多个值； 支持所有的基础类型和 map 类型，甚至是函数； 支持命名空间和选项组； 等等。 上面只是粗略介绍了go-flags的特性，下面我们依次来介绍。\n# 快速开始 学习从使用开始！我们先来看看go-flags的基本使用。\n由于是第三方库，使用前需要安装，执行下面的命令安装：\n1 $ go get -u github.com/jessevdk/go-flags 代码中使用import导入该库：\n1 import \u0026#34;github.com/jessevdk/go-flags\u0026#34; 完整示例代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package main import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/jessevdk/go-flags\u0026#34; ) type Option struct { Verbose []bool `short:\u0026#34;v\u0026#34; long:\u0026#34;verbose\u0026#34; description:\u0026#34;Show verbose debug message\u0026#34;` } func main() { var opt Option _, parseErr := flags.Parse(\u0026amp;opt) if parseErr != nil { var errPtr *flags.Error // 指针类型实现Error接口 if errors.As(parseErr, \u0026amp;errPtr) { // 断言的类型要是指针 if errors.Is(errPtr.Type, flags.ErrHelp) { return } return } panic(parseErr) return } fmt.Println(opt.Verbose) } 使用go-flags的一般步骤：\n定义选项结构，在结构标签中设置选项信息。通过short和long设置短、长选项名字，description设置帮助信息。命令行传参时，短选项前加-，长选项前加--； 声明选项变量； 调用go-flags的解析方法解析。 解析之后会返回两个参数： 第一个：剩余未解析选项，是string类型的切片，一般忽略。 第二个：error对象 对于帮助信息的error对象我们应该忽略。内部会打印这个错误，造成重复。其他错误抛出panic，并退出 flags.Parse()方法默认选项是Default = HelpFlag | PrintErrors | PassDoubleDash:打印帮助信息、打印错误信息、\u0026ndash;后面的参数不解析。 错误信息是封装到flags.Error结构体里面的ErrorType类型l字段里面的。所以需要断言之后再判断。 编译、运行代码（我的环境是 Win10 + Git Bash）：\n1 $ go build -o main.exe main.go 短选项：\n1 2 $ ./main.exe -v [true] 长选项：\n1 2 $ ./main.exe --verbose [true] 由于Verbose字段是切片类型，每次遇到-v或--verbose都会追加一个true到切片中。\n多个短选项：\n1 2 $ ./main.exe -v -v [true true] 多个长选项：\n1 2 $ ./main.exe --verbose --verbose [true true] 短选项 + 长选项：\n1 2 $ ./main.exe -v --verbose -v [true true true] 短选项合写：\n1 2 $ ./main.exe -vvv [true true true] # 基本特性 # 支持丰富的数据类型 go-flags相比标准库flag支持更丰富的数据类型：\n所有的基本类型（包括有符号整数int/int8/int16/int32/int64，无符号整数uint/uint8/uint16/uint32/uint64，浮点数float32/float64，布尔类型bool和字符串string）和它们的切片； map 类型。只支持键为string，值为基础类型的 map； 函数类型。 如果字段是基本类型的切片，基本解析流程与对应的基本类型是一样的。切片类型选项的不同之处在于，遇到相同的选项时，值会被追加到切片中。而非切片类型的选项，后出现的值会覆盖先出现的值。\n下面来看一个示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 package main import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/jessevdk/go-flags\u0026#34; ) type Option struct { IntFlag int `short:\u0026#34;i\u0026#34; long:\u0026#34;int\u0026#34; description:\u0026#34;int flag value\u0026#34;` IntSlice []int `long:\u0026#34;intslice\u0026#34; description:\u0026#34;int slice flag value\u0026#34;` BoolFlag bool `long:\u0026#34;bool\u0026#34; description:\u0026#34;bool flag value\u0026#34;` BoolSlice []bool `long:\u0026#34;boolslice\u0026#34; description:\u0026#34;bool slice flag value\u0026#34;` FloatFlag float64 `long:\u0026#34;float\u0026#34; description:\u0026#34;float64 flag value\u0026#34;` FloatSlice []float64 `long:\u0026#34;floatslice\u0026#34; description:\u0026#34;float64 slice flag value\u0026#34;` StringFlag string `short:\u0026#34;s\u0026#34; long:\u0026#34;string\u0026#34; description:\u0026#34;string flag value\u0026#34;` StringSlice []string `long:\u0026#34;strslice\u0026#34; description:\u0026#34;string slice flag value\u0026#34;` PtrStringSlice []*string `long:\u0026#34;pstrslice\u0026#34; description:\u0026#34;slice of pointer of string flag value\u0026#34;` Call func(string) `long:\u0026#34;call\u0026#34; description:\u0026#34;callback\u0026#34;` IntMap map[string]int `long:\u0026#34;intmap\u0026#34; description:\u0026#34;A map from string to int\u0026#34;` } func main() { var opt Option opt.Call = func(value string) { fmt.Println(\u0026#34;in callback: \u0026#34;, value) } _, parseErr := flags.Parse(\u0026amp;opt) if parseErr != nil { var errPtr *flags.Error if errors.As(parseErr, \u0026amp;errPtr) { return } panic(parseErr) return } fmt.Printf(\u0026#34;int flag: %v\\n\u0026#34;, opt.IntFlag) fmt.Printf(\u0026#34;int slice flag: %v\\n\u0026#34;, opt.IntSlice) fmt.Printf(\u0026#34;bool flag: %v\\n\u0026#34;, opt.BoolFlag) fmt.Printf(\u0026#34;bool slice flag: %v\\n\u0026#34;, opt.BoolSlice) fmt.Printf(\u0026#34;float flag: %v\\n\u0026#34;, opt.FloatFlag) fmt.Printf(\u0026#34;float slice flag: %v\\n\u0026#34;, opt.FloatSlice) fmt.Printf(\u0026#34;string flag: %v\\n\u0026#34;, opt.StringFlag) fmt.Printf(\u0026#34;string slice flag: %v\\n\u0026#34;, opt.StringSlice) fmt.Println(\u0026#34;slice of pointer of string flag: \u0026#34;) for i := 0; i \u0026lt; len(opt.PtrStringSlice); i++ { fmt.Printf(\u0026#34;\\t%d: %v\\n\u0026#34;, i, *opt.PtrStringSlice[i]) } fmt.Printf(\u0026#34;int map: %v\\n\u0026#34;, opt.IntMap) } 基本类型和其切片比较简单，就不过多介绍了。值得留意的是基本类型指针的切片，即上面的PtrStringSlice字段，类型为[]*string。 由于结构中存储的是字符串指针，go-flags在解析过程中遇到该选项会自动创建字符串，将指针追加到切片中。\n运行程序，传入--pstrslice选项：\n1 2 3 4 $ ./main.exe --pstrslice test1 --pstrslice test2 slice of pointer of string flag: 0: test1 1: test2 另外，我们可以在选项中定义函数类型。该函数的唯一要求是有一个字符串类型的参数。解析中每次遇到该选项就会以选项值为参数调用这个函数。 上面代码中，Call函数只是简单的打印传入的选项值。运行代码，传入--call选项：\n1 2 3 $ ./main.exe --call test1 --call test2 in callback: test1 in callback: test2 最后，go-flags还支持 map 类型。虽然限制键必须是string类型，值必须是基本类型，也能实现比较灵活的配置。 map类型的选项值中键-值通过:分隔，如key:value，可设置多个。运行代码，传入--intmap选项：\n1 2 $ ./main.exe --intmap key1:12 --intmap key2:58 int map: map[key1:12 key2:58] # 常用设置 go-flags提供了非常多的设置选项，具体可参见文档。这里重点介绍两个required和default。\nrequired非空时，表示对应的选项必须设置值，否则解析时返回ErrRequired错误。\ndefault用于设置选项的默认值。如果已经设置了默认值，那么required是否设置并不影响，也就是说命令行参数中该选项可以没有。\n看下面示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;github.com/jessevdk/go-flags\u0026#34; ) type Option struct { Required string `short:\u0026#34;r\u0026#34; long:\u0026#34;required\u0026#34; required:\u0026#34;true\u0026#34;` Default string `short:\u0026#34;d\u0026#34; long:\u0026#34;default\u0026#34; default:\u0026#34;default\u0026#34;` } func main() { var opt Option _, err := flags.Parse(\u0026amp;opt) if err != nil { log.Fatal(\u0026#34;Parse error:\u0026#34;, err) } fmt.Println(\u0026#34;required: \u0026#34;, opt.Required) fmt.Println(\u0026#34;default: \u0026#34;, opt.Default) } 运行程序，不传入default选项，Default字段取默认值，不传入required选项，执行报错：\n1 2 3 4 5 6 7 8 9 10 11 $ ./main.exe -r required-data required: required-data default: default $ ./main.exe -d default-data -r required-data required: required-data default: default-data $ ./main.exe the required flag `/r, /required\u0026#39; was not specified 2020/01/09 18:07:39 Parse error:the required flag `/r, /required\u0026#39; was not specified # 高级特性 # 选项分组 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 package main import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;github.com/jessevdk/go-flags\u0026#34; ) type Option struct { GroupBasicOption `group:\u0026#34;basic\u0026#34;` GroupSliceOption `group:\u0026#34;slice\u0026#34;` } type GroupBasicOption struct { IntFlag int `short:\u0026#34;i\u0026#34; long:\u0026#34;intflag\u0026#34; description:\u0026#34;int flag\u0026#34;` BoolFlag bool `short:\u0026#34;b\u0026#34; long:\u0026#34;boolflag\u0026#34; description:\u0026#34;bool flag\u0026#34;` FloatFlag float64 `short:\u0026#34;f\u0026#34; long:\u0026#34;floatflag\u0026#34; description:\u0026#34;float flag\u0026#34;` StringFlag string `short:\u0026#34;s\u0026#34; long:\u0026#34;stringflag\u0026#34; description:\u0026#34;string flag\u0026#34;` } type GroupSliceOption struct { IntSlice int `long:\u0026#34;intslice\u0026#34; description:\u0026#34;int slice\u0026#34;` BoolSlice bool `long:\u0026#34;boolslice\u0026#34; description:\u0026#34;bool slice\u0026#34;` FloatSlice float64 `long:\u0026#34;floatslice\u0026#34; description:\u0026#34;float slice\u0026#34;` StringSlice string `long:\u0026#34;stringslice\u0026#34; description:\u0026#34;string slice\u0026#34;` } func main() { var opt Option p := flags.NewParser(\u0026amp;opt, flags.Default) _, err := p.Parse() if err != nil { var errPtr *flags.Error if errors.As(err, \u0026amp;errPtr) { return } log.Fatal(err) } fmt.Println(opt) } 上面代码中我们将基本类型和它们的切片类型选项拆分到两个结构体中，这样可以使代码看起来更清晰自然，特别是在代码量很大的情况下。 这样做还有一个好处，我们试试用--help运行该程序：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 $ go run main.go --help Usage: C:\\Users\\Lenovo\\AppData\\Local\\Temp\\go-build4141518920\\b001\\exe\\main.exe [OPTIONS] basic: /i, /intflag: int flag /b, /boolflag bool flag /f, /floatflag: float flag /s, /stringflag: string flag slice: /intslice: int slice /boolslice bool slice /floatslice: float slice /stringslice: string slice Help Options: /? Show this help message /h, /help Show this help message 输出的帮助信息中，也是按照我们设定的分组显示了，便于查看。\ngroup标签字段用于分组并命名。当在结构体字段上指定时，使该结构体字段具有给定名称的单独组（可选）\n# 子命令 go-flags支持子命令。我们经常使用的 Go 和 Git 命令行程序就有大量的子命令。例如go version、go build、go run、git status、git commit这些命令中version/build/run/status/commit就是子命令。 使用go-flags定义子命令比较简单：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 package main import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;strconv\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;github.com/jessevdk/go-flags\u0026#34; ) type Option struct { GroupBasicOption `group:\u0026#34;Basic\u0026#34;` GroupSliceOption `group:\u0026#34;Slice\u0026#34;` MathCommand `command:\u0026#34;math\u0026#34;` Call func(int) `long:\u0026#34;call\u0026#34; description:\u0026#34;callback\u0026#34;` } type GroupBasicOption struct { IntFlag int `short:\u0026#34;i\u0026#34; long:\u0026#34;intflag\u0026#34; description:\u0026#34;int flag\u0026#34;` BoolFlag bool `short:\u0026#34;b\u0026#34; long:\u0026#34;boolflag\u0026#34; description:\u0026#34;bool flag\u0026#34;` FloatFlag float64 `short:\u0026#34;f\u0026#34; long:\u0026#34;floatflag\u0026#34; description:\u0026#34;float flag\u0026#34;` StringFlag string `short:\u0026#34;s\u0026#34; long:\u0026#34;stringflag\u0026#34; description:\u0026#34;string flag\u0026#34;` } type GroupSliceOption struct { IntSlice int `long:\u0026#34;intslice\u0026#34; description:\u0026#34;int slice\u0026#34;` BoolSlice bool `long:\u0026#34;boolslice\u0026#34; description:\u0026#34;bool slice\u0026#34;` FloatSlice float64 `long:\u0026#34;floatslice\u0026#34; description:\u0026#34;float slice\u0026#34;` StringSlice string `long:\u0026#34;stringslice\u0026#34; description:\u0026#34;string slice\u0026#34;` } type MathCommand struct { Op string `long:\u0026#34;op\u0026#34; description:\u0026#34;operation to execute\u0026#34;` Args []string Result int64 } func (m *MathCommand) Execute(args []string) error { // 注意，不能使用乘法符号*和除法符号/，它们都不可识别。 if m.Op != \u0026#34;+\u0026#34; \u0026amp;\u0026amp; m.Op != \u0026#34;-\u0026#34; \u0026amp;\u0026amp; m.Op != \u0026#34;*\u0026#34; \u0026amp;\u0026amp; m.Op != \u0026#34;/\u0026#34; { return errors.New(\u0026#34;invalid op\u0026#34;) } for _, arg := range args { num, err := strconv.ParseInt(arg, 10, 64) if err != nil { return err } // 只实现了加的功能 m.Result += num } m.Args = args return nil } func main() { var opt Option opt.Call = func(i int) { fmt.Println(i) } //_, errParse := flags.Parse(\u0026amp;opt) _, errParse := flags.NewParser(\u0026amp;opt, flags.HelpFlag|flags.PassDoubleDash).Parse() if errParse != nil { var p *flags.Error if errors.As(errParse, \u0026amp;p) { /*if errors.Is(p.Type, flags.ErrHelp) { os.Exit(0) }*/ switch { case errors.Is(p.Type, flags.ErrHelp): fmt.Println(p.Message) os.Exit(0) case errors.Is(p.Type, flags.ErrCommandRequired): default: log.Fatal(p.Message) } } else { log.Fatal(errParse) } } fmt.Println(opt) fmt.Printf(\u0026#34;The result of %s is %d\u0026#34;, strings.Join(opt.MathCommand.Args, opt.MathCommand.Op), opt.MathCommand.Result) } 子命令必须实现go-flags定义的Commander接口：\n1 2 3 type Commander interface { Execute(args []string) error } command结构体标签字段：当在结构体字段上指定时，使该结构体字段具有给定名称的（子）命令\n解析命令行时，如果遇到不是以-或--开头的参数，go-flags会尝试将其解释为子命令名。子命令的名字通过在结构标签中使用command指定。 子命令后面的参数都将作为子命令的参数，子命令也可以有选项。\n上面代码中，我们实现了一个可以计算任意个整数的加、减、乘、除子命令math。\n接下来看看如何使用：\n1 2 3 $ go run main.go math --op + 1 2 3 {{0 false 0 } {0 false 0 } {+ [1 2 3] 6} 0x6809a0} The result of 1+2+3 is 6 注意，不能使用乘法符号*和除法符号/，它们都不可识别。\n# 其他 go-flags库还有很多有意思的特性，例如支持 Windows 选项格式（/v和/verbose）、从环境变量中读取默认值、从 ini 文件中读取默认设置等等。大家有兴趣可以自行去研究~\n# 参考 go-flagsGoDoc 文档 Go 每日一库之 go-flags ","date":"2024-05-01T21:50:22+08:00","permalink":"https://arlettebrook.github.io/p/go%E8%A7%A3%E6%9E%90%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%80%89%E9%A1%B9%E4%B9%8B%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93go-flags/","title":"Go解析命令行选项之第三方库go-flags"},{"content":" zap 是由 Uber 公司开源的一款 Go 日志库，就像它的命名一样，zap 以快著称。官方 GitHub 仓库中只用一句话来概括 zap：「在 Go 中进行快速、结构化、分级的日志记录」。这句话简单明了的概括了 zap 的核心特性，今天我们就来介绍下 zap 日志库的基本使用和高级特性，以及如何在实际应用程序中使用，来提高应用程序的可靠性。\n# 特点 zap 具有如下特点：\n快，非常快，这也是 zap 最显著的特点。速度快的原因是 zap 避免使用 interface{} 和反射，并且使用 sync.Pool 减少堆内存分配。在 zap 面前 Logrus 的执行速度只有被吊打的份，你可以在官方 GitHub 仓库中看到 zap 与不同日志库的速度对比。 支持结构化日志记录。这是一个优秀的日志库必备功能。 支持七种日志级别：Debug、Info、Warn、Error、DPanic、Panic、Fatal，其中 DPanic 是指在开发环境下（development）记录日志后会进行 panic。 支持输出调用堆栈。 支持 Hooks 机制。 # 使用 # 基本使用 先安装go get -u go.uber.org/zap\n基本使用如下：\nzap库的使用与其他的日志库非常相似。先创建一个logger，然后调用各个级别的方法记录日志（Debug/Info/Warn/Error/）。zap提供了几个快速创建logger的方法，zap.NewExample()、zap.NewDevelopment()、zap.NewProduction()，还有高度定制化的创建方法zap.New()。创建前 3 个logger时，zap会使用一些预定义的设置，它们的使用场景也有所不同。Example适合用在测试代码中，Development在开发环境中使用，Production用在生成环境。\nzap底层 API 可以设置缓存，所以一般使用defer logger.Sync()将缓存同步到文件中。刷新缓存，确保日志输出。\n由于fmt.Printf之类的方法大量使用interface{}和反射，会有不少性能损失，并且增加了内存分配的频次。zap为了提高性能、减少内存分配次数，没有使用反射，而且默认的Logger只支持强类型的、结构化的日志。必须使用zap提供的方法记录字段。zap为 Go 语言中所有的基本类型和其他常见类型都提供了方法。这些方法的名称也比较好记忆，zap.Type（Type为bool/int/uint/float64/complex64/time.Time/time.Duration/error等）就表示该类型的字段，zap.Typep以p结尾表示该类型指针的字段，zap.Types以s结尾表示该类型切片的字段。如：\nzap.Bool(key string, val bool) Field：bool字段 zap.Boolp(key string, val *bool) Field：bool指针字段； zap.Bools(key string, val []bool) Field：bool切片字段。 当然也有一些特殊类型的字段：\nzap.Any(key string, value interface{}) Field：任意类型的字段； zap.Binary(key string, val []byte) Field：二进制串的字段。 当然，每个字段都用方法包一层用起来比较繁琐。zap也提供了便捷的方法SugarLogger，可以使用printf格式符的方式。调用logger.Sugar()即可创建SugaredLogger。SugaredLogger的使用比Logger简单，只是性能比Logger低 50% 左右，可以用在非热点函数中。调用SugarLogger以f结尾的方法与fmt.Printf没什么区别，如例子中的Infof。同时SugarLogger还支持以w结尾的方法，这种方式不需要先创建字段对象，直接将字段名和值依次放在参数中即可，如例子中的Infow。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; \u0026#34;go.uber.org/zap\u0026#34; ) func main() { // 生产环境 fmt.Println(\u0026#34;------生产环境------\u0026#34;) { logger, _ := zap.NewProduction() defer logger.Sync() // 刷新 buffer，保证日志最终会被输出 url := \u0026#34;https://arlettebrook.github.io/\u0026#34; logger.Info(\u0026#34;production failed to fetch URL\u0026#34;, zap.String(\u0026#34;url\u0026#34;, url), // 因为没有使用 interface{} 和反射机制，所以需要指定具体类型 zap.Int(\u0026#34;attempt\u0026#34;, 3), zap.Duration(\u0026#34;backoff\u0026#34;, time.Second), ) } // 开发环境 fmt.Println(\u0026#34;------开发环境------\u0026#34;) { logger, _ := zap.NewDevelopment() defer logger.Sync() url := \u0026#34;https://arlettebrook.github.io/\u0026#34; logger.Debug(\u0026#34;development failed to fetch URL\u0026#34;, zap.String(\u0026#34;url\u0026#34;, url), zap.Int(\u0026#34;attempt\u0026#34;, 3), zap.Duration(\u0026#34;backoff\u0026#34;, time.Second), ) } // 测试环境 fmt.Println(\u0026#34;------测试环境------\u0026#34;) { logger := zap.NewExample() defer logger.Sync() url := \u0026#34;https://arlettebrook.github.io/\u0026#34; logger.Info(\u0026#34;failed to fetch URL\u0026#34;, zap.String(\u0026#34;url\u0026#34;, url), zap.Int(\u0026#34;attempt\u0026#34;, 3), zap.Duration(\u0026#34;backoff\u0026#34;, time.Second), ) fmt.Println(\u0026#34;------sugaredLogger------\u0026#34;) sugar := logger.Sugar() sugar.Infow(\u0026#34;failed to fetch URL\u0026#34;, \u0026#34;url\u0026#34;, url, \u0026#34;attempt\u0026#34;, 3, \u0026#34;backoff\u0026#34;, time.Second, ) sugar.Infof(\u0026#34;Failed to fetch URL: %s\u0026#34;, url) } } zap 针对生产环境、开发环境以及测试环境提供了不同的函数来创建 Logger 对象。\n如果想在日志后面追加 key-value，则需要根据 value 的数据类型使用 zap.String、zap.Int 等方法实现。这一点在使用上显然不如 Logrus 等其他日志库来的方便，但这也是 zap 速度快的原因之一，zap 内部尽量避免使用 interface{} 和反射来提高代码执行效率。\n记录日志的 logger.Xxx 方法签名如下：\n1 func (log *Logger) Info(msg string, fields ...Field) 其中 fields 是 zapcore.Field 类型，用来存储 key-value，并记录 value 类型，不管是 zap.String 还是 zap.Int 底层都是 zapcore.Field 类型来记录的。zap 为每一种 Go 的内置类型都定义了对应的 zap.Xxx 方法，甚至还实现 zap.Any() 来支持 interface{}。\n执行以上代码，控制台得到如下输出：\n1 2 3 4 5 6 7 8 9 10 11 12 13 ------生产环境------ {\u0026#34;level\u0026#34;:\u0026#34;info\u0026#34;,\u0026#34;ts\u0026#34;:1714375211.8196504,\u0026#34;caller\u0026#34;:\u0026#34;learn/main.go:18\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;production failed to fe tch URL\u0026#34;,\u0026#34;url\u0026#34;:\u0026#34;https://arlettebrook.github.io/\u0026#34;,\u0026#34;attempt\u0026#34;:3,\u0026#34;backoff\u0026#34;:1} ------开发环境------ 2024-04-29T15:20:11.820+0800 DEBUG learn/main.go:32 development failed to fetch URL {\u0026#34; url\u0026#34;: \u0026#34;https://arlettebrook.github.io/\u0026#34;, \u0026#34;attempt\u0026#34;: 3, \u0026#34;backoff\u0026#34;: \u0026#34;1s\u0026#34;} ------测试环境------ {\u0026#34;level\u0026#34;:\u0026#34;info\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;failed to fetch URL\u0026#34;,\u0026#34;url\u0026#34;:\u0026#34;https://arlettebrook.github.io/\u0026#34;,\u0026#34;attempt\u0026#34;:3,\u0026#34;b ackoff\u0026#34;:\u0026#34;1s\u0026#34;} ------sugaredLogger------ {\u0026#34;level\u0026#34;:\u0026#34;info\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;failed to fetch URL\u0026#34;,\u0026#34;url\u0026#34;:\u0026#34;https://arlettebrook.github.io/\u0026#34;,\u0026#34;attempt\u0026#34;:3,\u0026#34;b ackoff\u0026#34;:\u0026#34;1s\u0026#34;} {\u0026#34;level\u0026#34;:\u0026#34;info\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;Failed to fetch URL: https://arlettebrook.github.io/\u0026#34;} 可以发现，通过 zap.NewProduction() 创建的日志对象输出格式为 JSON，而通过 zap.NewDevelopment() 创建的日志对象输出格式为 Text，日志后面追加的 key-value 会被转换成 JSON。并且，两者输出的字段内容也略有差异，如生产环境日志输出的时间格式为 Unix epoch 利于程序解析，而开发环境日志输出的时间格式为 ISO8601 更利于人类阅读。测试环境没有文件行号、堆栈跟踪信息以及时间，格式为JSON。对应的sugar都是是一样的。\n导致以上这些差异的原因是配置不同，我们来看下 zap.NewProduction 和 zap.NewDevelopment 的代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 func NewProduction(options ...Option) (*Logger, error) { return NewProductionConfig().Build(options...) } func NewProductionConfig() Config { return Config{ Level: NewAtomicLevelAt(InfoLevel), Development: false, Sampling: \u0026amp;SamplingConfig{ Initial: 100, Thereafter: 100, }, Encoding: \u0026#34;json\u0026#34;, EncoderConfig: NewProductionEncoderConfig(), OutputPaths: []string{\u0026#34;stderr\u0026#34;}, ErrorOutputPaths: []string{\u0026#34;stderr\u0026#34;}, } } func NewDevelopment(options ...Option) (*Logger, error) { return NewDevelopmentConfig().Build(options...) } func NewDevelopmentConfig() Config { return Config{ Level: NewAtomicLevelAt(DebugLevel), Development: true, Encoding: \u0026#34;console\u0026#34;, EncoderConfig: NewDevelopmentEncoderConfig(), OutputPaths: []string{\u0026#34;stderr\u0026#34;}, ErrorOutputPaths: []string{\u0026#34;stderr\u0026#34;}, } } 可以看到，两者在实现思路上是一样的，都是先创建一个配置对象 zap.Config，然后再调用配置对象的 Build 方法来构建 Logger。\nzap.Config 定义如下：\n1 2 3 4 5 6 7 8 9 10 11 12 type Config struct { Level AtomicLevel `json:\u0026#34;level\u0026#34; yaml:\u0026#34;level\u0026#34;` Development bool `json:\u0026#34;development\u0026#34; yaml:\u0026#34;development\u0026#34;` DisableCaller bool `json:\u0026#34;disableCaller\u0026#34; yaml:\u0026#34;disableCaller\u0026#34;` DisableStacktrace bool `json:\u0026#34;disableStacktrace\u0026#34; yaml:\u0026#34;disableStacktrace\u0026#34;` Sampling *SamplingConfig `json:\u0026#34;sampling\u0026#34; yaml:\u0026#34;sampling\u0026#34;` Encoding string `json:\u0026#34;encoding\u0026#34; yaml:\u0026#34;encoding\u0026#34;` EncoderConfig zapcore.EncoderConfig `json:\u0026#34;encoderConfig\u0026#34; yaml:\u0026#34;encoderConfig\u0026#34;` OutputPaths []string `json:\u0026#34;outputPaths\u0026#34; yaml:\u0026#34;outputPaths\u0026#34;` ErrorOutputPaths []string `json:\u0026#34;errorOutputPaths\u0026#34; yaml:\u0026#34;errorOutputPaths\u0026#34;` InitialFields map[string]interface{} `json:\u0026#34;initialFields\u0026#34; yaml:\u0026#34;initialFields\u0026#34;` } 每个配置项说明如下：\nLevel: 日志级别。 Development: 是否为开发模式。 DisableCaller: 禁用调用信息，值为 true 时，日志中将不再显示记录日志时所在的函数调用文件名和行号。 DisableStacktrace: 禁用堆栈跟踪捕获。 Sampling: 采样策略配置，单位为每秒，作用是限制日志在每秒内的输出数量，以此来防止全局的 CPU 和 I/O 负载过高。 Encoding: 指定日志编码器，目前支持 json 和 console。 EncoderConfig: 编码配置，决定了日志字段格式。 OutputPaths: 配置日志输出位置，URLs 或文件路径，可配置多个。 ErrorOutputPaths: zap 包内部出现错误的日志输出位置，URLs 或文件路径，可配置多个，默认 os.Stderr。 InitialFields: 初始化字段配置，该配置的字段会以结构化的形式打印在每条日志输出中。 我们再来对比下 NewProductionEncoderConfig() 和 NewDevelopmentEncoderConfig() 这两个配置的不同：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 func NewProductionEncoderConfig() zapcore.EncoderConfig { return zapcore.EncoderConfig{ TimeKey: \u0026#34;ts\u0026#34;, LevelKey: \u0026#34;level\u0026#34;, NameKey: \u0026#34;logger\u0026#34;, CallerKey: \u0026#34;caller\u0026#34;, FunctionKey: zapcore.OmitKey, MessageKey: \u0026#34;msg\u0026#34;, StacktraceKey: \u0026#34;stacktrace\u0026#34;, LineEnding: zapcore.DefaultLineEnding, EncodeLevel: zapcore.LowercaseLevelEncoder, EncodeTime: zapcore.EpochTimeEncoder, EncodeDuration: zapcore.SecondsDurationEncoder, EncodeCaller: zapcore.ShortCallerEncoder, } } func NewDevelopmentEncoderConfig() zapcore.EncoderConfig { return zapcore.EncoderConfig{ // Keys can be anything except the empty string. TimeKey: \u0026#34;T\u0026#34;, LevelKey: \u0026#34;L\u0026#34;, NameKey: \u0026#34;N\u0026#34;, CallerKey: \u0026#34;C\u0026#34;, FunctionKey: zapcore.OmitKey, MessageKey: \u0026#34;M\u0026#34;, StacktraceKey: \u0026#34;S\u0026#34;, LineEnding: zapcore.DefaultLineEnding, EncodeLevel: zapcore.CapitalLevelEncoder, EncodeTime: zapcore.ISO8601TimeEncoder, EncodeDuration: zapcore.StringDurationEncoder, EncodeCaller: zapcore.ShortCallerEncoder, } } 对比来看，两者有很多不同的配置，比如生产环境下 EncodeTime 值为 zapcore.EpochTimeEncoder，开发环境下 EncodeTime 值为 zapcore.ISO8601TimeEncoder。这就是生产环境日志输出的时间格式为 Unix epoch 而开发环境日志输出的时间格式为 ISO8601 的原因。\nzapcore.EncoderConfig 其他几个常用的配置项说明如下：\nMessageKey: 日志信息的键名，默认 msg。 LevelKey: 日志级别的键名，默认 level。 TimeKey: 日志时间的键名。 EncodeLevel: 日志级别的格式，默认为小写，如 info。 除了提供 zap.NewProduction() 和 zap.NewDevelopment() 两个构造函数外，zap 还提供了 zap.NewExample() 来创建一个 Logger 对象，这个方法主要用于测试，这里就不多介绍了。\n# 记录层级关系 前面我们记录的日志都是一层结构，没有嵌套的层级。我们可以使用zap.Namespace(key string) Field构建一个命名空间，后续的Field都记录在此命名空间中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func main() { logger := zap.NewExample() defer logger.Sync() logger.Info(\u0026#34;tracked some metrics\u0026#34;, zap.Namespace(\u0026#34;metrics\u0026#34;), zap.Int(\u0026#34;counter\u0026#34;, 1), ) logger2 := logger.With( zap.Namespace(\u0026#34;metrics\u0026#34;), zap.Int(\u0026#34;counter\u0026#34;, 1), ) logger2.Info(\u0026#34;tracked some metrics\u0026#34;) } 输出：\n1 2 {\u0026#34;level\u0026#34;:\u0026#34;info\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;tracked some metrics\u0026#34;,\u0026#34;metrics\u0026#34;:{\u0026#34;counter\u0026#34;:1}} {\u0026#34;level\u0026#34;:\u0026#34;info\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;tracked some metrices\u0026#34;,\u0026#34;metrics\u0026#34;:{\u0026#34;counter\u0026#34;:1}} 上面我们演示了两种Namespace的用法，一种是直接作为字段传入Debug/Info等方法，一种是调用With()创建一个新的Logger，新的Logger记录日志时总是带上预设的字段。With()方法实际上是创建了一个新的Logger：\n1 2 3 4 5 6 7 8 9 // src/go.uber.org/zap/logger.go func (log *Logger) With(fields ...Field) *Logger { if len(fields) == 0 { return log } l := log.clone() l.core = l.core.With(fields) return l } # 预设日志字段 如果每条日志都要记录一些共用的字段，那么使用zap.Fields(fs ...Field)创建的选项。例如在服务器日志中记录可能都需要记录serverId和serverName：\n1 2 3 4 5 6 7 8 func main() { logger := zap.NewExample(zap.Fields( zap.Int(\u0026#34;serverId\u0026#34;, 90), zap.String(\u0026#34;serverName\u0026#34;, \u0026#34;awesome web\u0026#34;), )) logger.Info(\u0026#34;hello world\u0026#34;) } 输出：\n1 {\u0026#34;level\u0026#34;:\u0026#34;info\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;hello world\u0026#34;,\u0026#34;serverId\u0026#34;:90,\u0026#34;serverName\u0026#34;:\u0026#34;awesome web\u0026#34;} 与logger.with()差不多\n# 给语法加点糖 zap 虽然速度足够快，但是多数情况下，我们并不需要极致的性能，而是想让代码写起来更爽一些。zap 为我们提供了解决方案 —— SugaredLogger。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package main import ( \u0026#34;time\u0026#34; \u0026#34;go.uber.org/zap\u0026#34; ) func main() { logger, _ := zap.NewProduction() defer logger.Sync() url := \u0026#34;https://arlettebrook.github.io/\u0026#34; sugar := logger.Sugar() sugar.Infow(\u0026#34;production failed to fetch URL\u0026#34;, \u0026#34;url\u0026#34;, url, \u0026#34;attempt\u0026#34;, 3, \u0026#34;backoff\u0026#34;, time.Second, ) sugar.Info(\u0026#34;Info\u0026#34;) sugar.Infoln(\u0026#34;Infoln\u0026#34;) sugar.Infof(\u0026#34;Infof: %s\u0026#34;, url) } 通过 logger.Sugar() 方法可以将一个 Logger 对象转换成一个 SugaredLogger 对象。\nSugaredLogger 提供了更人性化的接口，日志中追加 key-value 时不在需要 zap.String(\u0026quot;url\u0026quot;, url) 这种显式指明类型的写法，只需要保证 key 为 string 类型，value 则可以为任意类型，能够减少我们编写的代码量。\n此外，为了满足不同需求，SugaredLogger 提供了四种方式输出日志：sugar.Xxx、sugar.Xxxw、sugar.Xxxf、sugar.Xxxln。\n执行以上代码，控制台得到如下输出：\n1 2 3 4 5 6 {\u0026#34;level\u0026#34;:\u0026#34;info\u0026#34;,\u0026#34;ts\u0026#34;:1714398451.8505704,\u0026#34;caller\u0026#34;:\u0026#34;learn/main.go:15\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;production failed to fe tch URL\u0026#34;,\u0026#34;url\u0026#34;:\u0026#34;https://arlettebrook.github.io/\u0026#34;,\u0026#34;attempt\u0026#34;:3,\u0026#34;backoff\u0026#34;:1} {\u0026#34;level\u0026#34;:\u0026#34;info\u0026#34;,\u0026#34;ts\u0026#34;:1714398451.8511178,\u0026#34;caller\u0026#34;:\u0026#34;learn/main.go:20\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;Info\u0026#34;} {\u0026#34;level\u0026#34;:\u0026#34;info\u0026#34;,\u0026#34;ts\u0026#34;:1714398451.851623,\u0026#34;caller\u0026#34;:\u0026#34;learn/main.go:21\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;Infoln\u0026#34;} {\u0026#34;level\u0026#34;:\u0026#34;info\u0026#34;,\u0026#34;ts\u0026#34;:1714398451.8516397,\u0026#34;caller\u0026#34;:\u0026#34;learn/main.go:22\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;Infof: https://arletteb rook.github.io/\u0026#34;} 我们知道，这种方便的写法是有一定代价的，所以开发中是否需要使用 SugaredLogger 来记录日志，需要根据程序的特点来决定。SugaredLogger 与 Logger 的性能对比同样可以在官方 GitHub 仓库中看到。\n# 定制 Logger 通过查看 zap.NewProduction() 和 zap.NewDevelopment() 两个构造函数源码，我们知道可以使用 zap.Config 对象的 Build 方法创建 Logger 对象。那么我们很容易能够想到，如果要定制 Logger，只需要创建一个定制的 zap.Config 即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 package main import ( \u0026#34;go.uber.org/zap\u0026#34; \u0026#34;go.uber.org/zap/zapcore\u0026#34; ) func newCustomLogger() (*zap.Logger, error) { cfg := zap.Config{ Level: zap.NewAtomicLevelAt(zap.DebugLevel), Development: false, Encoding: \u0026#34;json\u0026#34;, EncoderConfig: zapcore.EncoderConfig{ TimeKey: \u0026#34;time\u0026#34;, LevelKey: \u0026#34;level\u0026#34;, NameKey: \u0026#34;logger\u0026#34;, CallerKey: \u0026#34;\u0026#34;, // 不记录日志调用位置 FunctionKey: zapcore.OmitKey, MessageKey: \u0026#34;message\u0026#34;, LineEnding: zapcore.DefaultLineEnding, EncodeLevel: zapcore.LowercaseLevelEncoder, EncodeTime: zapcore.RFC3339TimeEncoder, EncodeDuration: zapcore.SecondsDurationEncoder, EncodeCaller: zapcore.ShortCallerEncoder, }, OutputPaths: []string{\u0026#34;stdout\u0026#34;, \u0026#34;test.log\u0026#34;}, ErrorOutputPaths: []string{\u0026#34;error.log\u0026#34;}, } return cfg.Build() } func main() { logger, _ := newCustomLogger() defer logger.Sync() // 增加一个 skip 选项，触发 zap 内部 error，将错误输出到 error.log logger = logger.WithOptions(zap.AddCallerSkip(100)) logger.Info(\u0026#34;Info msg\u0026#34;) logger.Error(\u0026#34;Error msg\u0026#34;) } 以上代码通过 newCustomLogger 函数创建了一个自定义的 Logger，同样通过先定义一个 zap.Config 然后再调用其 Build 方法来实现。\n配置日志分别输出到标准输出和 test.log 文件，执行以上代码，控制台和 test.log 都会得到如下输出：\n1 2 {\u0026#34;level\u0026#34;:\u0026#34;info\u0026#34;,\u0026#34;time\u0026#34;:\u0026#34;2023-03-19T19:19:18+08:00\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;Info msg\u0026#34;} {\u0026#34;level\u0026#34;:\u0026#34;error\u0026#34;,\u0026#34;time\u0026#34;:\u0026#34;2023-03-19T19:19:18+08:00\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;Error msg\u0026#34;} 另外，我们还通过 logger.WithOptions() 为 Logger 对象增加了一个选项 zap.AddCallerSkip(100)，这个选项的作用是指定在通过调用栈获得行号时跳过的调用深度，因为我们的函数调用栈并不是 100 层，所以会触发 zap 内部错误，zap 会将错误日志输出到 ErrorOutputPaths 配置指定的位置中，即 error.log。\nerror.log 得到的错误日志如下：\n1 2 2023-03-19 11:19:18.438824 +0000 UTC Logger.check error: failed to get caller 2023-03-19 11:19:18.44921 +0000 UTC Logger.check error: failed to get caller # 选项 logger.WithOptions() 支持的选项如下：\nWrapCore(f func(zapcore.Core) zapcore.Core): 使用一个新的 zapcore.Core 替换掉 Logger 内部原有的的 zapcore.Core 属性。 Hooks(hooks ...func(zapcore.Entry) error): 注册钩子函数，用来在日志打印时同时调用注册的钩子函数。 Fields(fs ...Field): 添加公共字段。 ErrorOutput(w zapcore.WriteSyncer): 指定日志组件内部出现异常时的输出位置。 Development(): 将日志记录器设为开发模式，这将使 DPanic 级别日志记录错误后执行 panic()。 AddCaller(): 与 WithCaller(true) 等价。 WithCaller(enabled bool): 指定是否在日志输出内容中增加调用信息，即文件名和行号。 AddCallerSkip(skip int): 指定在通过调用栈获取文件名和行号时跳过的调用深度。 AddStacktrace(lvl zapcore.LevelEnabler): 用来指定某个日志级别及以上级别输出调用堆栈。 IncreaseLevel(lvl zapcore.LevelEnabler): 提高日志级别，如果传入的 lvl 比现有级别低，则不会改变日志级别。 WithFatalHook(hook zapcore.CheckWriteHook): 当出现 Fatal 级别日志时调用的钩子函数。 WithClock(clock zapcore.Clock): 指定日志记录器用来确定当前时间的 zapcore.Clock 对象，默认为 time.Now 的系统时钟。 NewExample()/NewDevelopment()/NewProduction()这 3 个函数可以传入若干类型为zap.Option的选项，从而定制Logger的行为。又一次见到了选项模式！！\nzap提供了丰富的选项供我们选择。\n输出文件名和行号\n调用zap.AddCaller()返回的选项设置输出文件名和行号。但是有一个前提，必须设置配置对象Config中的CallerKey字段。也因此NewExample()不能输出这个信息（它的Config没有设置CallerKey）。\nAddCaller()与zap.WithCaller(true)等价。一般不用\n有时我们稍微封装了一下记录日志的方法，但是我们希望输出的文件名和行号是调用封装函数的位置。这时可以使用zap.AddCallerSkip(skip int)向上跳 1 层。可能会用到。\n输出调用堆栈\n有时候在某个函数处理中遇到了异常情况，因为这个函数可能在很多地方被调用。如果我们能输出此次调用的堆栈，那么分析起来就会很方便。我们可以使用zap.AddStackTrace(lvl zapcore.LevelEnabler)达成这个目的。该函数指定lvl和之上的级别都需要输出调用堆栈：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package main import ( \u0026#34;go.uber.org/zap\u0026#34; \u0026#34;go.uber.org/zap/zapcore\u0026#34; ) func f1() { f2(\u0026#34;hello world\u0026#34;) } func f2(msg string, fields ...zap.Field) { zap.L().Warn(msg, fields...) // zap.L()获取全局logger } func main() { logger, _ := zap.NewDevelopment(zap.AddStacktrace(zapcore.WarnLevel)) defer logger.Sync() zap.ReplaceGlobals(logger) // 替换全局logger f1() } 将zapcore.WarnLevel传入AddStacktrace()，之后Warn()/Error()等级别的日志会输出堆栈，Debug()/Info()这些级别不会。运行结果：\n1 2 3 4 5 6 7 8 9 2024-04-30T10:32:49.798+0800 WARN learn/main.go:13 hello world main.f2 F:/GoProject/learn/main.go:13 main.f1 F:/GoProject/learn/main.go:9 main.main F:/GoProject/learn/main.go:22 runtime.main D:/Go/src/runtime/proc.go:271 很清楚地看到调用路径。\n创建自定义的配置对象，除了在代码中指定配置参数，也可以将这些配置项写入到 JSON 文件中，然后通过 json.Unmarshal 的方式将配置绑定到 zap.Config，可以参考官方示例。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 func main() { rawJSON := []byte(`{ \u0026#34;level\u0026#34;:\u0026#34;debug\u0026#34;, \u0026#34;encoding\u0026#34;:\u0026#34;json\u0026#34;, \u0026#34;outputPaths\u0026#34;: [\u0026#34;stdout\u0026#34;, \u0026#34;server.log\u0026#34;], \u0026#34;errorOutputPaths\u0026#34;: [\u0026#34;stderr\u0026#34;], \u0026#34;initialFields\u0026#34;:{\u0026#34;name\u0026#34;:\u0026#34;dj\u0026#34;}, \u0026#34;encoderConfig\u0026#34;: { \u0026#34;messageKey\u0026#34;: \u0026#34;message\u0026#34;, \u0026#34;levelKey\u0026#34;: \u0026#34;level\u0026#34;, \u0026#34;levelEncoder\u0026#34;: \u0026#34;lowercase\u0026#34; } }`) var cfg zap.Config if err := json.Unmarshal(rawJSON, \u0026amp;cfg); err != nil { panic(err) } logger, err := cfg.Build() if err != nil { panic(err) } defer logger.Sync() logger.Info(\u0026#34;server start work successfully!\u0026#34;) } 上面创建一个输出到标准输出stdout和文件server.log的Logger。观察输出：\n1 {\u0026#34;level\u0026#34;:\u0026#34;info\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;server start work successfully!\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;dj\u0026#34;} # 全局Logger 为了方便使用，zap提供了两个全局的Logger，一个是*zap.Logger，可调用zap.L()获得；另一个是*zap.SugaredLogger，可调用zap.S()获得。需要注意的是，全局的Logger默认并不会记录日志！它是一个无实际效果的Logger。看源码:\n1 2 3 4 5 6 // go.uber.org/zap/global.go var ( _globalMu sync.RWMutex _globalL = NewNop() _globalS = _globalL.Sugar() ) 我们可以使用ReplaceGlobals(logger *Logger) func()将logger设置为全局的Logger，该函数返回一个无参函数，用于恢复全局Logger设置：\n1 2 3 4 5 6 7 8 9 10 11 func main() { zap.L().Info(\u0026#34;global Logger before\u0026#34;) zap.S().Info(\u0026#34;global SugaredLogger before\u0026#34;) logger := zap.NewExample() defer logger.Sync() zap.ReplaceGlobals(logger) zap.L().Info(\u0026#34;global Logger after\u0026#34;) zap.S().Info(\u0026#34;global SugaredLogger after\u0026#34;) } 输出：\n1 2 {\u0026#34;level\u0026#34;:\u0026#34;info\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;global Logger after\u0026#34;} {\u0026#34;level\u0026#34;:\u0026#34;info\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;global SugaredLogger after\u0026#34;} 可以看到在调用ReplaceGlobals之前记录的日志并没有输出。\n# 与标准日志库搭配使用 如果项目一开始使用的是标准日志库log，后面想转为zap。这时不必修改每一个文件。我们可以调用zap.NewStdLog(l *Logger) *log.Logger返回一个标准的log.Logger，内部实际上写入的还是我们之前创建的zap.Logger：\n1 2 3 4 5 6 7 func main() { logger := zap.NewExample() defer logger.Sync() std := zap.NewStdLog(logger) std.Print(\u0026#34;standard logger wrapper\u0026#34;) } 输出：\n1 {\u0026#34;level\u0026#34;:\u0026#34;info\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;standard logger wrapper\u0026#34;} 很方便不是吗？我们还可以使用NewStdLogAt(l *logger, level zapcore.Level) (*log.Logger, error)让标准接口以level级别写入内部的*zap.Logger。\n如果我们只是想在一段代码内使用标准日志库log，其它地方还是使用zap.Logger。可以调用RedirectStdLog(l *Logger) func()。它会返回一个无参函数恢复设置：\n1 2 3 4 5 6 7 8 9 10 func main() { logger := zap.NewExample() defer logger.Sync() undo := zap.RedirectStdLog(logger) log.Print(\u0026#34;redirected standard library\u0026#34;) undo() log.Print(\u0026#34;restored standard library\u0026#34;) } 看前后输出变化：\n1 2 {\u0026#34;level\u0026#34;:\u0026#34;info\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;redirected standard library\u0026#34;} 2020/04/24 22:13:58 restored standard library 当然RedirectStdLog也有一个对应的RedirectStdLogAt以特定的级别调用内部的*zap.Logger方法。\n# 参考 Go 每日一库之 zap zap 源码: https://github.com/uber-go/zap zap 文档: https://pkg.go.dev/go.uber.org/zap Go 第三方 log 库之 zap 使用 如何基于 zap 封装一个更好用的日志库 ","date":"2024-04-29T12:12:52+08:00","permalink":"https://arlettebrook.github.io/p/go%E7%AC%AC%E4%B8%89%E6%96%B9log%E5%BA%93%E4%B9%8Bzap/","title":"Go第三方log库之zap"},{"content":" # 概述 大多数语言都有“依赖”、“包”等概念，Go语言的依赖处理经历了几次变革。\n最早的时候，Go所依赖的所有的第三方库都放在GOPATH这个目录下面。从v1.5开始引入vendor模式，如果项目目录下有vendor目录，那么go工具链会优先使用vendor内的包进行编译、测试等。\n从v1.11开始，引入了Go Modules 作为依赖解决方案，到v1.14宣布Go Modules已经可以用于生产环境，到v1.16版本开始Go Module默认开启。\n# 什么是 Go Modules Go modules 是 Go 语言的依赖解决方案，发布于 Go1.11，成长于 Go1.12，丰富于 Go1.13，正式于 Go1.14 推荐在生产上使用。\nGo Modules使得Go语言开发者能够更方便地管理代码包及其版本，并能够与现有的版本控制工具（如Git、SVN等）集成使用。\n在传统的GOPATH模式中，所有Go代码都必须位于一个全局的GOPATH路径之下，这使得在不同项目中使用不同版本的依赖包变得非常困难。然而，在Go Modules模式下，每个项目都可以独立管理自己的依赖关系，具有更好的兼容性。当使用Go Modules模式后，项目中会自动创建go.mod文件，其中记录了项目所依赖的模块及其版本信息。go.mod是Go语言项目中的模块文件，用于管理项目的依赖关系和版本信息。\nGo Modules也支持语义化版本控制，这意味着开发者可以指定依赖包的版本范围，而不是仅仅依赖最新的版本。这种灵活性有助于确保项目的稳定性和可维护性。\nGo moudles 目前集成在 Go 的工具链中，只要安装了 Go，自然而然也就可以使用 Go moudles 了，而 Go modules 的出现也解决了在 Go1.11 前的几个常见争议问题：\nGo 语言长久以来的依赖管理问题。 “淘汰”现有的 GOPATH 的使用模式。 统一社区中的其它的依赖管理工具（提供迁移功能）。 优势\n首先，研发者能够在任何目录下工作，而不仅仅是在GOPATH指定的目录。 可以安装依赖包的指定版本，而不是只能从master分支安装最新的版本。 可以导入同一个依赖包的多个版本。当我们老项目使用老版本，新项目使用新版本时会非常有用。 要有一个能够罗列当前项目所依赖包的列表。这个的好处是当我们发布项目时不用同时发布所依赖的包。Go能够根据该文件自动下载对应的包。 # GO PATH介绍 安装好go开发环境之后，可以运行go env查看go运行时的环境变量。要修改这些环境变量，可以通过配置环境变量来覆盖默认值(覆盖了就不能通过命令设置)，如临时设置export GO111MODULE=on。或者通过命令go env -w key=value，如go env -w GO111MODULE=on。通过命令修改的环境变量保存在GOENV这个环境变量指向的文件。\n有两个比较重要的环境变量：\nGOROOT：Golang 安装目录的路径，包含编译器程序和系统包，也可以放置三方包（不推荐）。新版本已经不需要配置这个环境变量了，安装了go会自动推断出该变量的值。如果安装之后环境变量中没有$GORROOT/bin,需要手动添加，这样才能直接在命令行中运行go编译程序。 GOPATH：该工作目录，放置编译后二进制和 import 包时的搜索路径，一般有三个目录: bin、pkg、src。并且该环境变量必须手动设置。 bin：用来存放编译后的可执行文件。引入Go modules之后用于存放get install安装的可执行文件。 pkg：存储预编译的目标文件，以加快程序的后续编译速度。引入Go modules之后用于存放第三方包。 src：存储所有.go文件或源代码。在编写 Go 应用程序，程序包和库时，一般会以$GOPATH/src/github.com/foo/bar的路径进行存放。引入Go modules之后用一般不用，go项目可以放在任意目录中，不在是$GOPATH/src 因此在使用 GOPATH 模式下，我们需要将应用代码存放在固定的$GOPATH/src目录下，并且如果执行go get来拉取外部依赖会自动下载并安装到$GOPATH目录下。\n# GOPATH模式的弊端 在 GOPATH 的 $GOPATH/src 下进行 .go 文件或源代码的存储，我们可以称其为 GOPATH 的模式，这个模式拥有一些弊端。\nA. 无版本控制概念. 在执行go get的时候，你无法传达任何的版本信息的期望，也就是说你也无法知道自己当前更新的是哪一个版本，也无法通过指定来拉取自己所期望的具体版本。 B.无法同步一致第三方版本号. 在运行 Go 应用程序的时候，你无法保证其它人与你所期望依赖的第三方库是相同的版本，也就是说在项目依赖库的管理上，你无法保证所有人的依赖版本都一致。 C.无法指定当前项目引用的第三方版本号. 你没办法处理 v1、v2、v3 等等不同版本的引用问题，因为 GOPATH 模式下的导入路径都是一样的，都是github.com/foo/bar。 Go 语言官方从 Go1.11 起开始推进 Go modules（前身vgo，知道即可，不需要深入了解），Go1.13 起不再推荐使用 GOPATH 的使用模式，Go modules 也渐趋稳定，因此新项目也没有必要继续使用GOPATH模式。\n# Go Module 语义化版本规范 Go Module 的设计采用了语义化版本规范，语义化版本规范非常流行且具有指导意义，本文就来聊聊语义化版本规范的设计和在 Go 中的应用。\n# 语义化版本规范 语义化版本规范（SemVer）是由 Gravatars 创办者兼 GitHub 共同创办者 Tom Preston-Werner 所建立，旨在解决 依赖地狱 问题。\n它清楚明了的规定了版本格式、版本号递增规：\n版本格式：采用 X.Y.Z 的格式，X 是主版本号、Y 是次版本号、而 Z 为修订号（即：主版本号.次版本号.修订号），其中 X、Y 和 Z 为非负的整数，且禁止在数字前方补零。\n版本号递增规则：\n主版本号：当做了不兼容的 API 修改。\n次版本号：当做了向下兼容的功能性新增及修改。\n修订号：当做了向下兼容的问题修正。\n另外，先行版本号 及 版本编译信息 可以加到 主版本号.次版本号.修订号 的后面，作为延伸。\n完整版本格式如下：\n先行版本号可以有多个，如第一个为UTC时间，第二个为提交的哈希值：\n1 2 v4.0.1-0.20210109023952-943e75fe5223+incompatible v0.0.0-20240416160154-fe59bbe5cc7f 其中版本号核心部分 X.Y.Z 是必须的，使用 . 连接，先行版本号和版本编译信息是可选的，先行版本号通过 - 与核心部分连接，版本编译信息通过 + 与核心部分或先行版本号连接。\n合法的几种版本号格式如下：\n主版本号.次版本号.修订号 主版本号.次版本号.修订号-先行版本号 主版本号.次版本号.修订号+版本编译信息 主版本号.次版本号.修订号-先行版本号+版本编译信息 主版本号必须在有任何不兼容的修改被加入公共 API 时递增。每当主版本号递增时，次版本号和修订号必须归零。\n次版本号必须在有向下兼容的新功能出现或有改进时递增，或在任何公共 API 的功能被标记为弃用时也必须递增。每当次版本号递增时，修订号必须归零。\n修订号必须在只做了向下兼容的修正时才递增。这里的修正指的是针对不正确结果而进行的内部修改。\n存在先行版本号，意味着当前版本不够稳定，且可能存在兼容性问题。先行版本号是一连串以 . 分隔的标识符，由 ASCII 字母数字和连接号 [0-9A-Za-z-] 组成，禁止出现空白符，数字类型则禁止在前方补零。合法示例：1.0.0-alpha、1.0.0-alpha.1、1.0.0-0.3.7、1.0.0-x.7.z.92。\n版本编译信息标志符规格与先行版本号基本相同，略有差异的是数字类型前方允许补零。合法示例：1.0.0-alpha+001、1.0.0+20130313144700、1.0.0-beta+exp.sha.5114f85。\n除了上面几点说明，还需要额外关注以下几点：\n标记版本号的软件发行后，禁止改变该版本软件的内容。任何修改都必须以新版本发行。 主版本号为零（0.y.z）的软件处于开发初始阶段，一切都可能随时被改变。这样的公共 API 不应该被视为稳定版。 1.0.0 的版本号用于界定公共 API 的形成。这一版本之后所有的版本号更新都基于公共 API 及其修改内容。 社区中还存在一个不成文的规定，对于次版本号，偶数为稳定版本，奇数为开发版本。当然不是所有项目都这样设计。 # 使用语义化版本规范可能遇到的问题 在使用语义化版本规范过程中，可能人为或程序编写错误导致出现如下几种可预见的问题：\n万一不小心把一个不兼容的改版当成了次版本号发行了该怎么办？\n一旦发现自己破坏了语义化版本控制的规范，就要修正这个问题，并发行一个新的次版本号来更正这个问题并且恢复向下兼容。即使是这种情况，也不能去修改已发行的版本。可以的话，将有问题的版本号记录到文档中，告诉使用者问题所在，让他们能够意识到这是有问题的版本。\n注意：不到万不得已，不要也不能去修改已发行的版本。\n如果我变更了公共 API 但无意中未遵循版本号的改动怎么办呢？（意即在修订等级的发布中，误将重大且不兼容的改变加到代码之中）\n自行做最佳的判断。如果你有庞大的使用者群在依照公共 API 的意图而变更行为后会大受影响，那么最好做一次主版本的发布，即使严格来说这个修复仅是修订等级的发布。记住，语义化的版本控制就是透过版本号的改变来传达意义。若这些改变对你的使用者是重要的，那就透过版本号来向他们说明。\nv1.2.3 是一个语义化版本号吗？\nv1.2.3 并不是的一个语义化的版本号。但是，在语义化版本号之前增加前缀 v 是用来表示版本号的常用做法。在版本控制系统中，将 version 缩写为 v 是很常见的。比如：git tag v1.2.3 -m \u0026quot;Release version 1.2.3\u0026quot; 中，v1.2.3 表示标签名称，而 1.2.3 是语义化版本号。go modules的模块版本也是在前面加v\n# 如何验证语义化版本规范正确性 官方提供了两个正则可以检查语义化版本号的正确性。\n支持按组名称提取匹配结果\n1 ^(?P\u0026lt;major\u0026gt;0|[1-9]\\d*)\\.(?P\u0026lt;minor\u0026gt;0|[1-9]\\d*)\\.(?P\u0026lt;patch\u0026gt;0|[1-9]\\d*)(?:-(?P\u0026lt;prerelease\u0026gt;(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+(?P\u0026lt;buildmetadata\u0026gt;[0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$ Go 语言示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 package main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;regexp\u0026#34; ) func main() { version := \u0026#34;0.1.2-alpha+001\u0026#34; pattern := regexp.MustCompile(`^(?P\u0026lt;major\u0026gt;0|[1-9]\\d*)\\.(?P\u0026lt;minor\u0026gt;0|[1-9]\\d*)\\.(?P\u0026lt;patch\u0026gt;0|[1-9]\\d*)(?:-(?P\u0026lt;prerelease\u0026gt;(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+(?P\u0026lt;buildmetadata\u0026gt;[0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$`) r := pattern.FindStringSubmatch(version) m := make(map[string]string) for i, name := range pattern.SubexpNames() { if i == 0 { m[\u0026#34;version\u0026#34;] = r[i] } else { m[name] = r[i] } } result, _ := json.MarshalIndent(m, \u0026#34;\u0026#34;, \u0026#34; \u0026#34;) fmt.Printf(\u0026#34;%s\\n\u0026#34;, result) } /* { \u0026#34;buildmetadata\u0026#34;: \u0026#34;001\u0026#34;, \u0026#34;major\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;minor\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;patch\u0026#34;: \u0026#34;2\u0026#34;, \u0026#34;prerelease\u0026#34;: \u0026#34;alpha\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;0.1.2-alpha+001\u0026#34; } */ 支持按编号提取匹配结果\n1 ^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$ Go 语言示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;regexp\u0026#34; ) func main() { version := \u0026#34;0.1.2-alpha+001\u0026#34; pattern := regexp.MustCompile(`^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$`) r := pattern.FindStringSubmatch(version) for i, s := range r { fmt.Printf(\u0026#34;%d -\u0026gt; %s\\n\u0026#34;, i, s) } } /* 0 -\u0026gt; 0.1.2-alpha+001 1 -\u0026gt; 0 2 -\u0026gt; 1 3 -\u0026gt; 2 4 -\u0026gt; alpha 5 -\u0026gt; 001 */ # Go Modules版本设计 # 依赖地狱 我们先来看下早期 Go 依赖包存在的依赖地狱问题：\n首先存在两个包 pkg1 和 pkg2，分别依赖 pkg3 的 v1.0.0 版本和 v2.0.0 版本，现在我们开发一个 app 包，它依赖 pkg1 和 pkg2，那么此时由于 app 包只允许包含一个 pkg3 依赖，所以 Go 构建工具无法抉择应该使用哪个版本的 pkg3。这就是所谓的依赖地狱问题。\n# 语义导入版本 为了解决依赖地狱问题，Go 在 1.11 版本时引入和 Go Modules：\nGo Module 解决问题的方式是，把 pkg3 的 v1.0.0 版本和 v2.0.0 版本当作两个不同的包，这样也就允许了 app 包能够同时包含多个不同版本的 pkg3。\n在使用时，需要在包的导入路径上加上包的主版本号。这里以 go-micro 包使用为例，展示下 Go Module 语义导入版本的用法：\n1 2 3 4 5 6 7 8 9 10 11 12 import \u0026#34;go-micro.dev/v4\u0026#34; // create a new service service := micro.NewService( micro.Name(\u0026#34;helloworld\u0026#34;), ) // initialise flags service.Init() // start the service service.Run() 可以看到导入路径为 \u0026quot;go-micro.dev/v4\u0026quot;，其中 v4 就代表了需要引入 go-micro 的 v4.y.z 版本。\n# Go Modules基本使用 # go modules相关命令 在 Go modules 中，我们能够使用如下命令进行操作：\n命令 介绍 go mod init \u0026lt;project\u0026gt; 初始化项目依赖，生成go.mod模块文件 go mod download 根据go.mod文件下载依赖 go mod tidy 比对项目文件中引入的依赖与go.mod进行比对,整理模块文件，去除没有用到的依赖 go mod graph 输出依赖关系图、查看现有的依赖结构 go mod edit 编辑go.mod文件 go mod vendor 将项目的所有依赖导出至vendor目录 go mod verify 检验一个依赖包是否被篡改过 go mod why 解释为什么需要某个依赖 # go modules参数配置 GO111MODULE\nGo语言提供了 GO111MODULE 这个环境变量来作为 Go modules 的开关，其允许设置以下参数：\n参数 说明 auto 只要项目包含了 go.mod 文件的话启用 Go modules，目前在 Go1.11 至 Go1.14 中仍然是默认值。 on 启用 Go modules，推荐设置，将会是Go1.16版本之后的默认值。 off 禁用 Go modules，不推荐设置。 你可能会留意到 GO111MODULE 这个名字比较“奇特”，实际上在 Go 语言中经常会有这类阶段性的变量， GO111MODULE 这个命名代表着Go语言在 1.11 版本添加的。后续版本中可能会去掉。\nGOPROXY\n这个环境变量主要是用于设置 Go 模块代理（Go module proxy），其作用是用于使 Go 在后续拉取模块版本时能够脱离传统的 VCS（版本控制系统，如github，就是源地址下载） 方式，直接通过镜像站点来快速拉取。值为off表示禁止模块代理。\n设置GOPROXY可以加速模块下载，确保构建确定性（提供稳定的构建版本），提高安全性，确保模块始终可用。\nGOPROXY 的默认值是：https://proxy.golang.org,direct，由于某些原因国内无法正常访问该地址，所以我们通常需要配置一个可访问的地址。目前国内社区使用比较多的有两个 https://goproxy.cn和 https://goproxy.io，当然如果你的公司有提供GOPROXY地址那么就直接使用。并且修改的代理，通过go get命令下载自己的公共模块，也会同步到 https://pkg.go.dev/。\n设置GOPAROXY的命令如下：\n1 go env -w GOPROXY=https://goproxy.cn,direct GOPROXY 允许设置多个代理地址，多个地址之间需使用英文逗号 “,” 分隔。最后的 “direct” 是一个特殊指示符，用于指示 Go 回源到源地址去抓取（比如 GitHub 等）。当配置有多个代理地址时，如果第一个代理地址返回 404 或 410 错误时，Go 会自动尝试下一个代理地址，当遇见 “direct” 时触发回源，也就是回到源地址去抓取。就是代理失败之后用传统方式（源地址下载模块）。\nGOPRIVATE\nGONOPROXY/GONOSUMDB/GOPRIVATE\n这三个环境变量都是用在当前项目依赖了私有模块，例如像是你公司的私有 git 仓库，又或是 github 中的私有库，都是属于私有模块，都是要进行设置的，否则会拉取失败。\n更细致来讲，就是依赖了由 GOPROXY 指定的 Go 模块代理或由 GOSUMDB 指定 Go checksum database 都无法访问到的模块时的场景。\n而一般建议直接设置 GOPRIVATE，它的值将作为 GONOPROXY 和 GONOSUMDB 的默认值，所以建议的最佳姿势是直接使用 GOPRIVATE。\n设置了GOPROXY 之后，go 命令就会从配置的代理地址拉取和校验依赖包。当我们在项目中引入了非公开的包（公司内部git仓库或 github 私有仓库等），此时便无法正常从代理拉取到这些非公开的依赖包，这个时候就需要配置 GOPRIVATE 环境变量。GOPRIVATE用来告诉 go 命令哪些仓库属于私有仓库，不必通过代理服务器拉取和校验。\nGOPRIVATE 的值也可以设置多个，多个地址之间使用英文逗号 “,” 分隔。我们通常会把自己公司内部的代码仓库设置到 GOPRIVATE 中，例如：\n1 $ go env -w GOPRIVATE=\u0026#34;git.example.com,github.com/arlettebrook/demo\u0026#34; 设置后，前缀为 git.xxx.com 和 github.com/arlettebrook/demo的模块都会被认为是私有模块。\n如果不想每次都重新设置，我们也可以利用通配符，例如：\n1 $ go env -w GOPRIVATE=\u0026#34;*.example.com\u0026#34; 这样子设置的话，所有模块路径为 example.com 的子域名（例如：git.example.com）都将不经过 Go module proxy 和 Go checksum database，需要注意的是不包括 example.com 本身。\n此外，如果公司内部自建了 GOPROXY 服务，那么我们可以通过设置 GONOPROXY=none，允许通内部代理拉取私有仓库的包。\n# go modules模块文件 初识化项目\n在项目的根目录下运行go mod init \u0026lt;project\u0026gt;，如go mod init github.com/arlettebrook/demo，demo是项目名，github.com/arlettebrook/demo是模块导入路径，当导入的时候，如果本地没有，会去该路径下载。\ngo.mod 文件\n在初始化项目时，会生成一个 go.mod 文件，是启用了 Go modules 项目所必须的最重要的标识，同时也是 GO111MODULE 值为 auto 时的识别标识，它描述了当前项目（也就是当前模块）的元信息，每一行都以一个动词开头。\n示例文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 module github.com/arlettebrook/demo go 1.22.1 require ( example.com/apple v0.1.2 example.com/banana v1.2.3 example.com/banana/v2 v2.3.4 example.com/pear // indirect example.com/strawberry // incompatible ) exclude example.com/banana v1.2.4 replace example.com/apple v0.1.2 =\u0026gt; example.com/fried v0.1.0 replace example.com/banana =\u0026gt; example.com/fish 说明\nmodule：用于定义当前项目的模块路径。 go：用于标识当前模块的 Go 语言版本，值为初始化模块时的版本，目前来看还只是个标识作用。 require：用于设置一个特定的模块版本。 exclude：用于从使用中排除一个特定的模块版本。 replace：用于将一个模块版本替换为另外一个模块版本。 另外你会发现 example.com/pear 的后面会有一个 indirect 标识，indirect 标识表示该模块为间接依赖，也就是在当前应用程序中的 import 语句中，并没有发现这个模块的明确引用，有可能是你先手动 go get 拉取下来的，也有可能是你所依赖的模块所依赖的，情况有好几种。incompatible：不兼容的\ngo.sum 文件\n在第一次拉取模块依赖后，会发现多出了一个 go.sum 文件，其详细罗列了当前项目直接或间接依赖的所有模块版本，并写明了那些模块版本的 SHA-256 哈希值以备 Go 在今后的操作中保证项目所依赖的那些模块版本不会被篡改。\n1 2 3 4 github.com/spf13/cobra v1.8.0 h1:7aJaZx1B85qltLMc546zn58BxxfZdR/W22ej9CFoEf0= github.com/spf13/cobra v1.8.0/go.mod h1:WXLWApfZ71AjXPya3WOlMsY9yMs7YeiHhFVlvLyhcho= github.com/spf13/pflag v1.0.5 h1:iy+VFUOCP1a+8yFto/drg2CJ5u0yRoB7fZw3DKv/JXA= github.com/spf13/pflag v1.0.5/go.mod h1:McXfInJRrz4CZXVZOBLb0bTZqETkiAhM9Iw0y3An2Bg= 可以看到一个模块路径可能有如下两种：\n1 2 github.com/spf13/cobra v1.8.0 h1:7aJaZx1B85qltLMc546zn58BxxfZdR/W22ej9CFoEf0= github.com/spf13/cobra v1.8.0/go.mod h1:WXLWApfZ71AjXPya3WOlMsY9yMs7YeiHhFVlvLyhcho= h1 hash 是 Go modules 将目标模块版本的 zip 文件开包后，针对所有包内文件依次进行 hash，然后再把它们的 hash 结果按照固定格式和算法组成总的 hash 值。\n而 h1 hash 和 go.mod hash 两者，要不就是同时存在，要不就是只存在 go.mod hash。那什么情况下会不存在 h1 hash 呢，就是当 Go 认为肯定用不到某个模块版本的时候就会省略它的 h1 hash，就会出现不存在 h1 hash，只存在 go.mod hash 的情况。\ngo.mod和go.sum都应该被提交到git仓库中去。当别人使用你的项目时，mod保证依赖版本一直，sum保证依赖不被篡改。\n# go modules模块下载 我们下载、添加模块使用go get -u \u0026lt;module path\u0026gt;。\n默认下载、添加最新版本，首先会检查本地（pkg：全局模块缓存）是否存在，没有，在去下载。\n在项目中下载会自动添加到go.mod文件中。\n-u选项会更新模块的依赖包到最新版本，推荐加上。\n还可以指定下载版本\n命令 作用 go get golang.org/x/text@latest 拉取最新的版本，若存在tag，则优先使用。可以省略。 go get golang.org/x/text@master 拉取 master 分支的最新 commit。@branch go get golang.org/x/text@v0.3.2 拉取 tag 为 v0.3.2 的 commit。@version，version必须满足语义化版本规范且前面加v。 go get golang.org/x/text@342b2e 拉取 hash 为 342b231 的 commit，最终会被转换为 v0.3.2。@commit go get golang.org/x/text/v2 下载主版本号为2的最新版 最新版本的选择\n分两种情况\n最新版本有发布tags：就以发布的版本，version一般为标签名，如v2.1.2 最新版本没有发布tags:就以提交的最新版本，version一般为已发布标签-最新提交日期-最新提交哈希+版本编译信息，版本编译信息一般没有。如v2.1.2-20240416160154-fe59bbe5cc7f，如果一次tags也没有发布，版本号则为v0.0.0，如v0.0.0-20240416160154-fe59bbe5cc7f 子模块同理 # go modules全局缓存 Go module 会把下载到本地的依赖包会以类似下面的形式保存在 $GOPATH/pkg/mod目录下，每个依赖包都会带有版本号进行区分，这样就允许在本地存在同一个包的多个不同版本。\n1 2 3 4 5 6 7 mod ├── cache ├── github.com ├── golang.org ├── google.golang.org ├── gopkg.in ... 如果想清除所有本地已缓存的依赖包数据，可以执行 go clean -modcache 命令。\n# go modules模块导入 go模块导入用import \u0026quot;模块路径\u0026quot;\n当导入多个模块的时候用\n1 2 3 4 5 import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;path/filepath\u0026#34; ) 别名导入用import 别名 \u0026quot;模块路径\u0026quot;\n1 import f \u0026#34;fmt\u0026#34; 点导入用import . \u0026quot;模块路径\u0026quot;\n点导入是一种特殊的导入方式，它将包中的所有公共标识符（函数、变量、类型等）提升到当前文件的命名空间中，这样在代码中就可以直接使用这些标识符，而不需要加上包名前缀。但是，这种方式可能会导致命名冲突和代码可读性下降，因此一般不建议使用。\n空导入用import _ \u0026quot;模块路径\u0026quot;\n空导入通常用于初始化包中的变量或者执行包中的初始化函数，而不直接使用该包中的其他标识符。\n注意事项\n当模块的主版本号为0或1的时候省略了主版本标识。\n当主版本号为2及以上时，不能省略主版本标识。否则会出现冲突。\n主版本标识只能为/v主版本号，不能用@version，一般使用主版本的最新版，这与语义化版本规范有关。\n如：\n1 2 import \u0026#34;github.com/jordan-wright/email\u0026#34; import \u0026#34;github.com/jordan-wright/email/v4\u0026#34; 为什么忽略 v0 和 v1 的主版本号\n还是与语义化版本规范有关，v0属于开发初始阶段，其公共api不被视为稳定版，当版本到达v1，其公共api基本确定，在此之后如果不出现不兼容api的修改，是不会修改主版本号的。后续的次版本、修订号会向下兼容。这是官方所鼓励的。当api做了不兼容的修改，主版本号就会修改。为了不出现冲突就会加上主版本标识。\n# 总结 至此我们大致介绍了 Go modules 的前世今生、语义化版本规范以及基本使用。\nGo modules 的成长和发展经历了一定的过程，如果你是刚接触的读者，直接基于 Go modules 的项目开始即可，如果既有老项目，那么是时候考虑切换过来了，Go1.14起已经准备就绪，并推荐你使用。\n# 参考 https://semver.org/lang/zh-CN/ Go Module 语义化版本规范 Go Modules详解 Go module详细介绍 ","date":"2024-04-28T10:57:17+08:00","permalink":"https://arlettebrook.github.io/p/go-modules%E8%AF%A6%E8%A7%A3/","title":"Go modules详解"},{"content":" Go 语言标准库中的 log 包设计简洁明了，易于上手，可以轻松记录程序运行时的信息、调试错误以及跟踪代码执行过程中的问题等。使用 log 包无需繁琐的配置即可直接使用。本文旨在深入探究 log 包的使用和原理，帮助读者更好地了解和掌握它。\n# 使用 先来看一个 log 包的使用示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main import \u0026#34;log\u0026#34; func main() { log.Print(\u0026#34;Print\u0026#34;) log.Printf(\u0026#34;Printf: %s\u0026#34;, \u0026#34;print\u0026#34;) log.Println(\u0026#34;Println\u0026#34;) log.Fatal(\u0026#34;Fatal\u0026#34;) log.Fatalf(\u0026#34;Fatalf: %s\u0026#34;, \u0026#34;fatal\u0026#34;) log.Fatalln(\u0026#34;Fatalln\u0026#34;) log.Panic(\u0026#34;Panic\u0026#34;) log.Panicf(\u0026#34;Panicf: %s\u0026#34;, \u0026#34;panic\u0026#34;) log.Panicln(\u0026#34;Panicln\u0026#34;) } 假设以上代码存放在 main.go 中，通过 go run main.go 执行代码将会得到如下输出：\n1 2 3 4 5 6 $ go run main.go 2023/03/08 22:33:22 Print 2023/03/08 22:33:22 Printf: print 2023/03/08 22:33:22 Println 2023/03/08 22:33:22 Fatal exit status 1 以上示例代码中使用 log 包提供的 9 个函数分别对日志进行输出，最终得到 4 条打印日志。我们来分析下每个日志函数的作用，来看看为什么出现这样的结果。\nlog 包提供了 3 类共计 9 种方法来输出日志内容。\n函数名 作用 使用示例 Print 打印日志 log.Print(“Print”) Printf 打印格式化日志 log.Printf(“Printf: %s”, “print”) Println 打印日志并换行 log.Println(“Println”) Panic 打印日志后执行 panic(s)（s 为日志内容） log.Panic(“Panic”) Panicf 打印格式化日志后执行 panic(s) log.Panicf(“Panicf: %s”, “panic”) Panicln 打印日志并换行后执行 panic(s) log.Panicln(“Panicln”) Fatal 打印日志后执行 os.Exit(1) log.Fatal(“Fatal”) Fatalf 打印格式化日志后执行 os.Exit(1) log.Fatalf(“Fatalf: %s”, “fatal”) Fatalln 打印日志并换行后执行 os.Exit(1) log.Panicln(“Panicln”) 实际上log包每打印一句日志，都会换行，无论有没有ln或者\\n。\n根据以上表格说明，我们可以知道，log 包在执行 log.Fatal(\u0026quot;Fatal\u0026quot;) 时，程序打印完日志就通过 os.Exit(1) 退出了。这也就可以解释上面的示例程序，为什么打印了 9 次日志，却只输出了 4 条日志，并且最后程序退出码为 1 了。\n以上是 log 包最基本的使用方式，如果我们想对日志输出做一些定制，可以使用 log.New 创建一个自定义 logger：\n1 logger := log.New(os.Stdout, \u0026#34;[Debug] - \u0026#34;, log.Lshortfile) log.New 函数接收三个参数，分别用来指定：日志输出位置（一个 io.Writer 对象）、日志前缀（字符串，每次打印日志都会跟随输出）、日志属性（定义好的常量，稍后会详细讲解）。\n使用示例：\n1 2 3 4 5 6 7 8 9 10 11 package main import ( \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; ) func main() { logger := log.New(os.Stdout, \u0026#34;[Debug] - \u0026#34;, log.Lshortfile) logger.Println(\u0026#34;custom logger\u0026#34;) } 示例输出：\n1 [Debug] - main.go:10: custom logger 以上示例中，指定日志输出到 os.Stdout，即标准输出；日志前缀 [Debug] - 会自动被加入到每行日志的行首；这条日志没有打印当前时间，而是打印了文件名和行号，这是 log.Lshortfile 日志属性的作用。\n日志属性可选项如下：\n属性 说明 Ldate 当前时区的日期，格式：2009/01/23 Ltime 当前时区的时间，格式：01:23:23 Lmicroseconds 当前时区的时间，格式：01:23:23.123123，精确到微妙 Llongfile 全文件名和行号，格式：/a/b/c/d.go:23 Lshortfile 当前文件名和行号，格式：d.go:23，会覆盖 Llongfile LUTC 使用 UTC 而非本地时区，推荐日志全部使用 UTC 时间 Lmsgprefix 将 prefix 内容从行首移动到日志内容前面 LstdFlags 标准 logger 对象的初始值（等于：`Ldate 这些属性都是预定义好的常量，不能修改，可以通过 | 运算符组合使用（如：log.Ldate|log.Ltime|log.Lshortfile）。\n使用 log.New 函数创建 logger 对象以后，依然可以通过 logger 对象的方法修改其属性值（默认的log也同样有下列同名函数）：\n方法 作用 SetOutput 设置日志输出位置 SetPrefix 设置日志输出前缀 SetFlags 设置日志属性 现在我们来看一个更加完整的使用示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package main import ( \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; ) func main() { // 准备日志文件 logFile, _ := os.Create(\u0026#34;demo.log\u0026#34;) defer func() { _ = logFile.Close() }() // 初始化日志对象 logger := log.New(logFile, \u0026#34;[Debug] - \u0026#34;, log.Lshortfile|log.Lmsgprefix) logger.Print(\u0026#34;Print\u0026#34;) logger.Println(\u0026#34;Println\u0026#34;) // 修改日志配置 logger.SetOutput(os.Stdout) logger.SetPrefix(\u0026#34;[Info] - \u0026#34;) logger.SetFlags(log.Ldate|log.Ltime|log.LUTC) logger.Print(\u0026#34;Print\u0026#34;) logger.Println(\u0026#34;Println\u0026#34;) } 执行以上代码，得到 demo.log 日志内容如下：\n1 2 main.go:15: [Debug] - Print main.go:16: [Debug] - Println 控制台输出内容如下：\n1 2 [Info] - 2023/03/11 01:24:56 Print [Info] - 2023/03/11 01:24:56 Println 可以发现，在 demo.log 日志内容中，因为指定了 log.Lmsgprefix 属性，所以日志前缀 [Debug] - 被移动到了日志内容前面，而非行首。\n因为后续通过 logger.SetXXX 对 logger 对象的属性进行了动态修改，所以最后两条日志输出到系统的标准输出。\n以上，基本涵盖了 log 包的所有常用功能。接下来我们就通过走读源码的方式来更深入的了解 log 包了。\n# 源码 注意：本文以 Go 1.19.4 源码为例，其他版本可能存在差异。\nGo 标准库的 log 包代码量非常少，算上注释也才 400+ 行，非常适合初学者阅读学习。\n在上面介绍的第一个示例中，我们使用 log 包提供的 9 个公开函数对日志进行输出，并通过表格的形式分别介绍了函数的作用和使用示例，那么现在我们就来看看这几个函数是如何定义的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 func Print(v ...any) { if atomic.LoadInt32(\u0026amp;std.isDiscard) != 0 { return } std.Output(2, fmt.Sprint(v...)) } func Printf(format string, v ...any) { if atomic.LoadInt32(\u0026amp;std.isDiscard) != 0 { return } std.Output(2, fmt.Sprintf(format, v...)) } func Println(v ...any) { if atomic.LoadInt32(\u0026amp;std.isDiscard) != 0 { return } std.Output(2, fmt.Sprintln(v...)) } func Fatal(v ...any) { std.Output(2, fmt.Sprint(v...)) os.Exit(1) } func Fatalf(format string, v ...any) { std.Output(2, fmt.Sprintf(format, v...)) os.Exit(1) } func Fatalln(v ...any) { std.Output(2, fmt.Sprintln(v...)) os.Exit(1) } func Panic(v ...any) { s := fmt.Sprint(v...) std.Output(2, s) panic(s) } func Panicf(format string, v ...any) { s := fmt.Sprintf(format, v...) std.Output(2, s) panic(s) } func Panicln(v ...any) { s := fmt.Sprintln(v...) std.Output(2, s) panic(s) } 可以发现，这些函数代码主逻辑基本一致，都是通过 std.Output 输出日志。不同的是，PrintX 输出日志后程序就执行结束了；Fatal 输出日志后会执行 os.Exit(1)；而 Panic 输出日志后会执行 panic(s)。\n那么接下来就是要搞清楚这个 std 对象是什么，以及它的 Output 方法是如何定义的。\n我们先来看下 std 是什么：\n1 2 3 4 5 6 7 8 9 var std = New(os.Stderr, \u0026#34;\u0026#34;, LstdFlags) func New(out io.Writer, prefix string, flag int) *Logger { l := \u0026amp;Logger{out: out, prefix: prefix, flag: flag} if out == io.Discard { l.isDiscard = 1 } return l } 可以看到，std 其实就是使用 New 创建的一个 Logger 对象，日志输出到标准错误输出，日志前缀为空，日志属性为 LstdFlags。\n这跟我们上面讲的自定义日志对象 logger := log.New(os.Stdout, \u0026quot;[Debug] - \u0026quot;, log.Lshortfile) 方式如出一辙。也就是说，当我们通过 log.Print(\u0026quot;Print\u0026quot;) 打印日志时，其实使用的是 log 包内部已经定义好的 Logger 对象。\nLogger 定义如下：\n1 2 3 4 5 6 7 8 type Logger struct { mu sync.Mutex // 锁，保证并发情况下对其属性操作是原子性的 prefix string // 日志前缀，即 Lmsgprefix 参数值 flag int // 日志属性，用来控制日志输出格式 out io.Writer // 日志输出位置，实现了 io.Writer 接口即可，如 文件、os.Stderr buf []byte // 存储日志输出内容 isDiscard int32 // 当 out = io.Discard 是，此值为 1 } 其中，flag 和 isDiscard 这两个属性有必要进一步解释下。\n首先是 flag 用来记录日志属性，其合法值如下：\n1 2 3 4 5 6 7 8 9 10 const ( Ldate = 1 \u0026lt;\u0026lt; iota // the date in the local time zone: 2009/01/23 Ltime // the time in the local time zone: 01:23:23 Lmicroseconds // microsecond resolution: 01:23:23.123123. assumes Ltime. Llongfile // full file name and line number: /a/b/c/d.go:23 Lshortfile // final file name element and line number: d.go:23. overrides Llongfile LUTC // if Ldate or Ltime is set, use UTC rather than the local time zone Lmsgprefix // move the \u0026#34;prefix\u0026#34; from the beginning of the line to before the message LstdFlags = Ldate | Ltime // initial values for the standard logger ) 具体含义我就不再一一解释了，前文的表格已经写的很详细了。\n值得注意的是，这里在定义常量时，巧妙的使用了左移运算符 1 \u0026lt;\u0026lt; iota，使得常量的值呈现 1、2、4、8… 这样的递增效果。其实是为了位运算方便，通过对属性进行位运算，来决定输出内容，其本质上跟基于位运算的权限管理是一样的。所以在使用 log.New 新建 Logger 对象时可以支持 log.Ldate|log.Ltime|log.Lshortfile 这种形式设置多个属性。\nstd 对象的属性初始值 LstdFlags 也是在这里定义的。\n其次还有一个属性 isDiscard，是用来丢弃日志的。在上面介绍 PrintX 函数定义时，在输出日志前有一个 if atomic.LoadInt32(\u0026amp;std.isDiscard) != 0 的判断，如果结果为真，则直接 return 不记录日志。\n在 Go 标准库的 io 包里，有一个 io.Discard 对象，io.Discard 实现了 io.Writer，它执行 Write 操作后不会产生任何实际的效果，是一个用于丢弃数据的对象。比如有时候我们不在意数据内容，但可能存在数据不读出来就无法关闭连接的情况，这时候就可以使用 io.Copy(io.Discard, io.Reader) 将数据写入 io.Discard 实现丢弃数据的效果。\n使用 New 创建 Logger 对象时，如果 out == io.Discard 则 l.isDiscard 的值会被置为 1，所以使用 PrintX 函数记录的日志将会被丢弃，而 isDiscard 属性之所以是 int32 类型而不是 bool，是因为方便原子操作。\n现在，我们终于可以来看 std.Output 的实现了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 func (l *Logger) Output(calldepth int, s string) error { now := time.Now() // 获取当前时间 var file string var line int // 加锁，保证并发安全 l.mu.Lock() defer l.mu.Unlock() // 通过位运算来判断是否需要获取文件名和行号 if l.flag\u0026amp;(Lshortfile|Llongfile) != 0 { // 运行 runtime.Caller 获取文件名和行号比较耗时，所以先释放锁 l.mu.Unlock() var ok bool _, file, line, ok = runtime.Caller(calldepth) if !ok { file = \u0026#34;???\u0026#34; line = 0 } // 获取到文件行号后再次加锁，保证下面代码并发安全 l.mu.Lock() } // 清空上次缓存的内容 l.buf = l.buf[:0] // 格式化日志头信息（如：日期时间、文件名和行号、前缀）并写入 buf l.formatHeader(\u0026amp;l.buf, now, file, line) // 追加日志内容到 buf l.buf = append(l.buf, s...) // 保证输出日志以 \\n 结尾 if len(s) == 0 || s[len(s)-1] != \u0026#39;\\n\u0026#39; { l.buf = append(l.buf, \u0026#39;\\n\u0026#39;) } // 调用 Logger 对象的 out 属性的 Write 方法输出日志 _, err := l.out.Write(l.buf) return err } Output 方法代码并不多，基本逻辑也比较清晰，首先根据日志属性来决定是否需要获取文件名和行号，因为调用 runtime.Caller 是一个耗时操作，开销比较大，为了增加并发性，暂时将锁释放，获取到文件名和行号后再重新加锁。\n接下来就是准备日志输出内容了，首先清空 buf 中保留的上次日志信息，然后通过 formatHeader 方法格式化日志头信息，接着把日志内容也追加到 buf 中，在这之后有一个保证输出日志以 \\n 结尾的逻辑，来保证输出的日志都是单独一行的。不知道你有没有注意到，在前文的 log 包使用示例中，我们使用 Print 和 Println 两个方法时，最终日志输出效果并无差别，使用 Print 打印日志也会换行，其实就是这里的逻辑决定的。\n最后，通过调用 l.out.Write 方法，将 buf 内容输出。\nfunc Caller(skip int) (pc uintptr, file string, line int, ok bool)\n当skip为0时，获取调用该函数的函数信息，返回值包括程序计数器（pc：program counter栈帧的入口地址）、file调用函数所在文件的绝对路径、line调用行号，ok是否获取成功 当skip为1时，获取调用该函数的调用函数的信息，返回值包括程序计数器（pc：program counter栈帧的入口地址）、调用函数所在文件的绝对路径、调用行号，是否获取成功 以此类推 func FuncForPC(pc uintptr) *Func\n根据pc获取调用函数对象，name属性可以获取调用函数名. func CallersFrames(callers []uintptr) *Frames\n根据pc字节切片获取调用栈帧。next()方法获取栈帧。然后通过栈帧可以获取函数名，函数所在文件的绝对路径。调用行号。 1 2 3 4 5 6 7 8 9 frames := runtime.CallersFrames([]uintptr{pc}) // 遍历栈帧 for { frame, more := frames.Next() if !more { break } fmt.Printf(\u0026#34;函数名: %s, 文件: %s, 行号: %d\\n\u0026#34;, frame.Function, frame.File, frame.Line) } 我们来看下用来格式化日志头信息的 formatHeader 方法是如何定义：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 func (l *Logger) formatHeader(buf *[]byte, t time.Time, file string, line int) { // 如果没有设置 Lmsgprefix 属性，将日志前缀内容设置到行首 if l.flag\u0026amp;Lmsgprefix == 0 { *buf = append(*buf, l.prefix...) } // 判断是否设置了日期时间相关的属性 if l.flag\u0026amp;(Ldate|Ltime|Lmicroseconds) != 0 { // 是否设置 UTC 时间 if l.flag\u0026amp;LUTC != 0 { t = t.UTC() } // 是否设置日期 if l.flag\u0026amp;Ldate != 0 { year, month, day := t.Date() itoa(buf, year, 4) *buf = append(*buf, \u0026#39;/\u0026#39;) itoa(buf, int(month), 2) *buf = append(*buf, \u0026#39;/\u0026#39;) itoa(buf, day, 2) *buf = append(*buf, \u0026#39; \u0026#39;) } // 是否设置时间 if l.flag\u0026amp;(Ltime|Lmicroseconds) != 0 { hour, min, sec := t.Clock() itoa(buf, hour, 2) *buf = append(*buf, \u0026#39;:\u0026#39;) itoa(buf, min, 2) *buf = append(*buf, \u0026#39;:\u0026#39;) itoa(buf, sec, 2) if l.flag\u0026amp;Lmicroseconds != 0 { *buf = append(*buf, \u0026#39;.\u0026#39;) itoa(buf, t.Nanosecond()/1e3, 6) } *buf = append(*buf, \u0026#39; \u0026#39;) } } // 是否设置文件名和行号 if l.flag\u0026amp;(Lshortfile|Llongfile) != 0 { if l.flag\u0026amp;Lshortfile != 0 { short := file for i := len(file) - 1; i \u0026gt; 0; i-- { if file[i] == \u0026#39;/\u0026#39; { short = file[i+1:] break } } file = short } *buf = append(*buf, file...) *buf = append(*buf, \u0026#39;:\u0026#39;) itoa(buf, line, -1) *buf = append(*buf, \u0026#34;: \u0026#34;...) } // 如果设置了 Lmsgprefix 属性，将日志前缀内容放到日志头信息最后，也就是紧挨着日志内容前面 if l.flag\u0026amp;Lmsgprefix != 0 { *buf = append(*buf, l.prefix...) } } formatHeader 方法是 log 包里面代码量最多的一个方法，主要通过按位与（\u0026amp;）来计算是否设置了某个日志属性，然后根据日志属性来格式化头信息。\n其中多次调用 itoa 函数，itoa 顾名思义，将 int 转换成 ASCII 码，itoa 定义如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func itoa(buf *[]byte, i int, wid int) { // Assemble decimal in reverse order. var b [20]byte bp := len(b) - 1 for i \u0026gt;= 10 || wid \u0026gt; 1 { wid-- q := i / 10 b[bp] = byte(\u0026#39;0\u0026#39; + i - q*10) bp-- i = q } // i \u0026lt; 10 b[bp] = byte(\u0026#39;0\u0026#39; + i) *buf = append(*buf, b[bp:]...) } 这个函数短小精悍，它接收三个参数，buf 用来保存转换后的内容，i 就是带转换的值，比如 year、month 等，wid 表示转换后 ASCII 码字符串宽度，如果传进来的 i 宽度不够，则前面补零。比如传入 itoa(\u0026amp;b, 12, 3)，最终输出字符串为 012。\n'0'+i会隐式触发字符和ASCII之间的转换，0的ASCII码是48，加0~9就是对应0~9的ASCII码，超过57就是别的字符。\n至此，我们已经理清了 log.Print(\u0026quot;Print\u0026quot;) 是如何打印一条日志的，其函数调用流程如下：\n上面我们讲解了使用 log 包中默认的 std 这个 Logger 对象打印日志的调用流程。当我们使用自定义的 Logger 对象（logger := log.New(os.Stdout, \u0026quot;[Debug] - \u0026quot;, log.Lshortfile)）来打印日志时，调用的 loggger.Print 是一个方法，而不是 log.Print 这个包级别的函数，所以其实 Logger 结构体也实现了 9 种输出日志方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 func (l *Logger) Print(v ...any) { if atomic.LoadInt32(\u0026amp;l.isDiscard) != 0 { return } l.Output(2, fmt.Sprint(v...)) } func (l *Logger) Printf(format string, v ...any) { if atomic.LoadInt32(\u0026amp;l.isDiscard) != 0 { return } l.Output(2, fmt.Sprintf(format, v...)) } func (l *Logger) Println(v ...any) { if atomic.LoadInt32(\u0026amp;l.isDiscard) != 0 { return } l.Output(2, fmt.Sprintln(v...)) } func (l *Logger) Fatal(v ...any) { l.Output(2, fmt.Sprint(v...)) os.Exit(1) } func (l *Logger) Fatalf(format string, v ...any) { l.Output(2, fmt.Sprintf(format, v...)) os.Exit(1) } func (l *Logger) Fatalln(v ...any) { l.Output(2, fmt.Sprintln(v...)) os.Exit(1) } func (l *Logger) Panic(v ...any) { s := fmt.Sprint(v...) l.Output(2, s) panic(s) } func (l *Logger) Panicf(format string, v ...any) { s := fmt.Sprintf(format, v...) l.Output(2, s) panic(s) } func (l *Logger) Panicln(v ...any) { s := fmt.Sprintln(v...) l.Output(2, s) panic(s) } 这 9 个方法跟 log 包级别的函数一一对应，用于自定义 Logger 对象。\n有一个值得注意的点，在这些方法内部，调用 l.Output(2, s) 时，第一个参数 calldepth 传递的是 2，这跟 runtime.Caller(calldepth) 函数内部实现有关，runtime.Caller 函数签名如下：\n1 func Caller(skip int) (pc uintptr, file string, line int, ok bool) runtime.Caller 返回当前 Goroutine 的栈上的函数调用信息（程序计数器、文件信息、行号），其参数 skip 表示当前向上层的栈帧数，0 代表当前函数，也就是调用 runtime.Caller 的函数，1 代表上一层调用者，以此类推。\n因为函数调用链为 main.go -\u0026gt; log.Print -\u0026gt; std.Output -\u0026gt; runtime.Caller，所以 skip 值即为 2：\n0: 表示 std.Output 中调用 runtime.Caller 所在的源码文件和行号。 1: 表示 log.Print 中调用 std.Output 所在的源码文件和行号。 2: 表示 main.go 中调用 log.Print 所在的源码文件和行号。 这样当代码出现问题时，就能根据日志中记录的函数调用栈来找到报错的源码位置了。\n另外，前文介绍过三个设置 Logger 对象属性的方法，分别是 SetOutput、SetPrefix、SetFlags，其实这三个方法各自还有与之对应的获取相应属性的方法，定义如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 func (l *Logger) Flags() int { l.mu.Lock() defer l.mu.Unlock() return l.flag } func (l *Logger) SetFlags(flag int) { l.mu.Lock() defer l.mu.Unlock() l.flag = flag } func (l *Logger) Prefix() string { l.mu.Lock() defer l.mu.Unlock() return l.prefix } func (l *Logger) SetPrefix(prefix string) { l.mu.Lock() defer l.mu.Unlock() l.prefix = prefix } func (l *Logger) Writer() io.Writer { l.mu.Lock() defer l.mu.Unlock() return l.out } func (l *Logger) SetOutput(w io.Writer) { l.mu.Lock() defer l.mu.Unlock() l.out = w isDiscard := int32(0) if w == io.Discard { isDiscard = 1 } atomic.StoreInt32(\u0026amp;l.isDiscard, isDiscard) } 其实就是针对每个私有属性，定义了 getter、setter 方法，并且每个方法内部为了保证并发安全，都进行了加锁操作。\n当然，log 包级别的函数，也少不了这几个功能：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 func Default() *Logger { return std } func SetOutput(w io.Writer) { std.SetOutput(w) } func Flags() int { return std.Flags() } func SetFlags(flag int) { std.SetFlags(flag) } func Prefix() string { return std.Prefix() } func SetPrefix(prefix string) { std.SetPrefix(prefix) } func Writer() io.Writer { return std.Writer() } func Output(calldepth int, s string) error { return std.Output(calldepth+1, s) // +1 for this frame. } 至此，log 包的全部代码我们就一起走读完成了。\n总结一下：log 包主要设计了 Logger 对象和其方法，并且为了开箱即用，在包级别又对外提供了默认的 Logger 对象 std 和一些包级别的对外函数。Logger 对象的方法，和包级别的函数基本上是一一对应的，签名一样，这样就大大降低了使用难度。并且log包是并发安全的。\n# 使用建议 关于 log 包的使用，我还有几条建议分享给你：\nlog 默认不支持 Debug、Info、Warn 等更细粒度级别的日志输出方法，不过我们可以通过创建多个 Logger 对象的方式来实现，只需要给每个 Logger 对象指定不同的日志前缀即可：\n1 2 3 4 loggerDebug = log.New(os.Stdout, \u0026#34;[Debug]\u0026#34;, log.LstdFlags) loggerInfo = log.New(os.Stdout, \u0026#34;[Info]\u0026#34;, log.LstdFlags) loggerWarn = log.New(os.Stdout, \u0026#34;[Warn]\u0026#34;, log.LstdFlags) loggerError = log.New(os.Stdout, \u0026#34;[Error]\u0026#34;, log.LstdFlags) log 包作为 Go 标准库，仅支持日志的基本功能，不支持记录结构化日志、日志切割、Hook 等高级功能，所以更适合小型项目使用，比如一个单文件的脚本。对于中大型项目，则推荐使用一些主流的第三方日志库，如 logrus、zap、glog 等。\n另外，如果你对 Go 标准日志库有所期待，Go 官方还打造了另一个日志库 slog 现已进入实验阶段，如果项目发展顺利，将可能成为 log 包的替代品。\n# 总结 本文我与读者一起深入探究了 Go log 标准库，首先向大家介绍了 log 包如何使用，接着又带领大家一起走读了 log 包的源码，最后我也给出了一些自己对 log 包的使用建议。\n参考：\nGo log 源码 Go 每日一库之 log 搬运自深入探究 Go log 标准库 ","date":"2024-04-27T16:54:38+08:00","permalink":"https://arlettebrook.github.io/p/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%A9%B6-go-log-%E6%A0%87%E5%87%86%E5%BA%93/","title":"深入探究 Go log 标准库"},{"content":" 在程序开发中，有些场景是我们经常会遇到的，软件行业的先行者们帮我们总结了一些解决常见场景编码问题的最佳实践，于是就有了设计模式。选项模式在 Go 语言开发中会经常用到，所以今天我们来介绍一下选项模式的应用。\n熟悉 Python 开发的同学都知道，Python 有默认参数的存在，使得我们在实例化一个对象的时候，可以根据需要来选择性的覆盖某些默认参数，以此来决定如何实例化对象。当一个对象有多个默认参数时，这个特性非常好用，能够优雅的简化代码。\n而 Go 语言从语法上是不支持默认参数的，所以为了实现既能通过默认参数创建对象，又能通过传递自定义参数创建对象，我们就需要通过一些编程技巧来实现。\n# 通过多构造函数实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 package main import \u0026#34;fmt\u0026#34; const ( defaultAddr = \u0026#34;127.0.0.1\u0026#34; defaultPort = 8000 ) type Server struct { Addr string Port int } func NewServer() *Server { return \u0026amp;Server{ Addr: defaultAddr, Port: defaultPort, } } func NewServerWithOptions(addr string, port int) *Server { return \u0026amp;Server{ Addr: addr, Port: port, } } func main() { s1 := NewServer() s2 := NewServerWithOptions(\u0026#34;localhost\u0026#34;, 8001) fmt.Println(s1) // \u0026amp;{127.0.0.1 8000} fmt.Println(s2) // \u0026amp;{localhost 8001} } 这里我们为 Server 结构体实现了两个构造函数，其中 NewServer 无需传递参数即可直接返回 Server 对象，NewServerWithOptions 则需要传递 addr 和 port 两个参数来构造 Server 对象。当我们无需对 Server 进行定制，通过默认参数创建的对象即可满足需求时，我们可以使用 NewServer 来生成对象（s1），而当我们需要对其进行定制时，则可以使用 NewServerWithOptions 来生成对象（s2）。\n# 通过默认参数选项实现 另外一种实现默认参数的方案是，我们可以为要生成的结构体对象定义一个选项结构体，用来生成要创建对象的默认参数，代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 package main import \u0026#34;fmt\u0026#34; const ( defaultAddr = \u0026#34;127.0.0.1\u0026#34; defaultPort = 8000 ) type Server struct { Addr string Port int } type ServerOptions struct { Addr string Port int } func NewServerOptions() *ServerOptions { return \u0026amp;ServerOptions{ Addr: defaultAddr, Port: defaultPort, } } func NewServerWithOptions(opts *ServerOptions) *Server { return \u0026amp;Server{ Addr: opts.Addr, Port: opts.Port, } } func main() { s1 := NewServerWithOptions(NewServerOptions()) s2 := NewServerWithOptions(\u0026amp;ServerOptions{ Addr: \u0026#34;localhost\u0026#34;, Port: 8001, }) fmt.Println(s1) // \u0026amp;{127.0.0.1 8000} fmt.Println(s2) // \u0026amp;{localhost 8001} } 我们为 Server 结构体专门实现了一个 ServerOptions 用来生成默认参数，调用 NewServerOptions 函数即可获得默认参数配置，构造函数 NewServerWithOptions 接收一个 *ServerOptions 类型作为参数，所以我们可以直接将调用 NewServerOptions 函数的返回值传递给 NewServerWithOptions 来实现通过默认参数生成对象（s1），也可以通过手动构造 ServerOptions 配置来生成定制对象（s2）。\n# 通过选项模式实现 以上两种方式虽然都能够完成功能，但实现上却都不够优雅，接下来我们一起来看下如何通过选项模式更优雅的解决这个问题，代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 package main import \u0026#34;fmt\u0026#34; const ( defaultAddr = \u0026#34;127.0.0.1\u0026#34; defaultPort = 8000 ) type Server struct { Addr string Port int } type ServerOptions struct { Addr string Port int } type ServerOption interface { apply(*ServerOptions) } type FuncServerOption struct { f func(*ServerOptions) } func (fo FuncServerOption) apply(option *ServerOptions) { fo.f(option) } func WithAddr(addr string) ServerOption { return FuncServerOption{ f: func(options *ServerOptions) { options.Addr = addr }, } } func WithPort(port int) ServerOption { return FuncServerOption{ f: func(options *ServerOptions) { options.Port = port }, } } func NewServer(opts ...ServerOption) *Server { options := ServerOptions{ Addr: defaultAddr, Port: defaultPort, } for _, opt := range opts { opt.apply(\u0026amp;options) } return \u0026amp;Server{ Addr: options.Addr, Port: options.Port, } } func main() { s1 := NewServer() s2 := NewServer(WithAddr(\u0026#34;localhost\u0026#34;), WithPort(8001)) s3 := NewServer(WithPort(8001)) fmt.Println(s1) // \u0026amp;{127.0.0.1 8000} fmt.Println(s2) // \u0026amp;{localhost 8001} fmt.Println(s3) // \u0026amp;{127.0.0.1 8001} } 乍一看，我们的代码复杂了很多，但其实都是定义上的复杂，调用构造函数生成对象的代码复杂度是没有改变的。\n在这里我们定义了 ServerOptions 结构体用来配置默认参数，因为这里 Addr 和 Port 都有默认参数，所以 ServerOptions 的定义和 Server 定义是一样的，但有一定复杂性的结构体中可能会有些参数没有默认参数，必须让用户来配置，这时 ServerOptions 的字段就会少一些，大家可以按需定义。\n同时，我们还定义了一个 ServerOption 接口和实现了此接口的 FuncServerOption 结构体，它们的作用是让我们能够通过 apply 方法为 ServerOptions 结构体单独配置某项参数。\n我们可以分别为每个默认参数都定义一个 WithXXX 函数用来配置参数，如这里定义的 WithAddr 和 WithPort ，这样用户就可以通过调用 WithXXX 函数来定制需要覆盖的默认参数。\n此时默认参数定义在构造函数 NewServer 中，构造函数的接收一个不定长参数，类型为 ServerOption，在构造函数内部通过一个 for 循环调用每个传进来的 ServerOption 对象的 apply 方法，将用户配置的参数依次赋值给构造函数内部的默认参数对象 options 中，以此来替换默认参数，for 循环执行完成后，得到的 options 对象将是最终配置，将其属性依次赋值给 Server 即可生成新的对象。\n# 总结 通过 s2 和 s3 的打印结果可以发现，使用选项模式实现的构造函数更加灵活，相较于前两种实现，选项模式中我们可以自由的更改其中任意一项或多项默认配置。\n虽然选项模式确实会多写一些代码，但多数情况下这是值得的，Google 的 gRPC 框架 Go 语言实现中创建 gRPC server 的构造函数 NewServer 就使用了选项模式，感兴趣的同学可以看下其源码的实现思想其实和这里的示例程序如出一辙。\n希望今天的分享能够给你带来一点帮助。\n原文地址：Go 常见设计模式之选项模式\n","date":"2024-04-25T23:22:54+08:00","permalink":"https://arlettebrook.github.io/p/go%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E9%80%89%E9%A1%B9%E6%A8%A1%E5%BC%8F/","title":"Go常见设计模式：选项模式"},{"content":" 单例模式是设计模式中最简单的一种模式，单例模式能够确保无论对象被实例化多少次，全局都只有一个实例存在。根据单例模式的特性，我们可以将其应用到全局唯一性配置、数据库连接对象、文件访问对象等。Go 语言有多种方式可以实现单例模式，我们今天就来一起学习下。\n# 饿汉式 饿汉式实现单例模式非常简单，直接看代码：\n1 2 3 4 5 6 7 8 9 package singleton type Singleton struct{} var instance = \u0026amp;Singleton{} func GetSingleton() *Singleton { return instance } singleton 包在被导入时会自动初始化 instance 实例，使用时通过调用 singleton.GetSingleton() 函数即可获得 Singleton 这个结构体的单例对象。\n由于单例对象是在包加载时立即被创建出来，所以也就有了这个形象的名称叫作饿汉式。与之对应的另一种实现方式叫作懒汉式，当实例被第一次使用时才会被创建。\n需要注意的是，尽管饿汉式实现单例模式如此简单，但大多数情况下仍不被推荐使用，因为如果单例实例化时初始化内容过多，可能造成程序加载用时较长。\n# 懒汉式 接下来我们再来看下如何通过懒汉式实现单例模式：\n1 2 3 4 5 6 7 8 9 10 11 12 package singleton type Singleton struct{} var instance *Singleton func GetSingleton() *Singleton { if instance == nil { instance = \u0026amp;Singleton{} } return instance } 相较于饿汉式的实现，我们把实例化 Singleton 结构体部分的代码移到了 GetSingleton() 函数内部。这样一来，就将对象实例化的步骤延迟到了 GetSingleton() 被第一次调用时。\n通过 instance == nil 的判断来实现单例并不十分可靠，当有多个 goroutine 同时调用 GetSingleton() 时无法保证并发安全。\n# 支持并发的单例 如果你用 Go 语言写过并发编程，那么应该可以很快想到解决懒汉式单例模式并发安全问题的方案：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package singleton import \u0026#34;sync\u0026#34; type Singleton struct{} var instance *Singleton var mu sync.Mutex func GetSingleton() *Singleton { mu.Lock() defer mu.Unlock() if instance == nil { instance = \u0026amp;Singleton{} } return instance } 我们对代码的主要修改就是在 GetSingleton() 函数最开始加了如下两行代码：\n1 2 mu.Lock() defer mu.Unlock() 通过加锁的机制，就可以保证这个实现单例模式的函数是并发安全的。\n不过这样也有些问题，因为用了锁机制，每次调用 GetSingleton() 时程序都会进行加锁、解锁的步骤，这样会导致程序性能的下降。\n# 双重锁定 加锁导致程序性能下降，但我们又不得不用锁来保证程序的并发安全，于是有人想出了双重锁定（Double-Check Locking）的方案：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package singleton import \u0026#34;sync\u0026#34; type Singleton struct{} var instance *Singleton var mu sync.Mutex func GetSingleton() *Singleton { if instance == nil { mu.Lock() defer mu.Unlock() if instance == nil { instance = \u0026amp;Singleton{} } } return instance } 可以看到，所谓的双重锁定实际上就是在程序加锁前又加了一层 instance == nil 判断，这样就兼顾了性能和安全两个方面。\n不过这段代码看起来有些奇怪，既然外层已经判断了 instance == nil，加锁后却又进行了第二次 instance == nil 判断。其实外层的 instance == nil 判断是为了提高程序的执行效率，因为如果 instance 已经存在，则无需进入 if 逻辑，程序直接返回 instance 即可。这样就免去了原来每次调用 GetSingleton() 都上锁的操作，将加锁的粒度更加精细化。而内层的 instance == nil 判断则是考虑了并发安全，在极端情况下，多个 goroutine 同时走到了加锁这一步，内层判断就起到作用了。\n# Gopher 惯用方案 gopher原意地鼠，在golang 的世界里解释为地道的go程序员。在其他语言的世界里也有PHPer，Pythonic的说法，反而Java是个例外。虽然也有Javaer之类的说法，但似乎并不被认可。而地道或者说道地，说的是gopher写的代码无不透露出go的独特气息，比如项目结构、命名方式、代码格式、编码风格、构建方式等等。用gopher的话说，用go编写代码就像是在画一幅中国山水画，成品美不胜收，心旷神怡。\n虽然我们通过双重锁定机制兼顾和性能和并发安全，但代码有些丑陋，不符合广大 Gopher 的期待。好在 Go 语言在 sync 包中提供了 Once 机制能够帮助我们写出更加优雅的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package singleton import \u0026#34;sync\u0026#34; type Singleton struct{} var instance *Singleton var once sync.Once func GetSingleton() *Singleton { once.Do(func() { instance = \u0026amp;Singleton{} }) return instance } Once 是一个结构体，在执行 Do 方法的内部通过 atomic 操作和加锁机制来保证并发安全，且 once.Do 能够保证多个 goroutine 同时执行时 \u0026amp;singleton{} 只被创建一次。\n其实 Once 并不神秘，其内部实现跟上面使用的双重锁定机制非常类似，只不过把 instance == nil 换成了 atomic 操作，感兴趣的同学可以查看下其对应源码。\n# 总结 以上就是 Go 语言中实现单例模式的几种常用套路，经过对比可以得出结论，最推荐的方式是使用 once.Do 来实现，sync.Once 包帮我们隐藏了部分细节，却可以让代码可读性得到很大提升。\n# 参考 不一样的go语言-gopher Go 常见设计模式之单例模式 ","date":"2024-04-25T18:00:25+08:00","permalink":"https://arlettebrook.github.io/p/go%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","title":"Go常见设计模式：单例模式"},{"content":" # 引子 在工作中，我时不时地会需要在Go中调用外部命令。前段时间我做了一个工具，在钉钉群中添加了一个机器人，@这个机器人可以让它执行一些写好的脚本程序完成指定的任务。机器人倒是不难，照着钉钉开发者文档添加好机器人，然后@这个机器人就会向一个你指定的服务器发送一个POST请求，请求中会附带文本消息。所以我要做的就是搭一个Web服务器，可以用go原生的net/http包，也可以用gin/fasthttp/fiber这些Web框架。收到请求之后，检查附带文本中的关键字去调用对应的程序，然后返回结果。\ngo标准库中的os/exec包对调用外部程序提供了支持，本文详细介绍os/exec的使用姿势。\n# 运行命令 Linux中有个cal命令，它可以显示指定年、月的日历，如果不指定年、月，默认为当前时间对应的年月。如果使用的是Windows，推荐安装msys2，这个软件包含了绝大多数的Linux常用命令。\n那么，在Go代码中怎么调用这个命令呢？其实也很简单：\n1 2 3 4 5 6 7 func main() { cmd := exec.Command(\u0026#34;cal\u0026#34;) err := cmd.Run() if err != nil { log.Fatalf(\u0026#34;cmd.Run() failed: %v\\n\u0026#34;, err) } } 首先，我们调用exec.Command传入命令名，创建一个命令对象exec.Cmd。接着调用该命令对象的Run()方法运行它。\n如果你实际运行了，你会发现什么也没有发生，哈哈。事实上，使用os/exec执行命令，标准输出和标准错误默认会被丢弃。\n# 显示输出 exec.Cmd对象有两个字段Stdout和Stderr，类型皆为io.Writer。我们可以将任意实现了io.Writer接口的类型实例赋给这两个字段，继而实现标准输出和标准错误的重定向。io.Writer接口在 Go 标准库和第三方库中随处可见，例如*os.File、*bytes.Buffer、net.Conn。所以我们可以将命令的输出重定向到文件、内存缓存甚至发送到网络中。\n# 显示到标准输出 将exec.Cmd对象的Stdout和Stderr这两个字段都设置为os.Stdout，那么输出内容都将显示到标准输出：\n1 2 3 4 5 6 7 8 9 func main() { cmd := exec.Command(\u0026#34;cal\u0026#34;) cmd.Stdout = os.Stdout cmd.Stderr = os.Stderr err := cmd.Run() if err != nil { log.Fatalf(\u0026#34;cmd.Run() failed: %v\\n\u0026#34;, err) } } 运行程序。我在git bash运行，得到如下结果：\n输出了中文，检查一下环境变量LANG的值，果然是zh_CN.UTF-8。如果想输出英文，可以将环境变量LANG设置为en_US.UTF-8：\n1 2 3 $ echo $LANG zh_CN.UTF-8 $ LANG=en_US.UTF-8 go run main.go 得到输出：\n# 输出到文件 打开或创建文件，然后将文件句柄赋给exec.Cmd对象的Stdout和Stderr这两个字段即可实现输出到文件的功能。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 func main() { f, err := os.OpenFile(\u0026#34;out.txt\u0026#34;, os.O_WRONLY|os.O_CREATE, os.ModePerm) if err != nil { log.Fatalf(\u0026#34;os.OpenFile() failed: %v\\n\u0026#34;, err) } cmd := exec.Command(\u0026#34;cal\u0026#34;) cmd.Stdout = f cmd.Stderr = f err = cmd.Run() if err != nil { log.Fatalf(\u0026#34;cmd.Run() failed: %v\\n\u0026#34;, err) } } os.OpenFile打开一个文件，指定os.O_CREATE标志让操作系统在文件不存在时自动创建一个，返回该文件对象*os.File。*os.File实现了io.Writer接口。\n运行程序：\n1 2 3 4 5 6 7 8 9 $ go run main.go $ cat out.txt November 2022 Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 # 发送到网络 现在我们来编写一个日历服务，接收年、月信息，返回该月的日历。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func cal(w http.ResponseWriter, r *http.Request) { year := r.URL.Query().Get(\u0026#34;year\u0026#34;) month := r.URL.Query().Get(\u0026#34;month\u0026#34;) cmd := exec.Command(\u0026#34;cal\u0026#34;, month, year) cmd.Stdout = w cmd.Stderr = w err := cmd.Run() if err != nil { log.Fatalf(\u0026#34;cmd.Run() failed: %v\\n\u0026#34;, err) } } func main() { http.HandleFunc(\u0026#34;/cal\u0026#34;, cal) http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil) } 这里为了简单，错误处理都省略了。正常情况下，year和month参数都需要做合法性校验。exec.Command函数接收一个字符串类型的可变参数作为命令的参数：\n1 func Command(name string, arg ...string) *Cmd # 保存到内存对象中 *bytes.Buffer同样也实现了io.Writer接口，故如果我们创建一个*bytes.Buffer对象，并将其赋给exec.Cmd的Stdout和Stderr这两个字段，那么命令执行之后，该*bytes.Buffer对象中保存的就是命令的输出。\n1 2 3 4 5 6 7 8 9 10 11 12 func main() { buf := bytes.NewBuffer(nil) cmd := exec.Command(\u0026#34;cal\u0026#34;) cmd.Stdout = buf cmd.Stderr = buf err := cmd.Run() if err != nil { log.Fatalf(\u0026#34;cmd.Run() failed: %v\\n\u0026#34;, err) } fmt.Println(buf.String()) } 运行：\n1 2 3 4 5 6 7 8 $ go run main.go November 2022 Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 运行命令，然后得到输出的字符串或字节切片这种模式是如此的普遍，并且使用便利，os/exec包提供了一个便捷方法：CombinedOutput。\n# 输出到多个目的地 有时，我们希望能输出到文件和网络，同时保存到内存对象。使用go提供的io.MultiWriter可以很容易实现这个需求。io.MultiWriter很方便地将多个io.Writer转为一个io.Writer。\n我们稍微修改上面的web程序：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func cal(w http.ResponseWriter, r *http.Request) { year := r.URL.Query().Get(\u0026#34;year\u0026#34;) month := r.URL.Query().Get(\u0026#34;month\u0026#34;) f, _ := os.OpenFile(\u0026#34;out.txt\u0026#34;, os.O_CREATE|os.O_WRONLY, os.ModePerm) buf := bytes.NewBuffer(nil) mw := io.MultiWriter(w, f, buf) cmd := exec.Command(\u0026#34;cal\u0026#34;, month, year) cmd.Stdout = mw cmd.Stderr = mw err := cmd.Run() if err != nil { log.Fatalf(\u0026#34;cmd.Run() failed: %v\\n\u0026#34;, err) } fmt.Println(buf.String()) } 调用io.MultiWriter将多个io.Writer整合成一个io.Writer，然后将cmd对象的Stdout和Stderr都赋值为这个io.Writer。这样，命令运行时产出的输出会分别送往http.ResponseWriter、*os.File以及*bytes.Buffer。\n# 运行命令，获取输出 前面提到，我们常常需要运行命令，返回输出。exec.Cmd对象提供了一个便捷方法：CombinedOutput()。该方法运行命令，将输出内容以一个字节切片返回便于后续处理。所以，上面获取输出的程序可以简化为：\n1 2 3 4 5 6 7 8 9 func main() { cmd := exec.Command(\u0026#34;cal\u0026#34;) output, err := cmd.CombinedOutput() if err != nil { log.Fatalf(\u0026#34;cmd.Run() failed: %v\\n\u0026#34;, err) } fmt.Println(string(output)) } So easy!\nCombinedOutput()方法的实现很简单，先将标准输出和标准错误重定向到*bytes.Buffer对象，然后运行程序，最后返回该对象中的字节切片：\n1 2 3 4 5 6 7 8 9 10 11 12 13 func (c *Cmd) CombinedOutput() ([]byte, error) { if c.Stdout != nil { return nil, errors.New(\u0026#34;exec: Stdout already set\u0026#34;) } if c.Stderr != nil { return nil, errors.New(\u0026#34;exec: Stderr already set\u0026#34;) } var b bytes.Buffer c.Stdout = \u0026amp;b c.Stderr = \u0026amp;b err := c.Run() return b.Bytes(), err } CombinedOutput方法前几行判断表明，Stdout和Stderr必须是未设置状态。这其实很好理解，一般情况下，如果已经打算使用CombinedOutput方法获取输出内容，不会再自找麻烦地再去设置Stdout和Stderr字段了。\n与CombinedOutput类似的还有Output方法，区别是Output只会返回运行命令产出的标准输出内容。\n# 分别获取标准输出和标准错误 创建两个*bytes.Buffer对象，分别赋给exec.Cmd对象的Stdout和Stderr这两个字段，然后运行命令即可分别获取标准输出和标准错误。\n1 2 3 4 5 6 7 8 9 10 11 12 func main() { cmd := exec.Command(\u0026#34;cal\u0026#34;, \u0026#34;15\u0026#34;, \u0026#34;2012\u0026#34;) var stdout, stderr bytes.Buffer cmd.Stdout = \u0026amp;stdout cmd.Stderr = \u0026amp;stderr err := cmd.Run() if err != nil { log.Fatalf(\u0026#34;cmd.Run() failed: %v\\n\u0026#34;, err) } fmt.Printf(\u0026#34;output:\\n%s\\nerror:\\n%s\\n\u0026#34;, stdout.String(), stderr.String()) } # 标准输入 exec.Cmd对象有一个类型为io.Reader的字段Stdin。命令运行时会从这个io.Reader读取输入。先来看一个最简单的例子：\n1 2 3 4 5 6 7 8 9 func main() { cmd := exec.Command(\u0026#34;cat\u0026#34;) cmd.Stdin = bytes.NewBufferString(\u0026#34;hello\\nworld\u0026#34;) cmd.Stdout = os.Stdout err := cmd.Run() if err != nil { log.Fatalf(\u0026#34;cmd.Run() failed: %v\\n\u0026#34;, err) } } 如果不带参数运行cat命令，则进入交互模式，cat按行读取输入，并且原样发送到输出。\n再来看一个复杂点的例子。Go标准库中compress/bzip2包只提供解压方法，并没有压缩方法。我们可以利用Linux命令bzip2实现压缩。bzip2从标准输入中读取数据，将其压缩，并发送到标准输出。\n1 2 3 4 5 6 7 8 9 10 11 12 func bzipCompress(d []byte) ([]byte, error) { var out bytes.Buffer cmd := exec.Command(\u0026#34;bzip2\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;-9\u0026#34;) cmd.Stdin = bytes.NewBuffer(d) cmd.Stdout = \u0026amp;out err := cmd.Run() if err != nil { log.Fatalf(\u0026#34;cmd.Run() failed: %v\\n\u0026#34;, err) } return out.Bytes(), nil } 参数-c表示压缩，-9表示压缩等级，9为最高。为了验证函数的正确性，写个简单的程序，先压缩\u0026quot;hello world\u0026quot;字符串，然后解压，看看是否能得到原来的字符串：\n1 2 3 4 5 6 7 func main() { data := []byte(\u0026#34;hello world\u0026#34;) compressed, _ := bzipCompress(data) r := bzip2.NewReader(bytes.NewBuffer(compressed)) decompressed, _ := ioutil.ReadAll(r) fmt.Println(string(decompressed)) } 运行程序，输出\u0026quot;hello world\u0026quot;。\n# 环境变量 环境变量可以在一定程度上微调程序的行为，当然这需要程序的支持。例如，设置ENV=production会抑制调试日志的输出。每个环境变量都是一个键值对。exec.Cmd对象中有一个类型为[]string的字段Env。我们可以通过修改它来达到控制命令运行时的环境变量的目的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;os/exec\u0026#34; ) func main() { cmd := exec.Command(\u0026#34;bash\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;./test.sh\u0026#34;) nameEnv := \u0026#34;NAME=darjun\u0026#34; ageEnv := \u0026#34;AGE=18\u0026#34; newEnv := append(os.Environ(), nameEnv, ageEnv) cmd.Env = newEnv out, err := cmd.CombinedOutput() if err != nil { log.Fatalf(\u0026#34;cmd.Run() failed: %v\\n\u0026#34;, err) } fmt.Println(string(out)) } 上面代码获取系统的环境变量，然后又添加了两个环境变量NAME和AGE。最后使用bash运行脚本test.sh：\n1 2 3 4 5 #!/bin/bash echo $NAME echo $AGE echo $GOPATH 程序运行结果：\n1 2 3 4 $ go run main.go darjun 18 D:\\workspace\\code\\go # 检查命令是否存在 一般在运行命令之前，我们通过希望能检查要运行的命令是否存在，如果存在则直接运行，否则提示用户安装此命令。os/exec包提供了函数LookPath可以获取命令所在目录，如果命令不存在，则返回一个error。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func main() { path, err := exec.LookPath(\u0026#34;ls\u0026#34;) if err != nil { fmt.Printf(\u0026#34;no cmd ls: %v\\n\u0026#34;, err) } else { fmt.Printf(\u0026#34;find ls in path:%s\\n\u0026#34;, path) } path, err = exec.LookPath(\u0026#34;not-exist\u0026#34;) if err != nil { fmt.Printf(\u0026#34;no cmd not-exist: %v\\n\u0026#34;, err) } else { fmt.Printf(\u0026#34;find not-exist in path:%s\\n\u0026#34;, path) } } 运行：\n1 2 3 $ go run main.go find ls in path:C:\\Program Files\\Git\\usr\\bin\\ls.exe no cmd not-exist: exec: \u0026#34;not-exist\u0026#34;: executable file not found in %PATH% # 封装 执行外部命令的流程比较固定：\n调用exec.Command()创建命令对象； 调用Cmd.Run()执行命令 可以自己封装成一个工具包。\n# 总结 本文介绍了使用os/exec这个标准库调用外部命令的各种姿势。\n# 参考 Advanced command execution in go with os/exec: https://blog.kowalczyk.info/article/wOYk/advanced-command-execution-in-go-with-osexec.html Go中调用外部命令的几种姿势搬运自该篇文章。 ","date":"2024-04-24T23:41:31+08:00","permalink":"https://arlettebrook.github.io/p/go%E8%B0%83%E7%94%A8%E5%A4%96%E9%83%A8%E5%91%BD%E4%BB%A4os/exec%E5%BA%93%E4%BB%8B%E7%BB%8D/","title":"Go调用外部命令os/exec库介绍"},{"content":" # 简介 今天我们来看一个很小，很实用的库go-homedir。顾名思义，go-homedir用来获取用户的主目录。 实际上，使用标准库os/user或者os.UserHomeDir()我们也可以得到这个信息：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os/user\u0026#34; ) func main() { u, err := user.Current() if err != nil { log.Fatal(err) } fmt.Println(\u0026#34;Home dir:\u0026#34;, u.HomeDir) } 那么为什么还要go-homedir库？\n在 Darwin 系统上，标准库os/user的使用需要 cgo。所以，任何使用os/user的代码都不能交叉编译。 但是，大多数人使用os/user的目的仅仅只是想获取主目录。因此，go-homedir库出现了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func UserHomeDir() (string, error) { env, enverr := \u0026#34;HOME\u0026#34;, \u0026#34;$HOME\u0026#34; switch runtime.GOOS { case \u0026#34;windows\u0026#34;: env, enverr = \u0026#34;USERPROFILE\u0026#34;, \u0026#34;%userprofile%\u0026#34; case \u0026#34;plan9\u0026#34;: env, enverr = \u0026#34;home\u0026#34;, \u0026#34;$home\u0026#34; } if v := Getenv(env); v != \u0026#34;\u0026#34; { return v, nil } // On some geese the home directory is not always defined. switch runtime.GOOS { case \u0026#34;android\u0026#34;: return \u0026#34;/sdcard\u0026#34;, nil case \u0026#34;ios\u0026#34;: return \u0026#34;/\u0026#34;, nil } return \u0026#34;\u0026#34;, errors.New(enverr + \u0026#34; is not defined\u0026#34;) } 还有就是官方的库也只是从环境变量中获取用户的家目录，没有考虑$HOME不存在的情况。\n# 快速使用 go-homedir是第三方包，使用前需要先安装：\n1 $ go get -u github.com/mitchellh/go-homedir 使用非常简单：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;github.com/mitchellh/go-homedir\u0026#34; ) func main() { dir, err := homedir.Dir() if err != nil { log.Fatal(err) } fmt.Println(\u0026#34;Home dir:\u0026#34;, dir) dir = \u0026#34;~/golang/src\u0026#34; expandedDir, err := homedir.Expand(dir) if err != nil { log.Fatal(err) } fmt.Printf(\u0026#34;Expand of %s is: %s\\n\u0026#34;, dir, expandedDir) } go-homedir有两个功能：\nDir：获取用户主目录； Expand：将路径中的第一个~扩展成用户主目录。 # 高级用法 由于Dir的调用可能涉及一些系统调用和外部执行命令，多次调用费性能。所以go-homedir提供了缓存的功能。默认情况下，缓存是开启的。 我们也可以将DisableCache设置为true来关闭它。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;github.com/mitchellh/go-homedir\u0026#34; ) func main() { homedir.DisableCache = true # 关闭了缓存 dir, err := homedir.Dir() if err != nil { log.Fatal(err) } fmt.Println(\u0026#34;Home dir:\u0026#34;, dir) } 使用缓存时，如果程序运行中修改了主目录，再次调用Dir还是返回之前的目录。如果需要获取最新的主目录，可以先调用Reset清除缓存。\n# 实现 go-homedir源码只有一个文件homedir.go，今天我们大概看一下Dir的实现，去掉缓存相关代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func Dir() (string, error) { var result string var err error if runtime.GOOS == \u0026#34;windows\u0026#34; { result, err = dirWindows() } else { // Unix-like system, so just assume Unix result, err = dirUnix() } if err != nil { return \u0026#34;\u0026#34;, err } return result, nil } 判断当前的系统是windows还是类 Unix，分别调用不同的方法。先看 windows 的，比较简单：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func dirWindows() (string, error) { // First prefer the HOME environmental variable if home := os.Getenv(\u0026#34;HOME\u0026#34;); home != \u0026#34;\u0026#34; { return home, nil } // Prefer standard environment variable USERPROFILE if home := os.Getenv(\u0026#34;USERPROFILE\u0026#34;); home != \u0026#34;\u0026#34; { return home, nil } drive := os.Getenv(\u0026#34;HOMEDRIVE\u0026#34;) path := os.Getenv(\u0026#34;HOMEPATH\u0026#34;) home := drive + path if drive == \u0026#34;\u0026#34; || path == \u0026#34;\u0026#34; { return \u0026#34;\u0026#34;, errors.New(\u0026#34;HOMEDRIVE, HOMEPATH, or USERPROFILE are blank\u0026#34;) } return home, nil } 流程如下：\n读取环境变量HOME，如果不为空，返回这个值； 读取环境变量USERPROFILE，如果不为空，返回这个值； 读取环境变量HOMEDRIVE和HOMEPATH，如果两者都不为空，拼接这两个值返回。 类 Unix 系统的实现稍微复杂一点：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 func dirUnix() (string, error) { homeEnv := \u0026#34;HOME\u0026#34; if runtime.GOOS == \u0026#34;plan9\u0026#34; { // On plan9, env vars are lowercase. homeEnv = \u0026#34;home\u0026#34; } // First prefer the HOME environmental variable if home := os.Getenv(homeEnv); home != \u0026#34;\u0026#34; { return home, nil } var stdout bytes.Buffer // If that fails, try OS specific commands if runtime.GOOS == \u0026#34;darwin\u0026#34; { cmd := exec.Command(\u0026#34;sh\u0026#34;, \u0026#34;-c\u0026#34;, `dscl -q . -read /Users/\u0026#34;$(whoami)\u0026#34; NFSHomeDirectory | sed \u0026#39;s/^[^ ]*: //\u0026#39;`) cmd.Stdout = \u0026amp;stdout if err := cmd.Run(); err == nil { result := strings.TrimSpace(stdout.String()) if result != \u0026#34;\u0026#34; { return result, nil } } } else { cmd := exec.Command(\u0026#34;getent\u0026#34;, \u0026#34;passwd\u0026#34;, strconv.Itoa(os.Getuid())) cmd.Stdout = \u0026amp;stdout if err := cmd.Run(); err != nil { // If the error is ErrNotFound, we ignore it. Otherwise, return it. if err != exec.ErrNotFound { return \u0026#34;\u0026#34;, err } } else { if passwd := strings.TrimSpace(stdout.String()); passwd != \u0026#34;\u0026#34; { // username:password:uid:gid:gecos:home:shell passwdParts := strings.SplitN(passwd, \u0026#34;:\u0026#34;, 7) if len(passwdParts) \u0026gt; 5 { return passwdParts[5], nil } } } } // If all else fails, try the shell stdout.Reset() cmd := exec.Command(\u0026#34;sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;cd \u0026amp;\u0026amp; pwd\u0026#34;) cmd.Stdout = \u0026amp;stdout if err := cmd.Run(); err != nil { return \u0026#34;\u0026#34;, err } result := strings.TrimSpace(stdout.String()) if result == \u0026#34;\u0026#34; { return \u0026#34;\u0026#34;, errors.New(\u0026#34;blank output when reading home directory\u0026#34;) } return result, nil } 流程如下：\n先读取环境变量HOME（注意 plan9 系统上为home），如果不为空，返回这个值； 使用getnet命令查看系统的数据库中的相关记录，我们知道passwd文件中存储了用户信息，包括用户的主目录。使用getent命令查看passwd中当前用户的那条记录，然后从中找到主目录部分返回； 如果上一个步骤失败了，我们知道cd后不加参数是直接切换到用户主目录的，而pwd可以显示当前目录。那么就可以结合这两个命令返回主目录。 这里分析源码并不是表示使用任何库都要熟悉它的源码，毕竟使用库就是为了方便开发。 但是源码是我们学习和提高的一个非常重要的途径。我们在使用库遇到问题的时候也要有能力从文档或甚至源码中查找原因。\n# 参考 home-dir GitHub 仓库 Go 每日一库之 go-homedir ","date":"2024-04-24T22:47:45+08:00","permalink":"https://arlettebrook.github.io/p/go-homedir%E5%BA%93%E4%BB%8B%E7%BB%8D/","title":"Go-homedir库介绍"},{"content":" 注意：要学会使用-h \u0026ndash;help选项，查看命令，看不懂在查阅。git help \u0026lt;command\u0026gt;可进入官方文档。Git入门参考。以下常用命令个人收集总结。\n# git简单命令 # git init git init \u0026lt;directory\u0026gt;在指定的⽬录下创建⼀个空的git repo。不带参数将在当前⽬录下创建⼀个git repo。 # git clone git clone \u0026lt;repo\u0026gt;克隆⼀个指定repo到本地。指定的repo可以是本地⽂件系统或者由HTTP或SSH指定的远程路径。 git clone -b \u0026lt;branch\u0026gt; \u0026lt;repo\u0026gt;克隆指定仓库的分支 git clone --recursive \u0026lt;repo\u0026gt;递归地克隆，克隆带有子模块的仓库 git clone --recurse-submodules \u0026lt;repository_url\u0026gt;同理 可组合使用 # git add git add \u0026lt;directory\u0026gt;将指定⽬录的所有修改加⼊到下⼀次 commit中。把\u0026lt;directory\u0026gt;替换成\u0026lt;file\u0026gt;将添加指定⽂件的修改。 git add *、git add .、git add -A三条命令但是一样的，将所以修改提交到暂存区。 # git commit 这个命令通常带-m选项git commit -m \u0026quot;\u0026lt;message\u0026gt;\u0026quot;提交暂存区的修改，使⽤指定的 \u0026lt;message\u0026gt;作为提交信息，⽽不是打开⽂本编辑器输⼊提交信息。 git commit -m \u0026lt;message\u0026gt; --amend将当前staged修改合并到最近⼀次的commit中。 # git status git status显示哪些⽂件已被staged、以及未跟踪(untracked)。 # git reflog git reflog显示本地repo的所有commit⽇志。 与git log的区别 log项目的提交历史，reflog本地仓库的引用提交日志。 引用会保留所以的提交历史，如何重置的历史。主要目的是提供一个安全网，以便在误操作（如错误的 git reset）后可以恢复丢失的提交或分支。 git log 的输出是永久性的，而 reflog 会在一段时间后自动过期（默认是 30 天），以节省空间。 # git rm git rm fileName删除指定的文件。 与rm fileName的区别。 git rm不能删除未跟踪的文件， git rm删除之后直接到暂存区，而rm是到工作区 注意删除之后都需要提交操作。 撤销操作不用记，git都会有提示 # git switch 该命令适用于特定git版本。\ngit switch \u0026lt;branch\u0026gt;切换到指定分支，\ngit checkout \u0026lt;branch\u0026gt;同理，但这个都适用。 git switch -c \u0026lt;branch\u0026gt;创建并切换指定分支\n# git branch git branch显示本地repo的所有分⽀。\n-v显示详细信息 带*的为当前分支 git branch -r显示远程仓库的所以分支。\n可以使用git checkout \u0026lt;branch\u0026gt;检出远程分支，可以省略origin/。 git branch -a显示本地和远程的所有分支\ngit branch -m \u0026lt;old_branch_name\u0026gt; \u0026lt;new_branch_name\u0026gt;重命名分支\n新分支名已经存在， -M 强制重命名。 git branch \u0026lt;name\u0026gt;创建指定分支\ngit branch -D \u0026lt;branch\u0026gt;强制删除指定分支，无论是否合并到当前分支。\ngit branch -d \u0026lt;branch\u0026gt;删除指定的分支，如果没有合并到当前分支，git会阻止操作。\n# git merge git merge \u0026lt;branch\u0026gt;合并指定分支。将指定\u0026lt;branch\u0026gt;分⽀合并到当前分⽀。 是在当前分支合并指定分支。 合并分支可能会出现冲突。要解决冲突之后才能合并。 git merge --abort放弃本次合并 # git一般命令 # git revert git revert \u0026lt;commit\u0026gt; 对指定\u0026lt;commit\u0026gt;创建⼀个undo的commit，并应⽤到当前分⽀。就是撤销指定的提交并保留记录 效果：撤销指定的提交，回到了撤销提交的是上个版本，保留了撤销历史。会打开编辑器显示具体效果 一般不用 # git reset git reset \u0026lt;commit\u0026gt;重置到指定的提交，不会保留commit历史。工作区和暂存区会变成未跟踪。--hard选项完全重置到指定提交。未跟踪的重置不了。重置历史可以通过git reflog查看，利用这个可以重置已经重置的版本库。\n\u0026lt;commit\u0026gt;可以是： HEAD表示最新的提交或者这个版本库，HEAD^、HEAD~1上上次提交或者上个版本 或者使用commit_hash，提交的哈希值可以使用git log查看，只需要前几位就行。 git reset（重置到最新的提交）移除所有暂存区、工作区的修改，到未跟踪。这些命令其实省略了HEAD\ngit reset --hard 重置到最新的提交，删除工作区和暂存区\ngit reset \u0026lt;file\u0026gt;将\u0026lt;file\u0026gt;从暂存区移除，但保持⼯作区不变。此操作不会修改⼯作区的任何⽂件。\n# git restore git restore \u0026lt;file\u0026gt;...撤销对工作区的修改，是对以跟踪的文件当未添加到暂存区的文件。多个文件用空格分开。 git checkout -- \u0026lt;file\u0026gt;...同理，--可以省略 git restore --staged \u0026lt;file\u0026gt;...撤销对暂存区的修改到未跟踪。针对添加到暂存区的文件。 git reset HEAD \u0026lt;file\u0026gt;...同理，HEAD可以省略。 具体用哪一个，git都会有提示，不用记。 # git checkout git checkout \u0026lt;branch\u0026gt;切换到指定的分支\n如果分支为远程分支，则检出远程分支 git checkout -b \u0026lt;new-branch\u0026gt;切换并创建指定的分支\ngit checkout \u0026lt;file\u0026gt;撤销工作区的修改\ngit restore \u0026lt;file\u0026gt;同理 git checkout \u0026lt;commit\u0026gt;根据指定的提交创建一个分支,处于游离态。一般不用。\ngit checkout -b \u0026lt;local_branch_name\u0026gt; origin/\u0026lt;remote_branch_name\u0026gt;切换到远程分支\ngit checkout \u0026lt;branch\u0026gt;差不多，可以使用git fetch origin获取仓库所以信息，在检出分支。 git checkout -切换到前一个分支。\n# git remote 用来管理远程仓库列表，origin为远程仓库的默认别名。这些远端仓库的信息都被保存在./git/config 文件中。\ngit remote列出所有已配置的远程仓库的信息。\n-v显示详细信息 git remote add \u0026lt;remote_name\u0026gt; \u0026lt;remote_url\u0026gt;添加远程仓库\n添加⼀个新的远程连接。添加后可使⽤ \u0026lt;name\u0026gt;作为指定\u0026lt;url\u0026gt;远程连接的名称。 只有配置了这个才能推送到远程仓库。 git remote rename \u0026lt;old_name\u0026gt; \u0026lt;new_name\u0026gt;重命名远程仓库。 git remote set-url \u0026lt;remote_name\u0026gt; \u0026lt;new_url\u0026gt;修改远程仓库的url。 git remote remove \u0026lt;remote_name\u0026gt;或git remote rm \u0026lt;remote_name\u0026gt;删除远程仓库。 git remote show \u0026lt;remote_name\u0026gt;显示远程仓库的详细信息，包括 URL、跟踪的分支等。\n补充如何创建远程仓库\n创建远程仓库可以先在github上创建好，然后在本地pull下来，在进行修改后push上去。\n可以建一个空白仓库，在本地push上去，但需要进行绑定。\n1 2 3 git remote add origin https://github.com/username/null-project.git git branch -M main git push -u origin main # gjit push 将本地仓库推送到远程仓库\ngit push \u0026lt;remote_repository\u0026gt; \u0026lt;本地分支名\u0026gt;:\u0026lt;远程分支名\u0026gt;推送本地分支到指定的远程分支。如果远程分支不存在，会自动创建。:前后不能有空格。\n当分支同名，可以简写成git push \u0026lt;remote_repository\u0026gt; \u0026lt;本地分支名\u0026gt; 果无法提交的话执行，-f、--force选项强制推送，一般不用。 git push -u \u0026lt;remote_repository\u0026gt; \u0026lt;本地分支名\u0026gt;设置默认推送分支。\n作用：这样设置以后，推送到远程仓库可以简写成git push git push 代替 git push origin master -u是--set-upstream的短形式。 git push \u0026lt;remote_repository\u0026gt; -d \u0026lt;远程分支名\u0026gt;删除远程分支 。\n--delete长选项。 git push origin :test同理，没有写本地分支，就是删除远程分支。 git push \u0026lt;remote\u0026gt; \u0026lt;tagname\u0026gt;推送指定标签到指定远程仓库，一般为`origin``\n``git push \u0026ndash;tags`推送所用标签到远程\n# git pull git pull \u0026lt;remote_repository\u0026gt; \u0026lt;远程分支名\u0026gt;:\u0026lt;本地分支名\u0026gt;从远程仓库拉取最新代码到本地仓库。 git pull会拉取并合并，出现冲突要解决之后才能合并。 git fetch获取当前远程仓库的最新信息，不会合并。 通常可以简写成git pull,远程仓库默认是origin，分支默认是当前分支。 git pull --rebase\u0026lt;remote\u0026gt; 抓取远程分⽀，并以rebase模式并⼊本地repo⽽不是merge。 # git fetch git fetch origin获取远程仓库最新的更改。不会合并。默认仓库是origin，分支是当前分支，这里可以省略origin git fetch origin \u0026lt;branch\u0026gt;获取特定分支的更改. git fetch --all获取所用仓库远程仓库的最新更改。 与git pull的区别 都会获取远程仓库最新的更改。 但是fetch不会合并，而pull会合并。可以理解为git pull 是 git fetch 和 git merge 的组合 获取最新更改之后可以： git checkout \u0026lt;branch\u0026gt;检出指定分支，如果加origin要这样git checkout -b \u0026lt;branch\u0026gt; origin/\u0026lt;branch\u0026gt; git merge origin/master合并远程 master 分支的更改到当前的分支 git rebase origin/master使用 rebase 来整合更改（这可能会改变提交历史） # git stash git stash保存工作区、暂存区，可以切换分支去完成别的任务。不保存修改，未提交的修改会错乱到别的分支。并且只能保存已追踪的文件。 git stash list查看保存的工作区以及暂存区。 git stash apply恢复保存的工作区以及暂存区。 这个命令执行之后不会删除存储的工作区以及暂存区。 要用git stash drop才能删除。 git stash pop恢复并删除保存的工作区以及暂存区。 默认都是保存、恢复第一个stash即stash@{0}。若要指定第几个在后面加stash@{num}。 如恢复第二个stash：git stash pop stash@{1} 每个分支共用一个stash。 # git tag 作用：用于标记项目的版本发布或重要的里程碑。 分类 git tag \u0026lt;tagname\u0026gt; \u0026lt;commit ID\u0026gt;轻量标签 git tag vn.n.n打标签，n.n.n表示对应的版本号，版本号前面一般加v，遵循一定的命名规范，如v1.0.1。 默认是打在最新的一次提交。 后面跟提交的哈希值可以指定给那次提交打标签。如git tag v0.9.0 f52c633。 哈希值可以通过git log查看 git tag -a \u0026lt;tagname\u0026gt; -m \u0026quot;\u0026lt;tag message\u0026gt;\u0026quot; \u0026lt;commit ID\u0026gt;附注标签 如git tag -a v0.1 -m \u0026quot;version 0.1 released\u0026quot; 1094adb 推荐id省略默认最新提交。 查看标签 git tag显示所有的本地tag列表，按照字母顺序排序。如果tag数量较多，可能会显示不全。省略选项-l、--list git show \u0026lt;tagname\u0026gt;显示指定tag的详细信息，包括提交的作者、提交时间、提交信息等。 git tag -n：显示tag列表，并同时显示每个tag对应的提交信息。 git ls-remote --tags origin：显示远程仓库中的所有tag信息。更推荐这种。 或者先git fetch获取最新的更改，然后git tag检出所有标签。 删除标签 git tag -d \u0026lt;tagname\u0026gt;删除本地标签 删除远程标签：首先需要在本地删除标签，然后推送到远程仓库 git push origin :refs/tags/\u0026lt;tagname\u0026gt; 远程标签是refs/tags/v0.0.1这样存在的，跟删除远程分支差不多。 标签一旦创建，就不能直接修改,如果需要修改标签，通常需要删除原标签，并重新创建一个新标签。 推送标签 打的标签不会自动推送到远程仓库，需要手动推送。 git push \u0026lt;remote\u0026gt; \u0026lt;tagname\u0026gt;推送指定标签到指定远程仓库，一般为origin git push \u0026lt;remote\u0026gt; --tags推送所用标签到远程 # git复杂命令 # git log git log以缺省格式显示全部commit历史。更多⾃定义参数请参考后续部分。q退出，空格下一页，h查看帮助 git log --stat：显示详细的commit历史。 git log -\u0026lt;limit\u0026gt;限制log的显示数量。例如：”git log -5”仅显示最新5条commit。 git log --oneline每⾏显示⼀条commit，简化信息。与--pretty=oneline等效 git log --author= \u0026quot;\u0026lt;pattern\u0026gt;\u0026quot;按提交者名字搜索并显示commit。 git log --grep= \u0026quot;\u0026lt;pattern\u0026gt;\u0026quot;按指定内容搜索并显示commit。 git log \u0026lt;since\u0026gt;..\u0026lt;until\u0026gt;显示指定范围的commit。范围参数可以是commit ID、分⽀名称、HEAD或任意相对位置。 git log -- \u0026lt;file\u0026gt;仅显示包含指定⽂件修改的commit。 git log --graph使⽤\u0026ndash;graph参数显示图形化的branch信息。 # git diff git diff⽐较⼯作区和暂存区的修改。 git diff HEAD⽐较⼯作区和上⼀次commit后的修改。 HEAD指向当前分支最新的commit版本库 git diff --cached⽐较暂存区和上⼀次commit后的修改。 git diff --stashed查看暂存区与最新提交的差异，与上面一样 git diff \u0026lt;commit1\u0026gt; \u0026lt;commit2\u0026gt;查看两个提交之间的差异。 git diff \u0026lt;filename\u0026gt;后面指定文件，只查看该文件的修改情况，没有参数查询全部 用git diff HEAD -- readme.txt命令可以查看版本库和工作区里面最新版本的区别 # git config 作用：通过git config命令配置git的配置文件\ngit配置文件级别分为：\n仓库级别 --local 【优先级最高】。文件所在位置仓库下的.git/config 当前用户级别 --global【优先级次之】一般配置它。文件所在位置用户家目录下的.gitconfig 系统所有用户级别 --system【优先级最低】。文件所在位置git安装目录下的 ./etc/gitconfig -l、--list查看配置。常用\ngit config -l查看所有的配置信息，依次是系统级别、用户级别、仓库级别 git config --local -l 查看仓库级别配置。必须要进入到具体的目录下。 git config --global -l 查看当前用户配置 git config --system -l 查看系统所有用户配置 可以与--show-origin 显示文件位置，--show-scope显示文件级别组合使用 -e、--edit打开编辑器编辑指定级别的配置文件，没有指定默认仓库级别，会使用默认编辑器打开编辑。安装的时候设置的。\n添加配置、修改配置：直接配置对应的配置参数就行。一般配置用户级别就行。省略了--add选项。没有指定级别，默认仓库基本。常用的添加配置命令:\n用户邮箱和用户名。安装git之后必设置的配置\ngit config --global user.email \u0026quot;Your mail\u0026quot;\ngit config --global user.name \u0026quot;Your name\u0026quot;\n如果我们没有配置，在提交代码时会有如下错误：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 xxx@DESKTOP-MD21325 MINGW64 /d/test/test (master) $ git commit -m \u0026#34;feature: add readme\u0026#34; Author identity unknown *** Please tell me who you are. Run git config --global user.email \u0026#34;you@example.com\u0026#34; git config --global user.name \u0026#34;Your Name\u0026#34; to set your account\u0026#39;s default identity. Omit --global to set the identity only in this repository. fatal: unable to auto-detect email address (got \u0026#39;xxx@DESKTOP-MD21325.(none)\u0026#39;) 设置自己的代理。网速慢必设置的配置\ngit config --global http.proxy \u0026quot;http://proxy_ip:port\u0026quot;\ngit config --global https.proxy \u0026quot;https://proxy_ip:port\u0026quot;\n--unset取消配置，注意要指定取消的配置级别。常用取消配置命令：\n取消代理配置\ngit config --global --unset http.proxy\ngit config --global --unset https.proxy\n--get查看指定级别、指定配置项的配置，默认仓库级别。如：\n查看代理配置\ngit config --global --get http.proxy\ngit config --global --get https.proxy\ngit config --global alias.\u0026lt;alias-name\u0026gt; \u0026lt;git-command\u0026gt;配置⼀个git命令的快捷⽅式。例如：配置”alias.glog log \u0026ndash;graph \u0026ndash;oneline”使”git glog”相当于”git log \u0026ndash;graph \u0026ndash;oneline”.\ngit config --global core.editor \u0026lt;editor\u0026gt;配置⽂本编辑器，例如vi，在必要时⾃动打开此⽂本编辑器。安装的时候也可以指定默认编辑器。\n# git submodule git submodule init初始化子模块，将子模块的配置信息存储在父仓库中。\n通常执行之后再执行更新子模块使用，如克隆带有子模块的仓库，没有加--recursive，是不会克隆子模块的 初始化子模块之后，执行更新子模块就会根据配置信息下载子模块 git submodule update根据父仓库子模块的配置信息更新子模块，如果没有初始化子模块可以加参数--init，会下载与父项目绑定版本的子模块，若要更新加--remote\n--init初识化子模块 --recursive会递归下载子模块的子模块 --remote根据子模块远程仓库的配置信息更新子模块，会下载最新版本的子模块 注意更新之后要提交更新的版本，否则当在执行更新命令没有加--remote时会退回与父仓库绑定的版本 git submodule add \u0026lt;repository\u0026gt; \u0026lt;path\u0026gt;添加子模块。其中，\u0026lt;repository\u0026gt;是子模块的远程仓库地址，\u0026lt;path\u0026gt;是子模块在主项目中的路径。\n子模块可以当正常仓库使用。创建时\u0026lt;path\u0026gt;路径不能存在文件，更克隆差不多。 # git subtree 作用：将一个仓库中的目录作为另一个仓库，可以指定分支 用途：搭建项目网站时，将项目网站资源推送到gh-pages分支上 git subtree push --prefix=dist origin gh-pages将目录添加到gh-pages分支上，dist为项目网站的目录 git subtree push --prefix=\u0026lt;prefix\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;branch\u0026gt;将子目录的内容推送到远程仓库。它会将当前仓库中子目录的修改推送到指定的远程仓库和分支中。 注意：以这种推送的方式添加的subtree不能执行subtree pull命令，只有通过subtree add添加的才能都执行，但能够执行subtree push命令 git subtree pull --prefix=\u0026lt;prefix\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;branch\u0026gt;这个命令用于从远程仓库更新子目录的内容。它会拉取远程仓库的最新代码，并更新到当前仓库的子目录中。 git subtree add --prefix=\u0026lt;prefix\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;branch\u0026gt;这个命令用于将远程仓库的内容作为子目录添加到当前仓库中。\u0026lt;prefix\u0026gt;是子目录的名称，\u0026lt;repository\u0026gt;是远程仓库的地址，\u0026lt;branch\u0026gt;是要合并的分支。 # git rebase 作用：rebase翻译成变基，顾名思义：改变基准点。可以使提交历史更加清晰和线性。\n原因：通过合并两个不同的分支，提交历史会很错乱。而通过变基，会使得提交历史更加整洁和可读。\n如何实现：就是修改创建分支的起点（基准点），到最新的提交。起点变了，提交历史就简化了。\n命令：\ngit rebase \u0026lt;base\u0026gt;基于\u0026lt;base\u0026gt;对当前分⽀进⾏rebase。\u0026lt;base\u0026gt;可以是commit、分⽀名称、tag或相对于HEAD的commit。 git rebase -i \u0026lt;base\u0026gt;以交互模式对当前分⽀做rebase。 rebase的过程中可能会出现冲突，解决冲突之后需要使用git add命令将解决冲突后的文件标记为已解决，然后，使用git rebase --continue命令继续rebase过程。Git会尝试继续应用剩余的提交。如果再次出现冲突，你需要重复上述解决冲突和继续rebase的步骤。 如果在rebase过程中出现了问题，或者你决定放弃rebase操作，你可以使用git rebase --abort命令来撤销整个rebase操作。 git rebase的注意事项\n避免对已经推送到远程仓库的提交执行rebase操作：这可能会导致提交历史的不一致，给其他协作者带来困扰。 保持工作目录干净：在执行rebase之前，确保你的工作目录中没有未提交的更改。 谨慎使用：由于rebase会改变提交历史，因此在与他人共享分支时要特别小心。通常，在公共分支上应该使用merge而不是rebase。 通过掌握git rebase的用法和注意事项，你可以更有效地管理你的Git仓库，保持代码的清晰和整洁。\n​\n# 扩展 # .gitignore文件 Git提供了.gitignore文件，用于指定哪些文件或目录应该被Git忽略，不纳入版本控制系统中。.gitignore文件是一个文本文件，可以包含一些简单的规则，指定应该忽略哪些文件或目录。以下是一些.gitignore文件的示例规则：\n忽略所有以.tmp结尾的文件：\n1 *.tmp 忽略所有的log文件：\n1 *.log 忽略所有的.idea目录：\n1 .idea/ 忽略所有的build目录及其内容：\n1 build/ 忽略根目录下的config.json文件，但不忽略子目录中的config.json文件：\n1 /config.json 忽略所有的node_modules目录及其内容：\n1 node_modules/ 忽略所有的DS_Store文件（Mac OS X系统中的文件）：\n1 .DS_Store 可以将这些规则写入.gitignore文件中，并将该文件添加到Git仓库中，以使Git忽略这些文件或目录。需要注意的是，即使某些文件或目录已经被添加到Git仓库中，也可以通过修改.gitignore文件来让Git忽略它们，但需要执行以下命令才能使.gitignore文件生效：\n1 2 3 4 git rm -r --cached . git add . git commit -m \u0026#34;update .gitignore\u0026#34; git push 这些命令会删除Git缓存中已经添加的文件，然后重新添加文件并提交更改，以使.gitignore文件生效。\n总结：\n当Git执行提交操作时，它会检查.gitignore文件中列出的文件和目录，并将它们从提交中排除。这是非常有用的，因为有些文件或目录不应该被纳入版本控制系统中，例如编译生成的文件、日志文件、临时文件等。\n.gitignore文件的语法是基于模式匹配的，其中的特殊字符有：\n*：匹配任意字符，但不包括路径分隔符（/）。 ?：匹配任意单个字符，但不包括路径分隔符（/）。 /：路径分隔符，用于指定目录。 !：用于否定模式，即不忽略指定的文件或目录。 可以在.gitignore文件中使用通配符、路径、注释等语法，以更精确地指定需要忽略的文件或目录。同时，可以在仓库的根目录下创建一个.gitignore文件，也可以在子目录中创建独立的.gitignore文件。\n# git账户认证 当我们对远程仓库就行修改时，需要对应的权限，不是什么人都能够修改仓库。只有通过了git账户认证，才能修改对应的仓库。 常见git账户认证的方式： SSH秘钥认证 这是Git中最常见的认证方式之一。用户首先生成一对公钥和私钥，然后将公钥添加到Git服务器上的用户帐户中。当用户尝试与Git服务器进行通信时，Git将使用私钥进行身份验证。这种方式相对安全，因为私钥是保存在用户本地机器上的，不会被传输到Git服务器。 秘钥生成命令：bash中运行ssh-keygen,一直回车就行，秘钥位置：主目录下的.ssh目录 公钥设置位置：github账户Settings-\u0026gt;SSH and GPG keys-\u0026gt;New SSH key将公钥复制粘贴保存就行。 HTTPS认证 在这种方式中，用户需要提供用户名和密码进行身份验证。用户需要在Git服务器上创建一个用户帐户，并将其关联到本地的Git仓库中。当用户执行需要身份验证的操作时，Git会要求输入用户名和密码。这种方式相对简单，适用于个人项目或小型团队。 设置位置：在使用Git进行操作时，如push或pull，系统会提示你输入用户名和密码进行身份验证。 访问令牌（Personal Access Token）认证：不常用 访问令牌提供了一种更安全、更灵活的身份验证方式，因为它可以限制令牌的使用权限，并且可以随时撤销或重新生成令牌。 设置位置：github账户Settings-\u0026gt;Developer Settings-\u0026gt;Personal access tokens-\u0026gt;Tokens (classic)-\u0026gt;Generate new token，然后根据自己的需求设置token的权限。 # ssh-keygen ssh-keygen命令是一个用于生成、管理和转换SSH认证密钥的工具。它支持RSA和DSA两种认证密钥类型，并且提供了多种选项和参数，以满足不同的需求。\n使用ssh-keygen命令，你可以生成新的密钥对，指定密钥的长度、类型以及保存的文件名。生成的私钥将保存在本地，而公钥则用于在SSH服务器上进行身份验证。\n以下是一些常用的ssh-keygen命令选项：\n-t：指定要创建的密钥类型，默认为RSA。 -b：指定密钥长度（以位为单位）。对于RSA密钥，最小要求是768位，默认是2048位。对于DSA密钥，长度必须是1024位（根据FIPS 1862标准规定）。 -f：指定用于保存密钥的文件名。如果不指定，将使用默认值id_rsa（对于私钥）和id_rsa.pub（对于公钥）。 -C：提供一个新注释，通常用于标识密钥的用途或所有者。 -P 和 -N：分别用于提供旧密码和新密码，以保护私钥文件。如果留空，则表示不需要密码。 在生成密钥对后，你可以将公钥复制到需要访问的SSH服务器上，通常是将公钥内容追加到服务器的~/.ssh/authorized_keys文件中。这样，当你使用SSH客户端连接到服务器时，客户端将使用私钥进行身份验证，如果验证成功，你将能够无需输入密码即可登录到服务器。\n请注意，私钥的安全性至关重要。私钥应该妥善保管，并且不应该与其他人共享。同时，定期更换密钥对也是保持安全性的好习惯。\n除了生成和管理密钥对，ssh-keygen还提供了其他功能，如转换密钥格式、读取密钥文件等。你可以通过查看ssh-keygen的帮助文档或手册页（通过运行man ssh-keygen命令）来获取更详细的信息和用法示例。\n","date":"2024-04-22T22:18:17+08:00","permalink":"https://arlettebrook.github.io/p/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","title":"Git常用命令"},{"content":" # 简介 flag用于解析命令行选项。有过类 Unix 系统使用经验的童鞋对命令行选项应该不陌生。例如命令ls -al列出当前目录下所有文件和目录的详细信息，其中-al就是命令行选项。\n命令行选项在实际开发中很常用，特别是在写工具的时候。\n指定配置文件的路径，如redis-server ./redis.conf以当前目录下的配置文件redis.conf启动 Redis 服务器； 自定义某些参数，如python -m SimpleHTTPServer 8080启动一个 HTTP 服务器，监听 8080 端口。如果不指定，则默认监听 8000 端口。 # 快速使用 学习一个库的第一步当然是使用它。我们先看看flag库的基本使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;flag\u0026#34; ) var ( intflag int boolflag bool stringflag string ) func init() { flag.IntVar(\u0026amp;intflag, \u0026#34;intflag\u0026#34;, 0, \u0026#34;int flag value\u0026#34;) flag.BoolVar(\u0026amp;boolflag, \u0026#34;boolflag\u0026#34;, false, \u0026#34;bool flag value\u0026#34;) flag.StringVar(\u0026amp;stringflag, \u0026#34;stringflag\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;string flag value\u0026#34;) } func main() { flag.Parse() fmt.Println(\u0026#34;int flag:\u0026#34;, intflag) fmt.Println(\u0026#34;bool flag:\u0026#34;, boolflag) fmt.Println(\u0026#34;string flag:\u0026#34;, stringflag) } 可以先编译程序，然后运行（我使用的是 Win10 + Git Bash）：\n1 2 $ go build -o main.exe main.go $ ./main.exe -intflag 12 -boolflag 1 -stringflag test 输出：\n1 2 3 int flag: 12 bool flag: true string flag: test 如果不设置某个选项，相应变量会取默认值：\n1 $ ./main.exe -intflag 12 -boolflag 1 输出：\n1 2 3 int flag: 12 bool flag: true string flag: default 可以看到没有设置的选项stringflag为默认值default。\n还可以直接使用go run，这个命令会先编译程序生成可执行文件，然后执行该文件，将命令行中的其它选项传给这个程序。\n1 go run main.go -intflag 12 -boolflag 1 可以使用-h显示选项帮助信息：\n1 2 3 4 5 6 7 8 $ ./main.exe -h Usage of D:\\code\\golang\\src\\github.com\\darjun\\cmd\\flag\\main.exe: -boolflag bool flag value -intflag int int flag value -stringflag string string flag value (default \u0026#34;default\u0026#34;) 总结一下，使用flag库的一般步骤：\n定义一些全局变量存储选项的值，如这里的intflag/boolflag/stringflag； 在init方法中使用flag.TypeVar方法定义选项，这里的Type可以为基本类型Int/Uint/Float64/Bool，还可以是时间间隔time.Duration。定义时传入变量的地址、选项名、默认值和帮助信息； 在main方法中调用flag.Parse从os.Args[1:]中解析选项。因为os.Args[0]为可执行程序路径，会被剔除。 注意点：\nflag.Parse方法必须在所有选项都定义之后调用，且flag.Parse调用之后不能再定义选项。如果按照前面的步骤，基本不会出现问题。 因为init在所有代码之前执行，将选项定义都放在init中，main函数中执行flag.Parse时所有选项都已经定义了。\n# 选项格式 flag库支持三种命令行选项格式。\n1 2 3 -flag -flag=x -flag x -和--都可以使用，它们的作用是一样的。有些库使用-表示短选项，--表示长选项。相对而言，flag使用起来更简单。\n第一种形式只支持布尔类型的选项，出现即为true，不出现为默认值。 第三种形式不支持布尔类型的选项。因为这种形式的布尔选项在类 Unix 系统中可能会出现意想不到的行为。看下面的命令：\n1 cmd -x * 其中，*是 shell 通配符。如果有名字为 0、false的文件，布尔选项-x将会取false。反之，布尔选项-x将会取true。而且这个选项消耗了一个参数。 如果要显示设置一个布尔选项为false，只能使用-flag=false这种形式。\n遇到第一个非选项参数（即不是以-和--开头的）或终止符--，解析停止。运行下面程序：\n1 $ ./main.exe noflag -intflag 12 将会输出：\n1 2 3 int flag: 0 bool flag: false string flag: default 因为解析遇到noflag就停止了，后面的选项-intflag没有被解析到。所以所有选项都取的默认值。\n运行下面的程序：\n1 $ ./main.exe -intflag 12 -- -boolflag=true 将会输出：\n1 2 3 int flag: 12 bool flag: false string flag: default 首先解析了选项intflag，设置其值为 12。遇到--后解析终止了，后面的--boolflag=true没有被解析到，所以boolflag选项取默认值false。\n解析终止之后如果还有命令行参数，flag库会存储下来，通过flag.Args方法返回这些参数的切片。 可以通过flag.NArg方法获取未解析的参数数量，flag.Arg(i)访问位置i（从 0 开始）上的参数。 选项个数也可以通过调用flag.NFlag方法获取。\n稍稍修改一下上面的程序：\n1 2 3 4 5 6 7 8 9 10 11 func main() { flag.Parse() fmt.Println(flag.Args()) fmt.Println(\u0026#34;Non-Flag Argument Count:\u0026#34;, flag.NArg()) for i := 0; i \u0026lt; flag.NArg(); i++ { fmt.Printf(\u0026#34;Argument %d: %s\\n\u0026#34;, i, flag.Arg(i)) } fmt.Println(\u0026#34;Flag Count:\u0026#34;, flag.NFlag()) } 编译运行该程序：\n1 2 $ go build -o main.exe main.go $ ./main.exe -intflag 12 -- -stringflag test 输出：\n1 2 3 4 [-stringflag test] Non-Flag Argument Count: 2 Argument 0: -stringflag Argument 1: test 解析遇到--终止后，剩余参数-stringflag test保存在flag中，可以通过Args/NArg/Arg等方法访问。\n整数选项值可以接受 1234（十进制）、0664（八进制）和 0x1234（十六进制）的形式，并且可以是负数。实际上flag在内部使用strconv.ParseInt方法将字符串解析成int。 所以理论上，ParseInt接受的格式都可以。\n布尔类型的选项值可以为：\n取值为true的：1、t、T、true、TRUE、True； 取值为false的：0、f、F、false、FALSE、False。 # 另一种定义选项的方式 上面我们介绍了使用flag.TypeVar定义选项，这种方式需要我们先定义变量，然后变量的地址。 还有一种方式，调用flag.Type（其中Type可以为Int/Uint/Bool/Float64/String/Duration等）会自动为我们分配变量，返回该变量的地址。用法与前一种方式类似：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;flag\u0026#34; ) var ( intflag *int boolflag *bool stringflag *string ) func init() { intflag = flag.Int(\u0026#34;intflag\u0026#34;, 0, \u0026#34;int flag value\u0026#34;) boolflag = flag.Bool(\u0026#34;boolflag\u0026#34;, false, \u0026#34;bool flag value\u0026#34;) stringflag = flag.String(\u0026#34;stringflag\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;string flag value\u0026#34;) } func main() { flag.Parse() fmt.Println(\u0026#34;int flag:\u0026#34;, *intflag) fmt.Println(\u0026#34;bool flag:\u0026#34;, *boolflag) fmt.Println(\u0026#34;string flag:\u0026#34;, *stringflag) } 编译并运行程序：\n1 2 $ go build -o main.exe main.go $ ./main.exe -intflag 12 将输出：\n1 2 3 int flag: 12 bool flag: false string flag: default 除了使用时需要解引用，其它与前一种方式基本相同。\n# 高级用法 # 定义短选项 flag库并没有显示支持短选项，但是可以通过给某个相同的变量设置不同的选项来实现。即两个选项共享同一个变量。 由于初始化顺序不确定，必须保证它们拥有相同的默认值。否则不传该选项时，行为是不确定的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;flag\u0026#34; ) var logLevel string func init() { const ( defaultLogLevel = \u0026#34;DEBUG\u0026#34; usage = \u0026#34;set log level value\u0026#34; ) flag.StringVar(\u0026amp;logLevel, \u0026#34;log_type\u0026#34;, defaultLogLevel, usage) flag.StringVar(\u0026amp;logLevel, \u0026#34;l\u0026#34;, defaultLogLevel, usage + \u0026#34;(shorthand)\u0026#34;) } func main() { flag.Parse() fmt.Println(\u0026#34;log level:\u0026#34;, logLevel) } 编译、运行程序：\n1 2 3 $ go build -o main.exe main.go $ ./main.exe -log_type WARNING $ ./main.exe -l WARNING 使用长、短选项均输出：\n1 log level: WARNING 不传入该选项，输出默认值：\n1 2 $ ./main.exe log level: DEBUG # 解析时间间隔 除了能使用基本类型作为选项，flag库还支持time.Duration类型，即时间间隔。时间间隔支持的格式非常之多，例如\u0026quot;300ms\u0026quot;、\u0026quot;-1.5h\u0026quot;、“2h45m\u0026quot;等等等等。 时间单位可以是 ns/us/ms/s/m/h/day 等。实际上flag内部会调用time.ParseDuration。具体支持的格式可以参见time（需fq）库的文档。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import ( \u0026#34;flag\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) var ( period time.Duration ) func init() { flag.DurationVar(\u0026amp;period, \u0026#34;period\u0026#34;, 1*time.Second, \u0026#34;sleep period\u0026#34;) } func main() { flag.Parse() fmt.Printf(\u0026#34;Sleeping for %v...\u0026#34;, period) time.Sleep(period) fmt.Println() } 根据传入的命令行选项period，程序睡眠相应的时间，默认 1 秒。编译、运行程序：\n1 2 3 4 5 6 $ go build -o main.exe main.go $ ./main.exe Sleeping for 1s... $ ./main.exe -period 1m30s Sleeping for 1m30s... # 自定义选项 除了使用flag库提供的选项类型，我们还可以自定义选项类型。我们分析一下标准库中提供的案例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 package main import ( \u0026#34;errors\u0026#34; \u0026#34;flag\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;time\u0026#34; ) type interval []time.Duration func (i *interval) String() string { return fmt.Sprint(*i) } func (i *interval) Set(value string) error { if len(*i) \u0026gt; 0 { return errors.New(\u0026#34;interval flag already set\u0026#34;) } for _, dt := range strings.Split(value, \u0026#34;,\u0026#34;) { duration, err := time.ParseDuration(dt) if err != nil { return err } *i = append(*i, duration) } return nil } var ( intervalFlag interval ) func init() { flag.Var(\u0026amp;intervalFlag, \u0026#34;deltaT\u0026#34;, \u0026#34;comma-seperated list of intervals to use between events\u0026#34;) } func main() { flag.Parse() fmt.Println(intervalFlag) } 首先定义一个新类型，这里定义类型interval。\n新类型必须实现flag.Value接口：\n1 2 3 4 5 // src/flag/flag.go type Value interface { String() string Set(string) error } 其中String方法格式化该类型的值，flag.Parse方法在执行时遇到自定义类型的选项会将选项值作为参数调用该类型变量的Set方法。 这里将以,分隔的时间间隔解析出来存入一个切片中。\n自定义类型选项的定义必须使用flag.Var方法。\n编译、执行程序：\n1 2 3 4 5 $ go build -o main.exe main.go $ ./main.exe -deltaT 30s [30s] $ ./main.exe -deltaT 30s,1m,1m30s [30s 1m0s 1m30s] 如果指定的选项值非法，Set方法返回一个error类型的值，Parse执行终止，打印错误和使用帮助。\n1 2 3 4 5 $ ./main.exe -deltaT 30x invalid value \u0026#34;30x\u0026#34; for flag -deltaT: time: unknown unit x in duration 30x Usage of D:\\code\\golang\\src\\github.com\\darjun\\go-daily-lib\\flag\\self-defined\\main.exe: -deltaT value comma-seperated list of intervals to use between events # 解析程序中的字符串 有时候选项并不是通过命令行传递的。例如，从配置表中读取或程序生成的。这时候可以使用flag.FlagSet结构的相关方法来解析这些选项。\n实际上，我们前面调用的flag库的方法，都会间接调用FlagSet结构的方法。flag库中定义了一个FlagSet类型的全局变量CommandLine专门用于解析命令行选项。 前面调用的flag库的方法只是为了提供便利，它们内部都是调用的CommandLine的相应方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // src/flag/flag.go var CommandLine = NewFlagSet(os.Args[0], ExitOnError) func Parse() { CommandLine.Parse(os.Args[1:]) } func IntVar(p *int, name string, value int, usage string) { CommandLine.Var(newIntValue(value, p), name, usage) } func Int(name string, value int, usage string) *int { return CommandLine.Int(name, value, usage) } func NFlag() int { return len(CommandLine.actual) } func Arg(i int) string { return CommandLine.Arg(i) } func NArg() int { return len(CommandLine.args) } 同样的，我们也可以自己创建FlagSet类型变量来解析选项。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package main import ( \u0026#34;flag\u0026#34; \u0026#34;fmt\u0026#34; ) func main() { args := []string{\u0026#34;-intflag\u0026#34;, \u0026#34;12\u0026#34;, \u0026#34;-stringflag\u0026#34;, \u0026#34;test\u0026#34;} var intflag int var boolflag bool var stringflag string fs := flag.NewFlagSet(\u0026#34;MyFlagSet\u0026#34;, flag.ContinueOnError) fs.IntVar(\u0026amp;intflag, \u0026#34;intflag\u0026#34;, 0, \u0026#34;int flag value\u0026#34;) fs.BoolVar(\u0026amp;boolflag, \u0026#34;boolflag\u0026#34;, false, \u0026#34;bool flag value\u0026#34;) fs.StringVar(\u0026amp;stringflag, \u0026#34;stringflag\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;string flag value\u0026#34;) fs.Parse(args) fmt.Println(\u0026#34;int flag:\u0026#34;, intflag) fmt.Println(\u0026#34;bool flag:\u0026#34;, boolflag) fmt.Println(\u0026#34;string flag:\u0026#34;, stringflag) } NewFlagSet方法有两个参数，第一个参数是程序名称，输出帮助或出错时会显示该信息。第二个参数是解析出错时如何处理，有几个选项：\nContinueOnError：发生错误后继续解析，CommandLine就是使用这个选项； ExitOnError：出错时调用os.Exit(2)退出程序； PanicOnError：出错时产生 panic。 随便看一眼flag库中的相关代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // src/flag/flag.go func (f *FlagSet) Parse(arguments []string) error { f.parsed = true f.args = arguments for { seen, err := f.parseOne() if seen { continue } if err == nil { break } switch f.errorHandling { case ContinueOnError: return err case ExitOnError: os.Exit(2) case PanicOnError: panic(err) } } return nil } 与直接使用flag库的方法有一点不同，FlagSet调用Parse方法时需要显示传入字符串切片作为参数。因为flag.Parse在内部调用了CommandLine.Parse(os.Args[1:])。 示例代码都放在GitHub上了。\n# 参考 flag库文档 Go 每日一库之 flag 深入探究 Go flag 标准库附源码分析 ","date":"2024-04-22T18:02:17+08:00","permalink":"https://arlettebrook.github.io/p/go-flag%E5%BA%93%E4%BB%8B%E7%BB%8D/","title":"Go flag库介绍"},{"content":" # 静态网页生成器 无论您需要搭建个人博客还是为您的项目创建文档，静态网页生成器（static site generator）都是一个不错的选择。无需服务器、数据库，只要你熟悉 Markdown，喜欢GitHub，使用生成器创建静态 HTML 文件，然后推送到 GitHub Pages 等免费服务即可。\n# 常见的静态网页生成器 Hugo是由Go语言实现的静态网站生成器。简单、易用、高效、易扩展、快速部署。 jekyll 是一个静态网页、博客生成器 vuepress是基于 Vue 的静态网页生成器 Hexo 是一个由Nodejs驱动的快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 参考：静态网页生成器\n# 快速使用Hugo搭建个人博客站点 # 安装Hugo 根据自己的操作系统，下载已经构建好的Hugo二进制文件官方地址\n官方推荐下载扩展版，支持的功能更多 解压之后，将hugo可执行文件加入到PATH环境变量中，即可使用\n1 2 3 hugo version # 查看版本，扩展版含这个extended标签 hugo -h # 显示帮助信息 hugo subcommand -h # 获取子命令的帮助信息 # 使用Hugo hugo需要配合git一起使用，并且官方推荐使用bash作为终端\n创建项目并安装主题hugo-theme-stack\n1 2 3 4 5 hugo new site quickstart # 创建目录结构 cd quickstart git init git submodule add https://github.com/CaiJimmy/hugo-theme-stack/ themes/hugo-theme-stack # 安装主题 添加内容并使用安装主题的默认配置\n使用安装主题的实例进行快速添加内容 只需要进入主题文件中的exampleSite中的content拷贝到quickstart根目录中 同理，在主题文件中的exampleSite中的hugo.yaml拷贝到quickstart根目录中，重命名为,并删除hugo.toml 最后运行\n1 2 hugo server # 本地启动一个http服务器，便于开发和测试站点，默认热更新 hugo server --navigateToChanged # 自动重定向：编辑内容时，浏览器会自动重定向到上次修改的页面 会使用到的命令\n1 2 3 4 5 6 7 8 9 10 11 hugo new content post/fist-post.md # 会在content目录下创建post/fist-post.md文件 # 执行完后，会在content/post目录自动生成一个MarkDown格式的first.md文件： +++ date = \u0026#34;2015-01-08T08:36:54-07:00\u0026#34; draft = true title = \u0026#34;Fist Post\u0026#34; +++ # draft 默认为true，构建网站时不会构建该文档 # 要构建草稿文档可以用-D或--buildDrafts选项启动服务 hugo server -D # title 默认为文件名首字母大写 构建命令\n进入项目目录，运行\n1 hugo hugo命令会构建生成静态文件，会将文件发布项目的public目录下\n要将站点发布到其他目录，请使用该标志--destination或在站点配置中设置publishDir\n注意：每次构建不会清空public目录，只会覆盖旧内容。\n这样做是为了防止，构建之后在public添加的文件被删除\n草稿、未来和过期内容\nHugo 允许在内容的前面设置draft、date、publishDate和expiryDate。默认情况下，Hugo 在以下情况下不会发布内容：\n其draft值为true\n是date在未来\n是publishDate在未来\n已经expiryDate过去了\n下面的行为可以取消\n1 2 3 hugo --buildDrafts # or -D hugo --buildExpired # or -E hugo --buildFuture # or -F 注意：当这样构建之后，需要手动删除不期望构建的文件，在推送站点\n否则当推送到远程会出现意外的内容\n所以建议运行上面的命令之后，前提public中没有手动添加的文件，在构建之前手动清空public目录，防止出现草稿、过期和未来的内容\n最后将public中的所以文件推送到静态网站托管平台即可\n也可以使用自动构建和部署 更多内容参考：\n使用hugo搭建个人博客站点 （1）带着Stack主题入坑Hugo （2）部署你的Hugo博客 （3）Stack主题的自定义 自定义主题添加了assets/scss、layouts/_default/、layouts/index.html,不用了删了就行 # 目录结构 archetypes目录包含新内容的模板\n目录下的default.md由标记（markdown）和内容格式\n内容格式：\u0026mdash;yaml\u0026mdash;、+++toml+++、{json}\n1 2 3 4 5 --- # +++/{ date: \u0026#39;{{ .Date }}\u0026#39; # yaml draft: true title: \u0026#39;{{ replace .File.ContentBaseName `-` ` ` | title }}\u0026#39; --- # +++/{ 当运行hugo new content post/my-first-post.md命令时会根据default.md创建内容文件\n1 2 3 4 5 --- date: \u0026#34;2023-08-24T11:49:46-07:00\u0026#34; draft: true title: My First Post --- 可以创建新内容的模版\n1 2 3 archetypes/ ├── default.md └── post.md 若运行hugo new content post/my-first-post.md查找模版的顺序 archetypes/post.md archetypes/default.md themes/my-theme/archetypes/post.md themes/my-theme/archetypes/default.md 如果这些都不存在，Hugo 将使用内置的默认原型 assets目录包含通常通过资产管道传递的全局资源，包括图像、CSS、Sass、JavaScript 和 TypeScript 等资源。\nconfig目录包含站点配置，可能分为多个子目录和文件。对于具有最少配置的项目或不需要在不同环境中表现不同的项目，hugo.toml在项目根目录中命名的单个配置文件就足够了\ncontent目录包含构成站点内容的标记文件（通常是 Markdown）和页面资源。\n对应stack主题： post存放发布的文章格式md page存放导航区域的md格式配置 不同的语言结尾用.en.md等表示 根据模版进行修改即可，根据自己的需求，没有的需要自己补充和修改文件内容 categories存放类别的md格式配置 data目录包含增强内容、配置、本地化和导航的数据文件（JSON、TOML、YAML 或 XML）。\ni18n目录包含多语言站点的翻译表。\ncontent目录包含将内容、数据和资源转换为完整网站的模板。\npublic目录包含运行hugo或hugo server命令时生成的已发布网站。 Hugo 根据需要重新创建该目录及其内容\nresources目录包含 Hugo 资产管道的缓存输出，这些输出是在运行hugo或hugo server命令时生成的。默认情况下，此缓存目录包括 CSS 和图像。 Hugo 根据需要重新创建该目录及其内容。\nstatic目录包含在您构建站点时将复制到公共目录的文件。例如：favicon.ico、robots.txt和 验证站点所有权的文件.与assets差不多\nthemes目录包含一个或多个主题，每个主题都位于其自己的子目录中。\n联合文件系统：\n这样理解：安装的主题里面同样有自己站点的目录结构，hugo构建时会将主题里面的文件挂载到站点，优先级是站点的高 # 配置文件 hugo支持三种配置文件hugo.tomal、hugo.yaml、hugo.json，喜欢用那个就用那个。\n每种文件格式的规范：TOML、YAML和JSON。\n配置文件可以有多个，可以放到config目录下，默认都是使用hugo开头的文件\n指定配置文件构建\n1 2 hugo server --config other.toml hugo --config a.toml,b.yaml,c.json # 可以指定多个，左边的优先级高 更多内容配置参考\n额外的一些关于配置文件的总结\n默认语言修改为zh-cn，意味着index.md表示中文，index.zh-cn.md也表示中文，此时的英文要用index.en.md表示 更多内容参考：\nHugo官方文档 Hugo中文文档 Hugo theme # 文章评论 使用Waline，其教程很完整。\n根据Waline教程从头完成到使用Vercel部署完成。\n最后在config.yaml中的waline的serverURL给上你的Vercel服务器地址。\n以及开启评论，最后waline还可以配置评论通知渠道。\n将cloudflare解析的域名绑定到vercel文档 概括：添加一条CNAME记录值为cname.vercel-dns.com，开启代理，将SSL/TLS修改为完全 将cloudflare解析的域名绑定到github-pages文档 概括：添加一条子域，类型CNAME记录值为username.github.io，开启代理，将SSL/TLS修改为完全,username为你的用户名 更多内容请查阅文档 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 comments: enabled: true provider: waline waline: serverURL: url lang: zh-cn pageview: true copyright: false emoji: - https://unpkg.com/@waline/emojis@1.0.1/weibo requiredMeta: - name - email locale: admin: 👻Hi! placeholder: 🎉留下你的脚印... # 搜索引擎优化（SEO） 本网站使用Hugo搭建，而且使用的stack主题支持自动生成基于Open Graph协议（OG协议）的标签，此处记录一下如何在Hugo搭建的网站中做搜索引擎优化（SEO）。\n目的：提升网站在搜索引擎中的排名\nOpen Graph（开放图谱）协议，简称OG协议，是Facebook在2010年公布的一项协议，用来标记网页内容。简单来讲，OG协议就是嵌在网页头部的一些标签，这些标签标记了网页的标题、描述等特征，使得网页成为一个“富媒体对象”，可以被其他社交网站引用。\n很多搜索引擎都支持OG协议，在网页中使用OG协议的标签，就更有利于提升我们的网页在搜索引擎中的排名。\nOG协议的标签在网页中通常表示为类似下面所示的格式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;meta property=\u0026#34;og:title\u0026#34; content=\u0026#34;The Rock\u0026#34; /\u0026gt; \u0026lt;meta property=\u0026#34;og:type\u0026#34; content=\u0026#34;video.movie\u0026#34; /\u0026gt; \u0026lt;meta property=\u0026#34;og:url\u0026#34; content=\u0026#34;https://www.imdb.com/title/tt0117500/\u0026#34; /\u0026gt; \u0026lt;meta property=\u0026#34;og:image\u0026#34; content=\u0026#34;https://ia.media-imdb.com/images/rock.jpg\u0026#34; /\u0026gt; \u0026lt;meta property=\u0026#39;og:url\u0026#39; content=\u0026#39;https://arlettebrook.github.io/search/\u0026#39;\u0026gt; \u0026lt;meta property=\u0026#39;og:site_name\u0026#39; content=\u0026#39;Arlettebrook\u0026amp;#39;s blog\u0026#39;\u0026gt; \u0026lt;meta property=\u0026#39;og:type\u0026#39; content=\u0026#39;article\u0026#39;\u0026gt;\u0026lt;meta property=\u0026#39;article:section\u0026#39; content=\u0026#39;P age\u0026#39; /\u0026gt; -\u0026lt;meta name=\u0026#34;twitter:title\u0026#34; content=\u0026#34;搜索\u0026#34;\u0026gt; +\u0026lt;meta name=\u0026#34;twitter:site\u0026#34; content=\u0026#34;@arlettebrook\u0026#34;\u0026gt; + \u0026lt;meta name=\u0026#34;twitter:creator\u0026#34; content=\u0026#34;@arlettebrook\u0026#34;\u0026gt;\u0026lt;meta name=\u0026#34;twitter:title\u0026#34; co ntent=\u0026#34;搜索\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;twitter:description\u0026#34; content=\u0026#34;\u0026#34;\u0026gt;\u0026lt;link rel=\u0026#34;alternate\u0026#34; type=\u0026#34;application/js on\u0026#34; href=\u0026#34;https://arlettebrook.github.io/search/index.json\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;shortcut icon\u0026#34; href=\u0026#34;/img/favicon.ico\u0026#34; /\u0026gt; stack主题提供了对OG协议的支持，只需要在网站根目录下的config/_default/params.en.yaml和config/_default/params.zh-cn.yaml配置文件中开启即可：\n1 2 3 4 5 6 7 opengraph: twitter: # Your Twitter username site: JinliCyou # Available values: summary, summary_large_image card: summary_large_image 这样，Hugo在生成和部署网站时就会在网页HTML文件中自动嵌入OG标签。\n参考：个人网站的建立过程（四）：网站的搜索引擎优化（SEO）\n# 额外的一些知识 gh-pages 是GitHub 所提供的一个服务，简单来讲就是可以让你不用花钱也可以部署一个静态网页作为展示用，因此对于前端工程师来讲就非常方便而且很实用，但是部署方式有很多。\ngh-pages是github-pages的缩写，可以用于个人博客和项目介绍的网站服务。\ngh-pages也是github特殊的分支，用来存放网站相关的一些资源，通常网站地址为username.github.io/仓库名\n项目名与username.github.io一样的话，可以省略仓库名，跟github个人资料页面一样，所以这个仓库是一个特殊的仓库，默认会自动开启gh-pages服务。别的需要手动。\n虽然gh-pages 是属于免费的服务，基本上只要你持有GitHub 帐号就可以使用，但是它基本上有几个重点可以稍微注意一下：\n只能放置纯静态网页，也就是说没有后端的网页，例如PHP、Node.js、Python 等等，只能是纯HTML、CSS、JavaScript 等等，因为它并没有运算能力。 gh-pages 是以储存库为单位，也就是说每个储存库都可以有一个gh-pages 分支，但是每个储存库只能有一个gh-pages 分支，因此如果你想要部署多个网页，那么你就需要建立多个储存库。 gh-pages 的容量是有限制的，每个储存库的容量是1GB，如果你的网页超过这个容量，那么就无法部署。 gh-pages 的流量为每月100GB gh-pages 每小时只能部署10 次，如果是使用自己写的GitHub Actions 就没有这个限制（毕竟要花钱）。 免费的ssh 凭证 预设的网域是https://\u0026lt;username\u0026gt;.github.io/\u0026lt;repository\u0026gt;，如果你想要使用自己的网域，那么你就需要花钱购买网域，并且设定DNS 最后要稍微注意一下gh-pages 虽然是免费提供的静态网页托管服务，但是它并不能拿来作为商业用途或是违法用途，否则你的帐号可能会被封锁\n简单说一下如何查看一个仓库是否启用gh-pages：进入项目settings-pages查看即可，有绿色钩就启动成功，没有需要指定分支和根目录，保存，稍等一会就行。\n# 用gh-pages分支展示自己的项目 我们只需要将网页资源上传至gh-pages分支即可\n搭建项目网站：将项目网站资源推送到gh-pages分支上,静态资源必须提交了才会成功\n1 git subtree push --prefix=dist origin gh-pages # dist为项目网站的目录 拉取指定分支\n1 2 3 4 5 6 7 8 git fetch origin # 获取origin仓库的信息 git checkout -b aaa origin/aaa # 创建并检出分支 # git clone之后也也可以检出分支 git checkout gh-page # 失败用上面办法 # 在git clone 的时候可以指定分支-b选项 git clone -b url 如果要项目中不含自己网站的源码，可以忽略public目录，将public目录创建为一个私有仓库的子目录，然后将子目录作为，项目的gh-pages分支。\n# 通过GitHub Actions自动部署gh-pages 简单介绍一下GitHub Actions:\nGitHub Actions是一个自动化工具。 可以实现自动化构建、测试、和部署项目。 定义自动化过程是通过编写workflows（工作流）实现的，格式是yaml。 推送部署的github-pages需要git账户认证，方式是SSH秘钥认证。\n所以需要设置ssh秘钥。\n生成秘钥：在bash中运行ssh-keygen,秘钥类型默认为rsa。可以给这个秘钥设置备注加-C选项，参数一般为拥有者邮箱，一直回车就行。秘钥保存位置：默认用户主目录下的.ssh。公钥就是id_rsa.pub\n建议将生成的这个秘钥对与本机认证的ssh秘钥对分开，保存到另外的一个地方。回车的时候修改位置就行。 设置公钥：\ngithub账户Settings-\u0026gt;SSH and GPG keys-\u0026gt;New SSH key将公钥复制粘贴保存就行。这种方式，只有有私钥，就能操作所有仓库，不推荐使用。 (自动构建之后)选择要推送的仓库Settings-\u0026gt;Deploy keys-\u0026gt;Add deploy key将公钥复制粘贴保存就行。title随意。注意勾选Allow write access。只针对该仓库有权限。推荐使用。 设置私钥：\n进入Actions所在的仓库Settings-\u0026gt;Secrets and variables-\u0026gt;Actions-\u0026gt;New repository secret。秘钥名称为ACTIONS_DEPLOY_KEY，值为私钥id_rsa的文件内容。最后保存就行。 添加workflows配置文件\n在构建仓库的根目录下创建.github/workflows目录，然后创建auto-deploy-gh-pages.yaml文件，内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 name: Deploy github pages on: push: branches: - main # main 更新触发 # Allows you to run this workflow manually from the Actions tab workflow_dispatch: jobs: auto-deploy-github-pages: runs-on: ubuntu-latest steps: - name: Checkout code uses: actions/checkout@v4 with: submodules: true # clone submodules fetch-depth: 0 # 克隆所有历史信息 - name: Setup Hugo uses: peaceiris/actions-hugo@v3 with: hugo-version: \u0026#34;0.125.4\u0026#34; # Hugo 版本 extended: true # hugo插件版 Stack主题 必须启用 - name: Cache resources # 缓存 resource 文件加快生成速度 uses: actions/cache@v4 with: path: resources # 检查照片文件变化 key: ${{ runner.os }}-hugocache-${{ hashFiles(\u0026#39;content/**/*\u0026#39;) }} restore-keys: ${{ runner.os }}-hugocache- - name: Build # 生成网页 删除无用 resource 文件 削减空行 run: hugo --minify --gc - name: Deploy # 部署到 GitHub Page uses: peaceiris/actions-gh-pages@v3 with: # 如果在同一个仓库下使用请使用 github_token 并注释 deploy_key # github_token: ${{ secrets.GITHUB_TOKEN }} deploy_key: ${{ secrets.ACTIONS_DEPLOY_KEY }} # 如果在同一个仓库请注释 external_repository: arlettebrook/arlettebrook.github.io # 你的 GitHub page 仓库 example/example.github.io publish_branch: main # 默认gh-pages # cname: blog.trojan123.top # 自定义域名 publish_dir: ./public user_name: \u0026#34;github-actions[bot]\u0026#34; user_email: \u0026#34;github-actions[bot]@users.noreply.github.com\u0026#34; # full_commit_message: ${{ github.event.head_commit.message }} # 不带提交哈希 # full_commit_message: Deploy from ${{ github.repository }}@${{ github.sha }} 🚀 commit_message: ${{ github.event.head_commit.message }}🚀 # 带提交哈希 # full_commit_message: Deploy from ${{ github.repository }}@${{ github.sha }}🚀 ${{ github.event.head_commit.message }} 注意你要将external_repository项里的arlettebrook/arlettebrook.github.io改为你要推送的仓库。cname为你绑定的自定义域名。\n忽略不必要的文件\n在构建项目根目录下创建.gitignore文件，内容如下：\n1 2 3 4 public resources assets/jsconfig.json .hugo_build.lock 最后将构建项目推送到远程就行，这样每次推送构建项目的main分支到远程，就会自动构建并推送到指定仓库。\n查看是否构建成功：进入构建项目的Actions选项里面即可查看。\n参考：（2）部署你的Hugo博客\n","date":"2024-04-22T16:12:26+08:00","image":"https://arlettebrook.github.io/p/%E5%9F%BA%E4%BA%8Ehugo%E5%92%8Cgh-pages%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99/hugo_hu45a5e3ad5e058da6a00650ed8fd40bea_15530_120x120_fill_q75_box_smart1.jpg","permalink":"https://arlettebrook.github.io/p/%E5%9F%BA%E4%BA%8Ehugo%E5%92%8Cgh-pages%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99/","title":"基于Hugo和gh-pages快速搭建静态网站"}]