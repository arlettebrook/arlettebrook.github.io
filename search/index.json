[{"content":" 单例模式是设计模式中最简单的一种模式，单例模式能够确保无论对象被实例化多少次，全局都只有一个实例存在。根据单例模式的特性，我们可以将其应用到全局唯一性配置、数据库连接对象、文件访问对象等。Go 语言有多种方式可以实现单例模式，我们今天就来一起学习下。\n#\r饿汉式\r饿汉式实现单例模式非常简单，直接看代码：\n1 2 3 4 5 6 7 8 9 package singleton type Singleton struct{} var instance = \u0026amp;Singleton{} func GetSingleton() *Singleton { return instance } singleton 包在被导入时会自动初始化 instance 实例，使用时通过调用 singleton.GetSingleton() 函数即可获得 Singleton 这个结构体的单例对象。\n由于单例对象是在包加载时立即被创建出来，所以也就有了这个形象的名称叫作饿汉式。与之对应的另一种实现方式叫作懒汉式，当实例被第一次使用时才会被创建。\n需要注意的是，尽管饿汉式实现单例模式如此简单，但大多数情况下仍不被推荐使用，因为如果单例实例化时初始化内容过多，可能造成程序加载用时较长。\n#\r懒汉式\r接下来我们再来看下如何通过懒汉式实现单例模式：\n1 2 3 4 5 6 7 8 9 10 11 12 package singleton type Singleton struct{} var instance *Singleton func GetSingleton() *Singleton { if instance == nil { instance = \u0026amp;Singleton{} } return instance } 相较于饿汉式的实现，我们把实例化 Singleton 结构体部分的代码移到了 GetSingleton() 函数内部。这样一来，就将对象实例化的步骤延迟到了 GetSingleton() 被第一次调用时。\n通过 instance == nil 的判断来实现单例并不十分可靠，当有多个 goroutine 同时调用 GetSingleton() 时无法保证并发安全。\n#\r支持并发的单例\r如果你用 Go 语言写过并发编程，那么应该可以很快想到解决懒汉式单例模式并发安全问题的方案：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package singleton import \u0026#34;sync\u0026#34; type Singleton struct{} var instance *Singleton var mu sync.Mutex func GetSingleton() *Singleton { mu.Lock() defer mu.Unlock() if instance == nil { instance = \u0026amp;Singleton{} } return instance } 我们对代码的主要修改就是在 GetSingleton() 函数最开始加了如下两行代码：\n1 2 mu.Lock() defer mu.Unlock() 通过加锁的机制，就可以保证这个实现单例模式的函数是并发安全的。\n不过这样也有些问题，因为用了锁机制，每次调用 GetSingleton() 时程序都会进行加锁、解锁的步骤，这样会导致程序性能的下降。\n#\r双重锁定\r加锁导致程序性能下降，但我们又不得不用锁来保证程序的并发安全，于是有人想出了双重锁定（Double-Check Locking）的方案：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package singleton import \u0026#34;sync\u0026#34; type Singleton struct{} var instance *Singleton var mu sync.Mutex func GetSingleton() *Singleton { if instance == nil { mu.Lock() defer mu.Unlock() if instance == nil { instance = \u0026amp;Singleton{} } } return instance } 可以看到，所谓的双重锁定实际上就是在程序加锁前又加了一层 instance == nil 判断，这样就兼顾了性能和安全两个方面。\n不过这段代码看起来有些奇怪，既然外层已经判断了 instance == nil，加锁后却又进行了第二次 instance == nil 判断。其实外层的 instance == nil 判断是为了提高程序的执行效率，因为如果 instance 已经存在，则无需进入 if 逻辑，程序直接返回 instance 即可。这样就免去了原来每次调用 GetSingleton() 都上锁的操作，将加锁的粒度更加精细化。而内层的 instance == nil 判断则是考虑了并发安全，在极端情况下，多个 goroutine 同时走到了加锁这一步，内层判断就起到作用了。\n#\rGopher 惯用方案\rgopher原意地鼠，在golang 的世界里解释为地道的go程序员。在其他语言的世界里也有PHPer，Pythonic的说法，反而Java是个例外。虽然也有Javaer之类的说法，但似乎并不被认可。而地道或者说道地，说的是gopher写的代码无不透露出go的独特气息，比如项目结构、命名方式、代码格式、编码风格、构建方式等等。用gopher的话说，用go编写代码就像是在画一幅中国山水画，成品美不胜收，心旷神怡。\n虽然我们通过双重锁定机制兼顾和性能和并发安全，但代码有些丑陋，不符合广大 Gopher 的期待。好在 Go 语言在 sync 包中提供了 Once 机制能够帮助我们写出更加优雅的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package singleton import \u0026#34;sync\u0026#34; type Singleton struct{} var instance *Singleton var once sync.Once func GetSingleton() *Singleton { once.Do(func() { instance = \u0026amp;Singleton{} }) return instance } Once 是一个结构体，在执行 Do 方法的内部通过 atomic 操作和加锁机制来保证并发安全，且 once.Do 能够保证多个 goroutine 同时执行时 \u0026amp;singleton{} 只被创建一次。\n其实 Once 并不神秘，其内部实现跟上面使用的双重锁定机制非常类似，只不过把 instance == nil 换成了 atomic 操作，感兴趣的同学可以查看下其对应源码。\n#\r总结\r以上就是 Go 语言中实现单例模式的几种常用套路，经过对比可以得出结论，最推荐的方式是使用 once.Do 来实现，sync.Once 包帮我们隐藏了部分细节，却可以让代码可读性得到很大提升。\n#\r参考\r不一样的go语言-gopher Go 常见设计模式之单例模式 ","date":"2024-04-25T18:00:25+08:00","permalink":"https://arlettebrook.github.io/p/go%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","title":"Go常见设计模式：单例模式"},{"content":" #\r引子\r在工作中，我时不时地会需要在Go中调用外部命令。前段时间我做了一个工具，在钉钉群中添加了一个机器人，@这个机器人可以让它执行一些写好的脚本程序完成指定的任务。机器人倒是不难，照着钉钉开发者文档添加好机器人，然后@这个机器人就会向一个你指定的服务器发送一个POST请求，请求中会附带文本消息。所以我要做的就是搭一个Web服务器，可以用go原生的net/http包，也可以用gin/fasthttp/fiber这些Web框架。收到请求之后，检查附带文本中的关键字去调用对应的程序，然后返回结果。\ngo标准库中的os/exec包对调用外部程序提供了支持，本文详细介绍os/exec的使用姿势。\n#\r运行命令\rLinux中有个cal命令，它可以显示指定年、月的日历，如果不指定年、月，默认为当前时间对应的年月。如果使用的是Windows，推荐安装msys2，这个软件包含了绝大多数的Linux常用命令。\n那么，在Go代码中怎么调用这个命令呢？其实也很简单：\n1 2 3 4 5 6 7 func main() { cmd := exec.Command(\u0026#34;cal\u0026#34;) err := cmd.Run() if err != nil { log.Fatalf(\u0026#34;cmd.Run() failed: %v\\n\u0026#34;, err) } } 首先，我们调用exec.Command传入命令名，创建一个命令对象exec.Cmd。接着调用该命令对象的Run()方法运行它。\n如果你实际运行了，你会发现什么也没有发生，哈哈。事实上，使用os/exec执行命令，标准输出和标准错误默认会被丢弃。\n#\r显示输出\rexec.Cmd对象有两个字段Stdout和Stderr，类型皆为io.Writer。我们可以将任意实现了io.Writer接口的类型实例赋给这两个字段，继而实现标准输出和标准错误的重定向。io.Writer接口在 Go 标准库和第三方库中随处可见，例如*os.File、*bytes.Buffer、net.Conn。所以我们可以将命令的输出重定向到文件、内存缓存甚至发送到网络中。\n#\r显示到标准输出\r将exec.Cmd对象的Stdout和Stderr这两个字段都设置为os.Stdout，那么输出内容都将显示到标准输出：\n1 2 3 4 5 6 7 8 9 func main() { cmd := exec.Command(\u0026#34;cal\u0026#34;) cmd.Stdout = os.Stdout cmd.Stderr = os.Stderr err := cmd.Run() if err != nil { log.Fatalf(\u0026#34;cmd.Run() failed: %v\\n\u0026#34;, err) } } 运行程序。我在git bash运行，得到如下结果：\n输出了中文，检查一下环境变量LANG的值，果然是zh_CN.UTF-8。如果想输出英文，可以将环境变量LANG设置为en_US.UTF-8：\n1 2 3 $ echo $LANG zh_CN.UTF-8 $ LANG=en_US.UTF-8 go run main.go 得到输出：\n#\r输出到文件\r打开或创建文件，然后将文件句柄赋给exec.Cmd对象的Stdout和Stderr这两个字段即可实现输出到文件的功能。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 func main() { f, err := os.OpenFile(\u0026#34;out.txt\u0026#34;, os.O_WRONLY|os.O_CREATE, os.ModePerm) if err != nil { log.Fatalf(\u0026#34;os.OpenFile() failed: %v\\n\u0026#34;, err) } cmd := exec.Command(\u0026#34;cal\u0026#34;) cmd.Stdout = f cmd.Stderr = f err = cmd.Run() if err != nil { log.Fatalf(\u0026#34;cmd.Run() failed: %v\\n\u0026#34;, err) } } os.OpenFile打开一个文件，指定os.O_CREATE标志让操作系统在文件不存在时自动创建一个，返回该文件对象*os.File。*os.File实现了io.Writer接口。\n运行程序：\n1 2 3 4 5 6 7 8 9 $ go run main.go $ cat out.txt November 2022 Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #\r发送到网络\r现在我们来编写一个日历服务，接收年、月信息，返回该月的日历。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func cal(w http.ResponseWriter, r *http.Request) { year := r.URL.Query().Get(\u0026#34;year\u0026#34;) month := r.URL.Query().Get(\u0026#34;month\u0026#34;) cmd := exec.Command(\u0026#34;cal\u0026#34;, month, year) cmd.Stdout = w cmd.Stderr = w err := cmd.Run() if err != nil { log.Fatalf(\u0026#34;cmd.Run() failed: %v\\n\u0026#34;, err) } } func main() { http.HandleFunc(\u0026#34;/cal\u0026#34;, cal) http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil) } 这里为了简单，错误处理都省略了。正常情况下，year和month参数都需要做合法性校验。exec.Command函数接收一个字符串类型的可变参数作为命令的参数：\n1 func Command(name string, arg ...string) *Cmd #\r保存到内存对象中\r*bytes.Buffer同样也实现了io.Writer接口，故如果我们创建一个*bytes.Buffer对象，并将其赋给exec.Cmd的Stdout和Stderr这两个字段，那么命令执行之后，该*bytes.Buffer对象中保存的就是命令的输出。\n1 2 3 4 5 6 7 8 9 10 11 12 func main() { buf := bytes.NewBuffer(nil) cmd := exec.Command(\u0026#34;cal\u0026#34;) cmd.Stdout = buf cmd.Stderr = buf err := cmd.Run() if err != nil { log.Fatalf(\u0026#34;cmd.Run() failed: %v\\n\u0026#34;, err) } fmt.Println(buf.String()) } 运行：\n1 2 3 4 5 6 7 8 $ go run main.go November 2022 Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 运行命令，然后得到输出的字符串或字节切片这种模式是如此的普遍，并且使用便利，os/exec包提供了一个便捷方法：CombinedOutput。\n#\r输出到多个目的地\r有时，我们希望能输出到文件和网络，同时保存到内存对象。使用go提供的io.MultiWriter可以很容易实现这个需求。io.MultiWriter很方便地将多个io.Writer转为一个io.Writer。\n我们稍微修改上面的web程序：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func cal(w http.ResponseWriter, r *http.Request) { year := r.URL.Query().Get(\u0026#34;year\u0026#34;) month := r.URL.Query().Get(\u0026#34;month\u0026#34;) f, _ := os.OpenFile(\u0026#34;out.txt\u0026#34;, os.O_CREATE|os.O_WRONLY, os.ModePerm) buf := bytes.NewBuffer(nil) mw := io.MultiWriter(w, f, buf) cmd := exec.Command(\u0026#34;cal\u0026#34;, month, year) cmd.Stdout = mw cmd.Stderr = mw err := cmd.Run() if err != nil { log.Fatalf(\u0026#34;cmd.Run() failed: %v\\n\u0026#34;, err) } fmt.Println(buf.String()) } 调用io.MultiWriter将多个io.Writer整合成一个io.Writer，然后将cmd对象的Stdout和Stderr都赋值为这个io.Writer。这样，命令运行时产出的输出会分别送往http.ResponseWriter、*os.File以及*bytes.Buffer。\n#\r运行命令，获取输出\r前面提到，我们常常需要运行命令，返回输出。exec.Cmd对象提供了一个便捷方法：CombinedOutput()。该方法运行命令，将输出内容以一个字节切片返回便于后续处理。所以，上面获取输出的程序可以简化为：\n1 2 3 4 5 6 7 8 9 func main() { cmd := exec.Command(\u0026#34;cal\u0026#34;) output, err := cmd.CombinedOutput() if err != nil { log.Fatalf(\u0026#34;cmd.Run() failed: %v\\n\u0026#34;, err) } fmt.Println(string(output)) } So easy!\nCombinedOutput()方法的实现很简单，先将标准输出和标准错误重定向到*bytes.Buffer对象，然后运行程序，最后返回该对象中的字节切片：\n1 2 3 4 5 6 7 8 9 10 11 12 13 func (c *Cmd) CombinedOutput() ([]byte, error) { if c.Stdout != nil { return nil, errors.New(\u0026#34;exec: Stdout already set\u0026#34;) } if c.Stderr != nil { return nil, errors.New(\u0026#34;exec: Stderr already set\u0026#34;) } var b bytes.Buffer c.Stdout = \u0026amp;b c.Stderr = \u0026amp;b err := c.Run() return b.Bytes(), err } CombinedOutput方法前几行判断表明，Stdout和Stderr必须是未设置状态。这其实很好理解，一般情况下，如果已经打算使用CombinedOutput方法获取输出内容，不会再自找麻烦地再去设置Stdout和Stderr字段了。\n与CombinedOutput类似的还有Output方法，区别是Output只会返回运行命令产出的标准输出内容。\n#\r分别获取标准输出和标准错误\r创建两个*bytes.Buffer对象，分别赋给exec.Cmd对象的Stdout和Stderr这两个字段，然后运行命令即可分别获取标准输出和标准错误。\n1 2 3 4 5 6 7 8 9 10 11 12 func main() { cmd := exec.Command(\u0026#34;cal\u0026#34;, \u0026#34;15\u0026#34;, \u0026#34;2012\u0026#34;) var stdout, stderr bytes.Buffer cmd.Stdout = \u0026amp;stdout cmd.Stderr = \u0026amp;stderr err := cmd.Run() if err != nil { log.Fatalf(\u0026#34;cmd.Run() failed: %v\\n\u0026#34;, err) } fmt.Printf(\u0026#34;output:\\n%s\\nerror:\\n%s\\n\u0026#34;, stdout.String(), stderr.String()) } #\r标准输入\rexec.Cmd对象有一个类型为io.Reader的字段Stdin。命令运行时会从这个io.Reader读取输入。先来看一个最简单的例子：\n1 2 3 4 5 6 7 8 9 func main() { cmd := exec.Command(\u0026#34;cat\u0026#34;) cmd.Stdin = bytes.NewBufferString(\u0026#34;hello\\nworld\u0026#34;) cmd.Stdout = os.Stdout err := cmd.Run() if err != nil { log.Fatalf(\u0026#34;cmd.Run() failed: %v\\n\u0026#34;, err) } } 如果不带参数运行cat命令，则进入交互模式，cat按行读取输入，并且原样发送到输出。\n再来看一个复杂点的例子。Go标准库中compress/bzip2包只提供解压方法，并没有压缩方法。我们可以利用Linux命令bzip2实现压缩。bzip2从标准输入中读取数据，将其压缩，并发送到标准输出。\n1 2 3 4 5 6 7 8 9 10 11 12 func bzipCompress(d []byte) ([]byte, error) { var out bytes.Buffer cmd := exec.Command(\u0026#34;bzip2\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;-9\u0026#34;) cmd.Stdin = bytes.NewBuffer(d) cmd.Stdout = \u0026amp;out err := cmd.Run() if err != nil { log.Fatalf(\u0026#34;cmd.Run() failed: %v\\n\u0026#34;, err) } return out.Bytes(), nil } 参数-c表示压缩，-9表示压缩等级，9为最高。为了验证函数的正确性，写个简单的程序，先压缩\u0026quot;hello world\u0026quot;字符串，然后解压，看看是否能得到原来的字符串：\n1 2 3 4 5 6 7 func main() { data := []byte(\u0026#34;hello world\u0026#34;) compressed, _ := bzipCompress(data) r := bzip2.NewReader(bytes.NewBuffer(compressed)) decompressed, _ := ioutil.ReadAll(r) fmt.Println(string(decompressed)) } 运行程序，输出\u0026quot;hello world\u0026quot;。\n#\r环境变量\r环境变量可以在一定程度上微调程序的行为，当然这需要程序的支持。例如，设置ENV=production会抑制调试日志的输出。每个环境变量都是一个键值对。exec.Cmd对象中有一个类型为[]string的字段Env。我们可以通过修改它来达到控制命令运行时的环境变量的目的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;os/exec\u0026#34; ) func main() { cmd := exec.Command(\u0026#34;bash\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;./test.sh\u0026#34;) nameEnv := \u0026#34;NAME=darjun\u0026#34; ageEnv := \u0026#34;AGE=18\u0026#34; newEnv := append(os.Environ(), nameEnv, ageEnv) cmd.Env = newEnv out, err := cmd.CombinedOutput() if err != nil { log.Fatalf(\u0026#34;cmd.Run() failed: %v\\n\u0026#34;, err) } fmt.Println(string(out)) } 上面代码获取系统的环境变量，然后又添加了两个环境变量NAME和AGE。最后使用bash运行脚本test.sh：\n1 2 3 4 5 #!/bin/bash echo $NAME echo $AGE echo $GOPATH 程序运行结果：\n1 2 3 4 $ go run main.go darjun 18 D:\\workspace\\code\\go #\r检查命令是否存在\r一般在运行命令之前，我们通过希望能检查要运行的命令是否存在，如果存在则直接运行，否则提示用户安装此命令。os/exec包提供了函数LookPath可以获取命令所在目录，如果命令不存在，则返回一个error。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func main() { path, err := exec.LookPath(\u0026#34;ls\u0026#34;) if err != nil { fmt.Printf(\u0026#34;no cmd ls: %v\\n\u0026#34;, err) } else { fmt.Printf(\u0026#34;find ls in path:%s\\n\u0026#34;, path) } path, err = exec.LookPath(\u0026#34;not-exist\u0026#34;) if err != nil { fmt.Printf(\u0026#34;no cmd not-exist: %v\\n\u0026#34;, err) } else { fmt.Printf(\u0026#34;find not-exist in path:%s\\n\u0026#34;, path) } } 运行：\n1 2 3 $ go run main.go find ls in path:C:\\Program Files\\Git\\usr\\bin\\ls.exe no cmd not-exist: exec: \u0026#34;not-exist\u0026#34;: executable file not found in %PATH% #\r封装\r执行外部命令的流程比较固定：\n调用exec.Command()创建命令对象； 调用Cmd.Run()执行命令 可以自己封装成一个工具包。\n#\r总结\r本文介绍了使用os/exec这个标准库调用外部命令的各种姿势。\n#\r参考\rAdvanced command execution in go with os/exec: https://blog.kowalczyk.info/article/wOYk/advanced-command-execution-in-go-with-osexec.html Go中调用外部命令的几种姿势搬运自该篇文章。 ","date":"2024-04-24T23:41:31+08:00","permalink":"https://arlettebrook.github.io/p/go%E8%B0%83%E7%94%A8%E5%A4%96%E9%83%A8%E5%91%BD%E4%BB%A4os/exec%E5%BA%93%E4%BB%8B%E7%BB%8D/","title":"Go调用外部命令os/exec库介绍"},{"content":" #\r简介\r今天我们来看一个很小，很实用的库go-homedir。顾名思义，go-homedir用来获取用户的主目录。 实际上，使用标准库os/user或者os.UserHomeDir()我们也可以得到这个信息：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os/user\u0026#34; ) func main() { u, err := user.Current() if err != nil { log.Fatal(err) } fmt.Println(\u0026#34;Home dir:\u0026#34;, u.HomeDir) } 那么为什么还要go-homedir库？\n在 Darwin 系统上，标准库os/user的使用需要 cgo。所以，任何使用os/user的代码都不能交叉编译。 但是，大多数人使用os/user的目的仅仅只是想获取主目录。因此，go-homedir库出现了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func UserHomeDir() (string, error) { env, enverr := \u0026#34;HOME\u0026#34;, \u0026#34;$HOME\u0026#34; switch runtime.GOOS { case \u0026#34;windows\u0026#34;: env, enverr = \u0026#34;USERPROFILE\u0026#34;, \u0026#34;%userprofile%\u0026#34; case \u0026#34;plan9\u0026#34;: env, enverr = \u0026#34;home\u0026#34;, \u0026#34;$home\u0026#34; } if v := Getenv(env); v != \u0026#34;\u0026#34; { return v, nil } // On some geese the home directory is not always defined. switch runtime.GOOS { case \u0026#34;android\u0026#34;: return \u0026#34;/sdcard\u0026#34;, nil case \u0026#34;ios\u0026#34;: return \u0026#34;/\u0026#34;, nil } return \u0026#34;\u0026#34;, errors.New(enverr + \u0026#34; is not defined\u0026#34;) } 还有就是官方的库也只是从环境变量中获取用户的家目录，没有考虑$HOME不存在的情况。\n#\r快速使用\rgo-homedir是第三方包，使用前需要先安装：\n1 $ go get -u github.com/mitchellh/go-homedir 使用非常简单：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;github.com/mitchellh/go-homedir\u0026#34; ) func main() { dir, err := homedir.Dir() if err != nil { log.Fatal(err) } fmt.Println(\u0026#34;Home dir:\u0026#34;, dir) dir = \u0026#34;~/golang/src\u0026#34; expandedDir, err := homedir.Expand(dir) if err != nil { log.Fatal(err) } fmt.Printf(\u0026#34;Expand of %s is: %s\\n\u0026#34;, dir, expandedDir) } go-homedir有两个功能：\nDir：获取用户主目录； Expand：将路径中的第一个~扩展成用户主目录。 #\r高级用法\r由于Dir的调用可能涉及一些系统调用和外部执行命令，多次调用费性能。所以go-homedir提供了缓存的功能。默认情况下，缓存是开启的。 我们也可以将DisableCache设置为true来关闭它。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;github.com/mitchellh/go-homedir\u0026#34; ) func main() { homedir.DisableCache = true # 关闭了缓存 dir, err := homedir.Dir() if err != nil { log.Fatal(err) } fmt.Println(\u0026#34;Home dir:\u0026#34;, dir) } 使用缓存时，如果程序运行中修改了主目录，再次调用Dir还是返回之前的目录。如果需要获取最新的主目录，可以先调用Reset清除缓存。\n#\r实现\rgo-homedir源码只有一个文件homedir.go，今天我们大概看一下Dir的实现，去掉缓存相关代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func Dir() (string, error) { var result string var err error if runtime.GOOS == \u0026#34;windows\u0026#34; { result, err = dirWindows() } else { // Unix-like system, so just assume Unix result, err = dirUnix() } if err != nil { return \u0026#34;\u0026#34;, err } return result, nil } 判断当前的系统是windows还是类 Unix，分别调用不同的方法。先看 windows 的，比较简单：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func dirWindows() (string, error) { // First prefer the HOME environmental variable if home := os.Getenv(\u0026#34;HOME\u0026#34;); home != \u0026#34;\u0026#34; { return home, nil } // Prefer standard environment variable USERPROFILE if home := os.Getenv(\u0026#34;USERPROFILE\u0026#34;); home != \u0026#34;\u0026#34; { return home, nil } drive := os.Getenv(\u0026#34;HOMEDRIVE\u0026#34;) path := os.Getenv(\u0026#34;HOMEPATH\u0026#34;) home := drive + path if drive == \u0026#34;\u0026#34; || path == \u0026#34;\u0026#34; { return \u0026#34;\u0026#34;, errors.New(\u0026#34;HOMEDRIVE, HOMEPATH, or USERPROFILE are blank\u0026#34;) } return home, nil } 流程如下：\n读取环境变量HOME，如果不为空，返回这个值； 读取环境变量USERPROFILE，如果不为空，返回这个值； 读取环境变量HOMEDRIVE和HOMEPATH，如果两者都不为空，拼接这两个值返回。 类 Unix 系统的实现稍微复杂一点：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 func dirUnix() (string, error) { homeEnv := \u0026#34;HOME\u0026#34; if runtime.GOOS == \u0026#34;plan9\u0026#34; { // On plan9, env vars are lowercase. homeEnv = \u0026#34;home\u0026#34; } // First prefer the HOME environmental variable if home := os.Getenv(homeEnv); home != \u0026#34;\u0026#34; { return home, nil } var stdout bytes.Buffer // If that fails, try OS specific commands if runtime.GOOS == \u0026#34;darwin\u0026#34; { cmd := exec.Command(\u0026#34;sh\u0026#34;, \u0026#34;-c\u0026#34;, `dscl -q . -read /Users/\u0026#34;$(whoami)\u0026#34; NFSHomeDirectory | sed \u0026#39;s/^[^ ]*: //\u0026#39;`) cmd.Stdout = \u0026amp;stdout if err := cmd.Run(); err == nil { result := strings.TrimSpace(stdout.String()) if result != \u0026#34;\u0026#34; { return result, nil } } } else { cmd := exec.Command(\u0026#34;getent\u0026#34;, \u0026#34;passwd\u0026#34;, strconv.Itoa(os.Getuid())) cmd.Stdout = \u0026amp;stdout if err := cmd.Run(); err != nil { // If the error is ErrNotFound, we ignore it. Otherwise, return it. if err != exec.ErrNotFound { return \u0026#34;\u0026#34;, err } } else { if passwd := strings.TrimSpace(stdout.String()); passwd != \u0026#34;\u0026#34; { // username:password:uid:gid:gecos:home:shell passwdParts := strings.SplitN(passwd, \u0026#34;:\u0026#34;, 7) if len(passwdParts) \u0026gt; 5 { return passwdParts[5], nil } } } } // If all else fails, try the shell stdout.Reset() cmd := exec.Command(\u0026#34;sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;cd \u0026amp;\u0026amp; pwd\u0026#34;) cmd.Stdout = \u0026amp;stdout if err := cmd.Run(); err != nil { return \u0026#34;\u0026#34;, err } result := strings.TrimSpace(stdout.String()) if result == \u0026#34;\u0026#34; { return \u0026#34;\u0026#34;, errors.New(\u0026#34;blank output when reading home directory\u0026#34;) } return result, nil } 流程如下：\n先读取环境变量HOME（注意 plan9 系统上为home），如果不为空，返回这个值； 使用getnet命令查看系统的数据库中的相关记录，我们知道passwd文件中存储了用户信息，包括用户的主目录。使用getent命令查看passwd中当前用户的那条记录，然后从中找到主目录部分返回； 如果上一个步骤失败了，我们知道cd后不加参数是直接切换到用户主目录的，而pwd可以显示当前目录。那么就可以结合这两个命令返回主目录。 这里分析源码并不是表示使用任何库都要熟悉它的源码，毕竟使用库就是为了方便开发。 但是源码是我们学习和提高的一个非常重要的途径。我们在使用库遇到问题的时候也要有能力从文档或甚至源码中查找原因。\n#\r参考\rhome-dir GitHub 仓库 Go 每日一库之 go-homedir ","date":"2024-04-24T22:47:45+08:00","permalink":"https://arlettebrook.github.io/p/go-homedir%E5%BA%93%E4%BB%8B%E7%BB%8D/","title":"Go-homedir库介绍"},{"content":" 注意：要学会使用-h \u0026ndash;help选项，查看命令，看不懂在查阅。git help \u0026lt;command\u0026gt;可进入官方文档。Git入门参考。以下常用命令个人收集总结。\n#\rgit简单命令\r#\rgit init\rgit init \u0026lt;directory\u0026gt;在指定的⽬录下创建⼀个空的git repo。不带参数将在当前⽬录下创建⼀个git repo。 #\rgit clone\rgit clone \u0026lt;repo\u0026gt;克隆⼀个指定repo到本地。指定的repo可以是本地⽂件系统或者由HTTP或SSH指定的远程路径。 git clone -b \u0026lt;branch\u0026gt; \u0026lt;repo\u0026gt;克隆指定仓库的分支 git clone --recursive \u0026lt;repo\u0026gt;递归地克隆，克隆带有子模块的仓库 git clone --recurse-submodules \u0026lt;repository_url\u0026gt;同理 可组合使用 #\rgit add\rgit add \u0026lt;directory\u0026gt;将指定⽬录的所有修改加⼊到下⼀次 commit中。把\u0026lt;directory\u0026gt;替换成\u0026lt;file\u0026gt;将添加指定⽂件的修改。 git add *、git add .、git add -A三条命令但是一样的，将所以修改提交到暂存区。 #\rgit commit\r这个命令通常带-m选项git commit -m \u0026quot;\u0026lt;message\u0026gt;\u0026quot;提交暂存区的修改，使⽤指定的 \u0026lt;message\u0026gt;作为提交信息，⽽不是打开⽂本编辑器输⼊提交信息。 git commit -m \u0026lt;message\u0026gt; --amend将当前staged修改合并到最近⼀次的commit中。 #\rgit status\rgit status显示哪些⽂件已被staged、以及未跟踪(untracked)。 #\rgit reflog\rgit reflog显示本地repo的所有commit⽇志。 与git log的区别 log项目的提交历史，reflog本地仓库的引用提交日志。 引用会保留所以的提交历史，如何重置的历史。主要目的是提供一个安全网，以便在误操作（如错误的 git reset）后可以恢复丢失的提交或分支。 git log 的输出是永久性的，而 reflog 会在一段时间后自动过期（默认是 30 天），以节省空间。 #\rgit rm\rgit rm fileName删除指定的文件。 与rm fileName的区别。 git rm不能删除未跟踪的文件， git rm删除之后直接到暂存区，而rm是到工作区 注意删除之后都需要提交操作。 撤销操作不用记，git都会有提示 #\rgit switch\r该命令适用于特定git版本。\ngit switch \u0026lt;branch\u0026gt;切换到指定分支，\ngit checkout \u0026lt;branch\u0026gt;同理，但这个都适用。 git switch -c \u0026lt;branch\u0026gt;创建并切换指定分支\n#\rgit branch\rgit branch显示本地repo的所有分⽀。\n-v显示详细信息 带*的为当前分支 git branch -r显示远程仓库的所以分支。\n可以使用git checkout \u0026lt;branch\u0026gt;检出远程分支，可以省略origin/。 git branch -a显示本地和远程的所有分支\ngit branch -m \u0026lt;old_branch_name\u0026gt; \u0026lt;new_branch_name\u0026gt;重命名分支\n新分支名已经存在， -M 强制重命名。 git branch \u0026lt;name\u0026gt;创建指定分支\ngit branch -D \u0026lt;branch\u0026gt;强制删除指定分支，无论是否合并到当前分支。\ngit branch -d \u0026lt;branch\u0026gt;删除指定的分支，如果没有合并到当前分支，git会阻止操作。\n#\rgit merge\rgit merge \u0026lt;branch\u0026gt;合并指定分支。将指定\u0026lt;branch\u0026gt;分⽀合并到当前分⽀。 是在当前分支合并指定分支。 合并分支可能会出现冲突。要解决冲突之后才能合并。 git merge --abort放弃本次合并 #\rgit一般命令\r#\rgit revert\rgit revert \u0026lt;commit\u0026gt; 对指定\u0026lt;commit\u0026gt;创建⼀个undo的commit，并应⽤到当前分⽀。就是撤销指定的提交并保留记录 效果：撤销指定的提交，回到了撤销提交的是上个版本，保留了撤销历史。会打开编辑器显示具体效果 一般不用 #\rgit reset\rgit reset \u0026lt;commit\u0026gt;重置到指定的提交，不会保留commit历史。工作区和暂存区会变成未跟踪。--hard选项完全重置到指定提交。未跟踪的重置不了。重置历史可以通过git reflog查看，利用这个可以重置已经重置的版本库。\n\u0026lt;commit\u0026gt;可以是： HEAD表示最新的提交或者这个版本库，HEAD^、HEAD~1上上次提交或者上个版本 或者使用commit_hash，提交的哈希值可以使用git log查看，只需要前几位就行。 git reset（重置到最新的提交）移除所有暂存区、工作区的修改，到未跟踪。这些命令其实省略了HEAD\ngit reset --hard 重置到最新的提交，删除工作区和暂存区\ngit reset \u0026lt;file\u0026gt;将\u0026lt;file\u0026gt;从暂存区移除，但保持⼯作区不变。此操作不会修改⼯作区的任何⽂件。\n#\rgit restore\rgit restore \u0026lt;file\u0026gt;...撤销对工作区的修改，是对以跟踪的文件当未添加到暂存区的文件。多个文件用空格分开。 git checkout -- \u0026lt;file\u0026gt;...同理，--可以省略 git restore --staged \u0026lt;file\u0026gt;...撤销对暂存区的修改到未跟踪。针对添加到暂存区的文件。 git reset HEAD \u0026lt;file\u0026gt;...同理，HEAD可以省略。 具体用哪一个，git都会有提示，不用记。 #\rgit checkout\rgit checkout \u0026lt;branch\u0026gt;切换到指定的分支\n如果分支为远程分支，则检出远程分支 git checkout -b \u0026lt;new-branch\u0026gt;切换并创建指定的分支\ngit checkout \u0026lt;file\u0026gt;撤销工作区的修改\ngit restore \u0026lt;file\u0026gt;同理 git checkout \u0026lt;commit\u0026gt;根据指定的提交创建一个分支,处于游离态。一般不用。\ngit checkout -b \u0026lt;local_branch_name\u0026gt; origin/\u0026lt;remote_branch_name\u0026gt;切换到远程分支\ngit checkout \u0026lt;branch\u0026gt;差不多，可以使用git fetch origin获取仓库所以信息，在检出分支。 git checkout -切换到前一个分支。\n#\rgit remote\r用来管理远程仓库列表，origin为远程仓库的默认别名。这些远端仓库的信息都被保存在./git/config 文件中。\ngit remote列出所有已配置的远程仓库的信息。\n-v显示详细信息 git remote add \u0026lt;remote_name\u0026gt; \u0026lt;remote_url\u0026gt;添加远程仓库\n添加⼀个新的远程连接。添加后可使⽤ \u0026lt;name\u0026gt;作为指定\u0026lt;url\u0026gt;远程连接的名称。 只有配置了这个才能推送到远程仓库。 git remote rename \u0026lt;old_name\u0026gt; \u0026lt;new_name\u0026gt;重命名远程仓库。 git remote set-url \u0026lt;remote_name\u0026gt; \u0026lt;new_url\u0026gt;修改远程仓库的url。 git remote remove \u0026lt;remote_name\u0026gt;或git remote rm \u0026lt;remote_name\u0026gt;删除远程仓库。 git remote show \u0026lt;remote_name\u0026gt;显示远程仓库的详细信息，包括 URL、跟踪的分支等。\n补充如何创建远程仓库\n创建远程仓库可以先在github上创建好，然后在本地pull下来，在进行修改后push上去。\n可以建一个空白仓库，在本地push上去，但需要进行绑定。\n1 2 3 git remote add origin https://github.com/username/null-project.git git branch -M main git push -u origin main #\rgjit push\r将本地仓库推送到远程仓库\ngit push \u0026lt;remote_repository\u0026gt; \u0026lt;本地分支名\u0026gt;:\u0026lt;远程分支名\u0026gt;推送本地分支到指定的远程分支。如果远程分支不存在，会自动创建。:前后不能有空格。\n当分支同名，可以简写成git push \u0026lt;remote_repository\u0026gt; \u0026lt;本地分支名\u0026gt; 果无法提交的话执行，-f、--force选项强制推送，一般不用。 git push -u \u0026lt;remote_repository\u0026gt; \u0026lt;本地分支名\u0026gt;设置默认推送分支。\n作用：这样设置以后，推送到远程仓库可以简写成git push git push 代替 git push origin master -u是--set-upstream的短形式。 git push \u0026lt;remote_repository\u0026gt; -d \u0026lt;远程分支名\u0026gt;删除远程分支 。\n--delete长选项。 git push origin :test同理，没有写本地分支，就是删除远程分支。 git push \u0026lt;remote\u0026gt; \u0026lt;tagname\u0026gt;推送指定标签到指定远程仓库，一般为`origin``\n``git push \u0026ndash;tags`推送所用标签到远程\n#\rgit pull\rgit pull \u0026lt;remote_repository\u0026gt; \u0026lt;远程分支名\u0026gt;:\u0026lt;本地分支名\u0026gt;从远程仓库拉取最新代码到本地仓库。 git pull会拉取并合并，出现冲突要解决之后才能合并。 git fetch获取当前远程仓库的最新信息，不会合并。 通常可以简写成git pull,远程仓库默认是origin，分支默认是当前分支。 git pull --rebase\u0026lt;remote\u0026gt; 抓取远程分⽀，并以rebase模式并⼊本地repo⽽不是merge。 #\rgit fetch\rgit fetch origin获取远程仓库最新的更改。不会合并。默认仓库是origin，分支是当前分支，这里可以省略origin git fetch origin \u0026lt;branch\u0026gt;获取特定分支的更改. git fetch --all获取所用仓库远程仓库的最新更改。 与git pull的区别 都会获取远程仓库最新的更改。 但是fetch不会合并，而pull会合并。可以理解为git pull 是 git fetch 和 git merge 的组合 获取最新更改之后可以： git checkout \u0026lt;branch\u0026gt;检出指定分支，如果加origin要这样git checkout -b \u0026lt;branch\u0026gt; origin/\u0026lt;branch\u0026gt; git merge origin/master合并远程 master 分支的更改到当前的分支 git rebase origin/master使用 rebase 来整合更改（这可能会改变提交历史） #\rgit stash\rgit stash保存工作区、暂存区，可以切换分支去完成别的任务。不保存修改，未提交的修改会错乱到别的分支。并且只能保存已追踪的文件。 git stash list查看保存的工作区以及暂存区。 git stash apply恢复保存的工作区以及暂存区。 这个命令执行之后不会删除存储的工作区以及暂存区。 要用git stash drop才能删除。 git stash pop恢复并删除保存的工作区以及暂存区。 默认都是保存、恢复第一个stash即stash@{0}。若要指定第几个在后面加stash@{num}。 如恢复第二个stash：git stash pop stash@{1} 每个分支共用一个stash。 #\rgit tag\r作用：用于标记项目的版本发布或重要的里程碑。 分类 git tag \u0026lt;tagname\u0026gt; \u0026lt;commit ID\u0026gt;轻量标签 git tag vn.n.n打标签，n.n.n表示对应的版本号，版本号前面一般加v，遵循一定的命名规范，如v1.0.1。 默认是打在最新的一次提交。 后面跟提交的哈希值可以指定给那次提交打标签。如git tag v0.9.0 f52c633。 哈希值可以通过git log查看 git tag -a \u0026lt;tagname\u0026gt; -m \u0026quot;\u0026lt;tag message\u0026gt;\u0026quot; \u0026lt;commit ID\u0026gt;附注标签 如git tag -a v0.1 -m \u0026quot;version 0.1 released\u0026quot; 1094adb 推荐id省略默认最新提交。 查看标签 git tag显示所有的本地tag列表，按照字母顺序排序。如果tag数量较多，可能会显示不全。省略选项-l、--list git show \u0026lt;tagname\u0026gt;显示指定tag的详细信息，包括提交的作者、提交时间、提交信息等。 git tag -n：显示tag列表，并同时显示每个tag对应的提交信息。 git ls-remote --tags origin：显示远程仓库中的所有tag信息。更推荐这种。 或者先git fetch获取最新的更改，然后git tag检出所有标签。 删除标签 git tag -d \u0026lt;tagname\u0026gt;删除本地标签 删除远程标签：首先需要在本地删除标签，然后推送到远程仓库 git push origin :refs/tags/\u0026lt;tagname\u0026gt; 远程标签是refs/tags/v0.0.1这样存在的，跟删除远程分支差不多。 标签一旦创建，就不能直接修改,如果需要修改标签，通常需要删除原标签，并重新创建一个新标签。 推送标签 打的标签不会自动推送到远程仓库，需要手动推送。 git push \u0026lt;remote\u0026gt; \u0026lt;tagname\u0026gt;推送指定标签到指定远程仓库，一般为origin git push \u0026lt;remote\u0026gt; --tags推送所用标签到远程 #\rgit复杂命令\r#\rgit log\rgit log以缺省格式显示全部commit历史。更多⾃定义参数请参考后续部分。q退出，空格下一页，h查看帮助 git log --stat：显示详细的commit历史。 git log -\u0026lt;limit\u0026gt;限制log的显示数量。例如：”git log -5”仅显示最新5条commit。 git log --oneline每⾏显示⼀条commit，简化信息。与--pretty=oneline等效 git log --author= \u0026quot;\u0026lt;pattern\u0026gt;\u0026quot;按提交者名字搜索并显示commit。 git log --grep= \u0026quot;\u0026lt;pattern\u0026gt;\u0026quot;按指定内容搜索并显示commit。 git log \u0026lt;since\u0026gt;..\u0026lt;until\u0026gt;显示指定范围的commit。范围参数可以是commit ID、分⽀名称、HEAD或任意相对位置。 git log -- \u0026lt;file\u0026gt;仅显示包含指定⽂件修改的commit。 git log --graph使⽤\u0026ndash;graph参数显示图形化的branch信息。 #\rgit diff\rgit diff⽐较⼯作区和暂存区的修改。 git diff HEAD⽐较⼯作区和上⼀次commit后的修改。 HEAD指向当前分支最新的commit版本库 git diff --cached⽐较暂存区和上⼀次commit后的修改。 git diff --stashed查看暂存区与最新提交的差异，与上面一样 git diff \u0026lt;commit1\u0026gt; \u0026lt;commit2\u0026gt;查看两个提交之间的差异。 git diff \u0026lt;filename\u0026gt;后面指定文件，只查看该文件的修改情况，没有参数查询全部 用git diff HEAD -- readme.txt命令可以查看版本库和工作区里面最新版本的区别 #\rgit config\r作用：通过git config命令配置git的配置文件\ngit配置文件级别分为：\n仓库级别 --local 【优先级最高】。文件所在位置仓库下的.git/config 当前用户级别 --global【优先级次之】一般配置它。文件所在位置用户家目录下的.gitconfig 系统所有用户级别 --system【优先级最低】。文件所在位置git安装目录下的 ./etc/gitconfig -l、--list查看配置。常用\ngit config -l查看所有的配置信息，依次是系统级别、用户级别、仓库级别 git config --local -l 查看仓库级别配置。必须要进入到具体的目录下。 git config --global -l 查看当前用户配置 git config --system -l 查看系统所有用户配置 可以与--show-origin 显示文件位置，--show-scope显示文件级别组合使用 -e、--edit打开编辑器编辑指定级别的配置文件，没有指定默认仓库级别，会使用默认编辑器打开编辑。安装的时候设置的。\n添加配置、修改配置：直接配置对应的配置参数就行。一般配置用户级别就行。省略了--add选项。没有指定级别，默认仓库基本。常用的添加配置命令:\n用户邮箱和用户名。安装git之后必设置的配置\ngit config --global user.email \u0026quot;Your mail\u0026quot;\ngit config --global user.name \u0026quot;Your name\u0026quot;\n如果我们没有配置，在提交代码时会有如下错误：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 xxx@DESKTOP-MD21325 MINGW64 /d/test/test (master) $ git commit -m \u0026#34;feature: add readme\u0026#34; Author identity unknown *** Please tell me who you are. Run git config --global user.email \u0026#34;you@example.com\u0026#34; git config --global user.name \u0026#34;Your Name\u0026#34; to set your account\u0026#39;s default identity. Omit --global to set the identity only in this repository. fatal: unable to auto-detect email address (got \u0026#39;xxx@DESKTOP-MD21325.(none)\u0026#39;) 设置自己的代理。网速慢必设置的配置\ngit config --global http.proxy \u0026quot;http://proxy_ip:port\u0026quot;\ngit config --global https.proxy \u0026quot;https://proxy_ip:port\u0026quot;\n--unset取消配置，注意要指定取消的配置级别。常用取消配置命令：\n取消代理配置\ngit config --global --unset http.proxy\ngit config --global --unset https.proxy\n--get查看指定级别、指定配置项的配置，默认仓库级别。如：\n查看代理配置\ngit config --global --get http.proxy\ngit config --global --get https.proxy\ngit config --global alias.\u0026lt;alias-name\u0026gt; \u0026lt;git-command\u0026gt;配置⼀个git命令的快捷⽅式。例如：配置”alias.glog log \u0026ndash;graph \u0026ndash;oneline”使”git glog”相当于”git log \u0026ndash;graph \u0026ndash;oneline”.\ngit config --global core.editor \u0026lt;editor\u0026gt;配置⽂本编辑器，例如vi，在必要时⾃动打开此⽂本编辑器。安装的时候也可以指定默认编辑器。\n#\rgit submodule\rgit submodule init初始化子模块，将子模块的配置信息存储在父仓库中。\n通常执行之后再执行更新子模块使用，如克隆带有子模块的仓库，没有加--recursive，是不会克隆子模块的 初始化子模块之后，执行更新子模块就会根据配置信息下载子模块 git submodule update根据父仓库子模块的配置信息更新子模块，如果没有初始化子模块可以加参数--init，会下载与父项目绑定版本的子模块，若要更新加--remote\n--init初识化子模块 --recursive会递归下载子模块的子模块 --remote根据子模块远程仓库的配置信息更新子模块，会下载最新版本的子模块 注意更新之后要提交更新的版本，否则当在执行更新命令没有加--remote时会退回与父仓库绑定的版本 git submodule add \u0026lt;repository\u0026gt; \u0026lt;path\u0026gt;添加子模块。其中，\u0026lt;repository\u0026gt;是子模块的远程仓库地址，\u0026lt;path\u0026gt;是子模块在主项目中的路径。\n子模块可以当正常仓库使用。创建时\u0026lt;path\u0026gt;路径不能存在文件，更克隆差不多。 #\rgit subtree\r作用：将一个仓库中的目录作为另一个仓库，可以指定分支 用途：搭建项目网站时，将项目网站资源推送到gh-pages分支上 git subtree push --prefix=dist origin gh-pages将目录添加到gh-pages分支上，dist为项目网站的目录 git subtree push --prefix=\u0026lt;prefix\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;branch\u0026gt;将子目录的内容推送到远程仓库。它会将当前仓库中子目录的修改推送到指定的远程仓库和分支中。 注意：以这种推送的方式添加的subtree不能执行subtree pull命令，只有通过subtree add添加的才能都执行，但能够执行subtree push命令 git subtree pull --prefix=\u0026lt;prefix\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;branch\u0026gt;这个命令用于从远程仓库更新子目录的内容。它会拉取远程仓库的最新代码，并更新到当前仓库的子目录中。 git subtree add --prefix=\u0026lt;prefix\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;branch\u0026gt;这个命令用于将远程仓库的内容作为子目录添加到当前仓库中。\u0026lt;prefix\u0026gt;是子目录的名称，\u0026lt;repository\u0026gt;是远程仓库的地址，\u0026lt;branch\u0026gt;是要合并的分支。 #\rgit rebase\r作用：rebase翻译成变基，顾名思义：改变基准点。可以使提交历史更加清晰和线性。\n原因：通过合并两个不同的分支，提交历史会很错乱。而通过变基，会使得提交历史更加整洁和可读。\n如何实现：就是修改创建分支的起点（基准点），到最新的提交。起点变了，提交历史就简化了。\n命令：\ngit rebase \u0026lt;base\u0026gt;基于\u0026lt;base\u0026gt;对当前分⽀进⾏rebase。\u0026lt;base\u0026gt;可以是commit、分⽀名称、tag或相对于HEAD的commit。 git rebase -i \u0026lt;base\u0026gt;以交互模式对当前分⽀做rebase。 rebase的过程中可能会出现冲突，解决冲突之后需要使用git add命令将解决冲突后的文件标记为已解决，然后，使用git rebase --continue命令继续rebase过程。Git会尝试继续应用剩余的提交。如果再次出现冲突，你需要重复上述解决冲突和继续rebase的步骤。 如果在rebase过程中出现了问题，或者你决定放弃rebase操作，你可以使用git rebase --abort命令来撤销整个rebase操作。 git rebase的注意事项\n避免对已经推送到远程仓库的提交执行rebase操作：这可能会导致提交历史的不一致，给其他协作者带来困扰。 保持工作目录干净：在执行rebase之前，确保你的工作目录中没有未提交的更改。 谨慎使用：由于rebase会改变提交历史，因此在与他人共享分支时要特别小心。通常，在公共分支上应该使用merge而不是rebase。 通过掌握git rebase的用法和注意事项，你可以更有效地管理你的Git仓库，保持代码的清晰和整洁。\n​\n#\r扩展\r#\r.gitignore文件\rGit提供了.gitignore文件，用于指定哪些文件或目录应该被Git忽略，不纳入版本控制系统中。.gitignore文件是一个文本文件，可以包含一些简单的规则，指定应该忽略哪些文件或目录。以下是一些.gitignore文件的示例规则：\n忽略所有以.tmp结尾的文件：\n1 *.tmp 忽略所有的log文件：\n1 *.log 忽略所有的.idea目录：\n1 .idea/ 忽略所有的build目录及其内容：\n1 build/ 忽略根目录下的config.json文件，但不忽略子目录中的config.json文件：\n1 /config.json 忽略所有的node_modules目录及其内容：\n1 node_modules/ 忽略所有的DS_Store文件（Mac OS X系统中的文件）：\n1 .DS_Store 可以将这些规则写入.gitignore文件中，并将该文件添加到Git仓库中，以使Git忽略这些文件或目录。需要注意的是，即使某些文件或目录已经被添加到Git仓库中，也可以通过修改.gitignore文件来让Git忽略它们，但需要执行以下命令才能使.gitignore文件生效：\n1 2 3 4 git rm -r --cached . git add . git commit -m \u0026#34;update .gitignore\u0026#34; git push 这些命令会删除Git缓存中已经添加的文件，然后重新添加文件并提交更改，以使.gitignore文件生效。\n总结：\n当Git执行提交操作时，它会检查.gitignore文件中列出的文件和目录，并将它们从提交中排除。这是非常有用的，因为有些文件或目录不应该被纳入版本控制系统中，例如编译生成的文件、日志文件、临时文件等。\n.gitignore文件的语法是基于模式匹配的，其中的特殊字符有：\n*：匹配任意字符，但不包括路径分隔符（/）。 ?：匹配任意单个字符，但不包括路径分隔符（/）。 /：路径分隔符，用于指定目录。 !：用于否定模式，即不忽略指定的文件或目录。 可以在.gitignore文件中使用通配符、路径、注释等语法，以更精确地指定需要忽略的文件或目录。同时，可以在仓库的根目录下创建一个.gitignore文件，也可以在子目录中创建独立的.gitignore文件。\n","date":"2024-04-22T22:18:17+08:00","permalink":"https://arlettebrook.github.io/p/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","title":"Git常用命令"},{"content":"\r#\r简介\rflag用于解析命令行选项。有过类 Unix 系统使用经验的童鞋对命令行选项应该不陌生。例如命令ls -al列出当前目录下所有文件和目录的详细信息，其中-al就是命令行选项。\n命令行选项在实际开发中很常用，特别是在写工具的时候。\n指定配置文件的路径，如redis-server ./redis.conf以当前目录下的配置文件redis.conf启动 Redis 服务器； 自定义某些参数，如python -m SimpleHTTPServer 8080启动一个 HTTP 服务器，监听 8080 端口。如果不指定，则默认监听 8000 端口。 #\r快速使用\r学习一个库的第一步当然是使用它。我们先看看flag库的基本使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;flag\u0026#34; ) var ( intflag int boolflag bool stringflag string ) func init() { flag.IntVar(\u0026amp;intflag, \u0026#34;intflag\u0026#34;, 0, \u0026#34;int flag value\u0026#34;) flag.BoolVar(\u0026amp;boolflag, \u0026#34;boolflag\u0026#34;, false, \u0026#34;bool flag value\u0026#34;) flag.StringVar(\u0026amp;stringflag, \u0026#34;stringflag\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;string flag value\u0026#34;) } func main() { flag.Parse() fmt.Println(\u0026#34;int flag:\u0026#34;, intflag) fmt.Println(\u0026#34;bool flag:\u0026#34;, boolflag) fmt.Println(\u0026#34;string flag:\u0026#34;, stringflag) } 可以先编译程序，然后运行（我使用的是 Win10 + Git Bash）：\n1 2 $ go build -o main.exe main.go $ ./main.exe -intflag 12 -boolflag 1 -stringflag test 输出：\n1 2 3 int flag: 12 bool flag: true string flag: test 如果不设置某个选项，相应变量会取默认值：\n1 $ ./main.exe -intflag 12 -boolflag 1 输出：\n1 2 3 int flag: 12 bool flag: true string flag: default 可以看到没有设置的选项stringflag为默认值default。\n还可以直接使用go run，这个命令会先编译程序生成可执行文件，然后执行该文件，将命令行中的其它选项传给这个程序。\n1 go run main.go -intflag 12 -boolflag 1 可以使用-h显示选项帮助信息：\n1 2 3 4 5 6 7 8 $ ./main.exe -h Usage of D:\\code\\golang\\src\\github.com\\darjun\\cmd\\flag\\main.exe: -boolflag bool flag value -intflag int int flag value -stringflag string string flag value (default \u0026#34;default\u0026#34;) 总结一下，使用flag库的一般步骤：\n定义一些全局变量存储选项的值，如这里的intflag/boolflag/stringflag； 在init方法中使用flag.TypeVar方法定义选项，这里的Type可以为基本类型Int/Uint/Float64/Bool，还可以是时间间隔time.Duration。定义时传入变量的地址、选项名、默认值和帮助信息； 在main方法中调用flag.Parse从os.Args[1:]中解析选项。因为os.Args[0]为可执行程序路径，会被剔除。 注意点：\nflag.Parse方法必须在所有选项都定义之后调用，且flag.Parse调用之后不能再定义选项。如果按照前面的步骤，基本不会出现问题。 因为init在所有代码之前执行，将选项定义都放在init中，main函数中执行flag.Parse时所有选项都已经定义了。\n#\r选项格式\rflag库支持三种命令行选项格式。\n1 2 3 -flag -flag=x -flag x -和--都可以使用，它们的作用是一样的。有些库使用-表示短选项，--表示长选项。相对而言，flag使用起来更简单。\n第一种形式只支持布尔类型的选项，出现即为true，不出现为默认值。 第三种形式不支持布尔类型的选项。因为这种形式的布尔选项在类 Unix 系统中可能会出现意想不到的行为。看下面的命令：\n1 cmd -x * 其中，*是 shell 通配符。如果有名字为 0、false的文件，布尔选项-x将会取false。反之，布尔选项-x将会取true。而且这个选项消耗了一个参数。 如果要显示设置一个布尔选项为false，只能使用-flag=false这种形式。\n遇到第一个非选项参数（即不是以-和--开头的）或终止符--，解析停止。运行下面程序：\n1 $ ./main.exe noflag -intflag 12 将会输出：\n1 2 3 int flag: 0 bool flag: false string flag: default 因为解析遇到noflag就停止了，后面的选项-intflag没有被解析到。所以所有选项都取的默认值。\n运行下面的程序：\n1 $ ./main.exe -intflag 12 -- -boolflag=true 将会输出：\n1 2 3 int flag: 12 bool flag: false string flag: default 首先解析了选项intflag，设置其值为 12。遇到--后解析终止了，后面的--boolflag=true没有被解析到，所以boolflag选项取默认值false。\n解析终止之后如果还有命令行参数，flag库会存储下来，通过flag.Args方法返回这些参数的切片。 可以通过flag.NArg方法获取未解析的参数数量，flag.Arg(i)访问位置i（从 0 开始）上的参数。 选项个数也可以通过调用flag.NFlag方法获取。\n稍稍修改一下上面的程序：\n1 2 3 4 5 6 7 8 9 10 11 func main() { flag.Parse() fmt.Println(flag.Args()) fmt.Println(\u0026#34;Non-Flag Argument Count:\u0026#34;, flag.NArg()) for i := 0; i \u0026lt; flag.NArg(); i++ { fmt.Printf(\u0026#34;Argument %d: %s\\n\u0026#34;, i, flag.Arg(i)) } fmt.Println(\u0026#34;Flag Count:\u0026#34;, flag.NFlag()) } 编译运行该程序：\n1 2 $ go build -o main.exe main.go $ ./main.exe -intflag 12 -- -stringflag test 输出：\n1 2 3 4 [-stringflag test] Non-Flag Argument Count: 2 Argument 0: -stringflag Argument 1: test 解析遇到--终止后，剩余参数-stringflag test保存在flag中，可以通过Args/NArg/Arg等方法访问。\n整数选项值可以接受 1234（十进制）、0664（八进制）和 0x1234（十六进制）的形式，并且可以是负数。实际上flag在内部使用strconv.ParseInt方法将字符串解析成int。 所以理论上，ParseInt接受的格式都可以。\n布尔类型的选项值可以为：\n取值为true的：1、t、T、true、TRUE、True； 取值为false的：0、f、F、false、FALSE、False。 #\r另一种定义选项的方式\r上面我们介绍了使用flag.TypeVar定义选项，这种方式需要我们先定义变量，然后变量的地址。 还有一种方式，调用flag.Type（其中Type可以为Int/Uint/Bool/Float64/String/Duration等）会自动为我们分配变量，返回该变量的地址。用法与前一种方式类似：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;flag\u0026#34; ) var ( intflag *int boolflag *bool stringflag *string ) func init() { intflag = flag.Int(\u0026#34;intflag\u0026#34;, 0, \u0026#34;int flag value\u0026#34;) boolflag = flag.Bool(\u0026#34;boolflag\u0026#34;, false, \u0026#34;bool flag value\u0026#34;) stringflag = flag.String(\u0026#34;stringflag\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;string flag value\u0026#34;) } func main() { flag.Parse() fmt.Println(\u0026#34;int flag:\u0026#34;, *intflag) fmt.Println(\u0026#34;bool flag:\u0026#34;, *boolflag) fmt.Println(\u0026#34;string flag:\u0026#34;, *stringflag) } 编译并运行程序：\n1 2 $ go build -o main.exe main.go $ ./main.exe -intflag 12 将输出：\n1 2 3 int flag: 12 bool flag: false string flag: default 除了使用时需要解引用，其它与前一种方式基本相同。\n#\r高级用法\r#\r定义短选项\rflag库并没有显示支持短选项，但是可以通过给某个相同的变量设置不同的选项来实现。即两个选项共享同一个变量。 由于初始化顺序不确定，必须保证它们拥有相同的默认值。否则不传该选项时，行为是不确定的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;flag\u0026#34; ) var logLevel string func init() { const ( defaultLogLevel = \u0026#34;DEBUG\u0026#34; usage = \u0026#34;set log level value\u0026#34; ) flag.StringVar(\u0026amp;logLevel, \u0026#34;log_type\u0026#34;, defaultLogLevel, usage) flag.StringVar(\u0026amp;logLevel, \u0026#34;l\u0026#34;, defaultLogLevel, usage + \u0026#34;(shorthand)\u0026#34;) } func main() { flag.Parse() fmt.Println(\u0026#34;log level:\u0026#34;, logLevel) } 编译、运行程序：\n1 2 3 $ go build -o main.exe main.go $ ./main.exe -log_type WARNING $ ./main.exe -l WARNING 使用长、短选项均输出：\n1 log level: WARNING 不传入该选项，输出默认值：\n1 2 $ ./main.exe log level: DEBUG #\r解析时间间隔\r除了能使用基本类型作为选项，flag库还支持time.Duration类型，即时间间隔。时间间隔支持的格式非常之多，例如\u0026quot;300ms\u0026quot;、\u0026quot;-1.5h\u0026quot;、“2h45m\u0026quot;等等等等。 时间单位可以是 ns/us/ms/s/m/h/day 等。实际上flag内部会调用time.ParseDuration。具体支持的格式可以参见time（需fq）库的文档。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import ( \u0026#34;flag\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) var ( period time.Duration ) func init() { flag.DurationVar(\u0026amp;period, \u0026#34;period\u0026#34;, 1*time.Second, \u0026#34;sleep period\u0026#34;) } func main() { flag.Parse() fmt.Printf(\u0026#34;Sleeping for %v...\u0026#34;, period) time.Sleep(period) fmt.Println() } 根据传入的命令行选项period，程序睡眠相应的时间，默认 1 秒。编译、运行程序：\n1 2 3 4 5 6 $ go build -o main.exe main.go $ ./main.exe Sleeping for 1s... $ ./main.exe -period 1m30s Sleeping for 1m30s... #\r自定义选项\r除了使用flag库提供的选项类型，我们还可以自定义选项类型。我们分析一下标准库中提供的案例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 package main import ( \u0026#34;errors\u0026#34; \u0026#34;flag\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;time\u0026#34; ) type interval []time.Duration func (i *interval) String() string { return fmt.Sprint(*i) } func (i *interval) Set(value string) error { if len(*i) \u0026gt; 0 { return errors.New(\u0026#34;interval flag already set\u0026#34;) } for _, dt := range strings.Split(value, \u0026#34;,\u0026#34;) { duration, err := time.ParseDuration(dt) if err != nil { return err } *i = append(*i, duration) } return nil } var ( intervalFlag interval ) func init() { flag.Var(\u0026amp;intervalFlag, \u0026#34;deltaT\u0026#34;, \u0026#34;comma-seperated list of intervals to use between events\u0026#34;) } func main() { flag.Parse() fmt.Println(intervalFlag) } 首先定义一个新类型，这里定义类型interval。\n新类型必须实现flag.Value接口：\n1 2 3 4 5 // src/flag/flag.go type Value interface { String() string Set(string) error } 其中String方法格式化该类型的值，flag.Parse方法在执行时遇到自定义类型的选项会将选项值作为参数调用该类型变量的Set方法。 这里将以,分隔的时间间隔解析出来存入一个切片中。\n自定义类型选项的定义必须使用flag.Var方法。\n编译、执行程序：\n1 2 3 4 5 $ go build -o main.exe main.go $ ./main.exe -deltaT 30s [30s] $ ./main.exe -deltaT 30s,1m,1m30s [30s 1m0s 1m30s] 如果指定的选项值非法，Set方法返回一个error类型的值，Parse执行终止，打印错误和使用帮助。\n1 2 3 4 5 $ ./main.exe -deltaT 30x invalid value \u0026#34;30x\u0026#34; for flag -deltaT: time: unknown unit x in duration 30x Usage of D:\\code\\golang\\src\\github.com\\darjun\\go-daily-lib\\flag\\self-defined\\main.exe: -deltaT value comma-seperated list of intervals to use between events #\r解析程序中的字符串\r有时候选项并不是通过命令行传递的。例如，从配置表中读取或程序生成的。这时候可以使用flag.FlagSet结构的相关方法来解析这些选项。\n实际上，我们前面调用的flag库的方法，都会间接调用FlagSet结构的方法。flag库中定义了一个FlagSet类型的全局变量CommandLine专门用于解析命令行选项。 前面调用的flag库的方法只是为了提供便利，它们内部都是调用的CommandLine的相应方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // src/flag/flag.go var CommandLine = NewFlagSet(os.Args[0], ExitOnError) func Parse() { CommandLine.Parse(os.Args[1:]) } func IntVar(p *int, name string, value int, usage string) { CommandLine.Var(newIntValue(value, p), name, usage) } func Int(name string, value int, usage string) *int { return CommandLine.Int(name, value, usage) } func NFlag() int { return len(CommandLine.actual) } func Arg(i int) string { return CommandLine.Arg(i) } func NArg() int { return len(CommandLine.args) } 同样的，我们也可以自己创建FlagSet类型变量来解析选项。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package main import ( \u0026#34;flag\u0026#34; \u0026#34;fmt\u0026#34; ) func main() { args := []string{\u0026#34;-intflag\u0026#34;, \u0026#34;12\u0026#34;, \u0026#34;-stringflag\u0026#34;, \u0026#34;test\u0026#34;} var intflag int var boolflag bool var stringflag string fs := flag.NewFlagSet(\u0026#34;MyFlagSet\u0026#34;, flag.ContinueOnError) fs.IntVar(\u0026amp;intflag, \u0026#34;intflag\u0026#34;, 0, \u0026#34;int flag value\u0026#34;) fs.BoolVar(\u0026amp;boolflag, \u0026#34;boolflag\u0026#34;, false, \u0026#34;bool flag value\u0026#34;) fs.StringVar(\u0026amp;stringflag, \u0026#34;stringflag\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;string flag value\u0026#34;) fs.Parse(args) fmt.Println(\u0026#34;int flag:\u0026#34;, intflag) fmt.Println(\u0026#34;bool flag:\u0026#34;, boolflag) fmt.Println(\u0026#34;string flag:\u0026#34;, stringflag) } NewFlagSet方法有两个参数，第一个参数是程序名称，输出帮助或出错时会显示该信息。第二个参数是解析出错时如何处理，有几个选项：\nContinueOnError：发生错误后继续解析，CommandLine就是使用这个选项； ExitOnError：出错时调用os.Exit(2)退出程序； PanicOnError：出错时产生 panic。 随便看一眼flag库中的相关代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // src/flag/flag.go func (f *FlagSet) Parse(arguments []string) error { f.parsed = true f.args = arguments for { seen, err := f.parseOne() if seen { continue } if err == nil { break } switch f.errorHandling { case ContinueOnError: return err case ExitOnError: os.Exit(2) case PanicOnError: panic(err) } } return nil } 与直接使用flag库的方法有一点不同，FlagSet调用Parse方法时需要显示传入字符串切片作为参数。因为flag.Parse在内部调用了CommandLine.Parse(os.Args[1:])。 示例代码都放在GitHub上了。\n#\r参考\rflag库文档 Go 每日一库之 flag ","date":"2024-04-22T18:02:17+08:00","permalink":"https://arlettebrook.github.io/p/go-flag%E5%BA%93%E4%BB%8B%E7%BB%8D/","title":"Go flag库介绍"},{"content":"\r#\r静态网页生成器\r无论您需要搭建个人博客还是为您的项目创建文档，静态网页生成器（static site generator）都是一个不错的选择。无需服务器、数据库，只要你熟悉 Markdown，喜欢GitHub，使用生成器创建静态 HTML 文件，然后推送到 GitHub Pages 等免费服务即可。\n#\r常见的静态网页生成器\rHugo是由Go语言实现的静态网站生成器。简单、易用、高效、易扩展、快速部署。 jekyll 是一个静态网页、博客生成器 vuepress是基于 Vue 的静态网页生成器 Hexo 是一个由Nodejs驱动的快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 参考：静态网页生成器\n#\r快速使用Hugo搭建个人博客站点\r#\r安装Hugo\r根据自己的操作系统，下载已经构建好的Hugo二进制文件官方地址\n官方推荐下载扩展版，支持的功能更多 解压之后，将hugo可执行文件加入到PATH环境变量中，即可使用\n1 2 3 hugo version # 查看版本，扩展版含这个extended标签 hugo -h # 显示帮助信息 hugo subcommand -h # 获取子命令的帮助信息 #\r使用Hugo\rhugo需要配合git一起使用，并且官方推荐使用bash作为终端\n创建项目并安装主题hugo-theme-stack\n1 2 3 4 5 hugo new site quickstart # 创建目录结构 cd quickstart git init git submodule add https://github.com/CaiJimmy/hugo-theme-stack/ themes/hugo-theme-stack # 安装主题 添加内容并使用安装主题的默认配置\n使用安装主题的实例进行快速添加内容 只需要进入主题文件中的exampleSite中的content拷贝到quickstart根目录中 同理，在主题文件中的exampleSite中的hugo.yaml拷贝到quickstart根目录中，重命名为,并删除hugo.toml 最后运行\n1 2 hugo server # 本地启动一个http服务器，便于开发和测试站点，默认热更新 hugo server --navigateToChanged # 自动重定向：编辑内容时，浏览器会自动重定向到上次修改的页面 会使用到的命令\n1 2 3 4 5 6 7 8 9 10 11 hugo new content post/fist-post.md # 会在content目录下创建post/fist-post.md文件 # 执行完后，会在content/post目录自动生成一个MarkDown格式的first.md文件： +++ date = \u0026#34;2015-01-08T08:36:54-07:00\u0026#34; draft = true title = \u0026#34;Fist Post\u0026#34; +++ # draft 默认为true，构建网站时不会构建该文档 # 要构建草稿文档可以用-D或--buildDrafts选项启动服务 hugo server -D # title 默认为文件名首字母大写 构建命令\n进入项目目录，运行\n1 hugo hugo命令会构建生成静态文件，会将文件发布项目的public目录下\n要将站点发布到其他目录，请使用该标志--destination或在站点配置中设置publishDir\n注意：每次构建不会清空public目录，只会覆盖旧内容。\n这样做是为了防止，构建之后在public添加的文件被删除\n草稿、未来和过期内容\nHugo 允许在内容的前面设置draft、date、publishDate和expiryDate。默认情况下，Hugo 在以下情况下不会发布内容：\n其draft值为true\n是date在未来\n是publishDate在未来\n已经expiryDate过去了\n下面的行为可以取消\n1 2 3 hugo --buildDrafts # or -D hugo --buildExpired # or -E hugo --buildFuture # or -F 注意：当这样构建之后，需要手动删除不期望构建的文件，在推送站点\n否则当推送到远程会出现意外的内容\n所以建议运行上面的命令之后，前提public中没有手动添加的文件，在构建之前手动清空public目录，防止出现草稿、过期和未来的内容\n最后将public中的所以文件推送到静态网站托管平台即可\n也可以使用自动构建和部署 更多内容参考：\n使用hugo搭建个人博客站点 （1）带着Stack主题入坑Hugo （2）部署你的Hugo博客 （3）Stack主题的自定义 自定义主题添加了assets/scss、layouts/_default/、layouts/index.html,不用了删了就行 #\r目录结构\rarchetypes目录包含新内容的模板\n目录下的default.md由标记（markdown）和内容格式\n内容格式：\u0026mdash;yaml\u0026mdash;、+++toml+++、{json}\n1 2 3 4 5 --- # +++/{ date: \u0026#39;{{ .Date }}\u0026#39; # yaml draft: true title: \u0026#39;{{ replace .File.ContentBaseName `-` ` ` | title }}\u0026#39; --- # +++/{ 当运行hugo new content post/my-first-post.md命令时会根据default.md创建内容文件\n1 2 3 4 5 --- date: \u0026#34;2023-08-24T11:49:46-07:00\u0026#34; draft: true title: My First Post --- 可以创建新内容的模版\n1 2 3 archetypes/ ├── default.md └── post.md 若运行hugo new content post/my-first-post.md查找模版的顺序 archetypes/post.md archetypes/default.md themes/my-theme/archetypes/post.md themes/my-theme/archetypes/default.md 如果这些都不存在，Hugo 将使用内置的默认原型 assets目录包含通常通过资产管道传递的全局资源，包括图像、CSS、Sass、JavaScript 和 TypeScript 等资源。\nconfig目录包含站点配置，可能分为多个子目录和文件。对于具有最少配置的项目或不需要在不同环境中表现不同的项目，hugo.toml在项目根目录中命名的单个配置文件就足够了\ncontent目录包含构成站点内容的标记文件（通常是 Markdown）和页面资源。\n对应stack主题： post存放发布的文章格式md page存放导航区域的md格式配置 不同的语言结尾用.en.md等表示 根据模版进行修改即可，根据自己的需求，没有的需要自己补充和修改文件内容 categories存放类别的md格式配置 data目录包含增强内容、配置、本地化和导航的数据文件（JSON、TOML、YAML 或 XML）。\ni18n目录包含多语言站点的翻译表。\ncontent目录包含将内容、数据和资源转换为完整网站的模板。\npublic目录包含运行hugo或hugo server命令时生成的已发布网站。 Hugo 根据需要重新创建该目录及其内容\nresources目录包含 Hugo 资产管道的缓存输出，这些输出是在运行hugo或hugo server命令时生成的。默认情况下，此缓存目录包括 CSS 和图像。 Hugo 根据需要重新创建该目录及其内容。\nstatic目录包含在您构建站点时将复制到公共目录的文件。例如：favicon.ico、robots.txt和 验证站点所有权的文件.与assets差不多\nthemes目录包含一个或多个主题，每个主题都位于其自己的子目录中。\n联合文件系统：\n这样理解：安装的主题里面同样有自己站点的目录结构，hugo构建时会将主题里面的文件挂载到站点，优先级是站点的高 #\r配置文件\rhugo支持三种配置文件hugo.tomal、hugo.yaml、hugo.json，喜欢用那个就用那个。\n每种文件格式的规范：TOML、YAML和JSON。\n配置文件可以有多个，可以放到config目录下，默认都是使用hugo开头的文件\n指定配置文件构建\n1 2 hugo server --config other.toml hugo --config a.toml,b.yaml,c.json # 可以指定多个，左边的优先级高 更多内容配置参考\n额外的一些关于配置文件的总结\n默认语言修改为zh-cn，意味着index.md表示中文，index.zh-cn.md也表示中文，此时的英文要用index.en.md表示 更多内容参考：\nHugo官方文档 Hugo中文文档 Hugo theme #\r文章评论\r使用Waline，其教程很完整。\n根据Waline教程从头完成到使用Vercel部署完成。\n最后在config.yaml中的waline的serverURL给上你的Vercel服务器地址。\n以及开启评论，最后waline还可以配置评论通知渠道。\n将cloudflare解析的域名绑定到vercel文档 概括：添加一条CNAME记录值为cname.vercel-dns.com，开启代理，将SSL/TLS修改为完全 将cloudflare解析的域名绑定到github-pages文档 概括：添加一条子域，类型CNAME记录值为username.github.io，开启代理，将SSL/TLS修改为完全,username为你的用户名 更多内容请查阅文档 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 comments: enabled: true provider: waline waline: serverURL: url lang: zh-cn pageview: true copyright: false emoji: - https://unpkg.com/@waline/emojis@1.0.1/weibo requiredMeta: - name - email locale: admin: 👻Hi! placeholder: 🎉留下你的脚印... #\r搜索引擎优化（SEO）\r本网站使用Hugo搭建，而且使用的stack主题支持自动生成基于Open Graph协议（OG协议）的标签，此处记录一下如何在Hugo搭建的网站中做搜索引擎优化（SEO）。\n目的：提升网站在搜索引擎中的排名\nOpen Graph（开放图谱）协议，简称OG协议，是Facebook在2010年公布的一项协议，用来标记网页内容。简单来讲，OG协议就是嵌在网页头部的一些标签，这些标签标记了网页的标题、描述等特征，使得网页成为一个“富媒体对象”，可以被其他社交网站引用。\n很多搜索引擎都支持OG协议，在网页中使用OG协议的标签，就更有利于提升我们的网页在搜索引擎中的排名。\nOG协议的标签在网页中通常表示为类似下面所示的格式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;meta property=\u0026#34;og:title\u0026#34; content=\u0026#34;The Rock\u0026#34; /\u0026gt; \u0026lt;meta property=\u0026#34;og:type\u0026#34; content=\u0026#34;video.movie\u0026#34; /\u0026gt; \u0026lt;meta property=\u0026#34;og:url\u0026#34; content=\u0026#34;https://www.imdb.com/title/tt0117500/\u0026#34; /\u0026gt; \u0026lt;meta property=\u0026#34;og:image\u0026#34; content=\u0026#34;https://ia.media-imdb.com/images/rock.jpg\u0026#34; /\u0026gt; \u0026lt;meta property=\u0026#39;og:url\u0026#39; content=\u0026#39;https://arlettebrook.github.io/search/\u0026#39;\u0026gt; \u0026lt;meta property=\u0026#39;og:site_name\u0026#39; content=\u0026#39;Arlettebrook\u0026amp;#39;s blog\u0026#39;\u0026gt; \u0026lt;meta property=\u0026#39;og:type\u0026#39; content=\u0026#39;article\u0026#39;\u0026gt;\u0026lt;meta property=\u0026#39;article:section\u0026#39; content=\u0026#39;P age\u0026#39; /\u0026gt; -\u0026lt;meta name=\u0026#34;twitter:title\u0026#34; content=\u0026#34;搜索\u0026#34;\u0026gt; +\u0026lt;meta name=\u0026#34;twitter:site\u0026#34; content=\u0026#34;@arlettebrook\u0026#34;\u0026gt; + \u0026lt;meta name=\u0026#34;twitter:creator\u0026#34; content=\u0026#34;@arlettebrook\u0026#34;\u0026gt;\u0026lt;meta name=\u0026#34;twitter:title\u0026#34; co ntent=\u0026#34;搜索\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;twitter:description\u0026#34; content=\u0026#34;\u0026#34;\u0026gt;\u0026lt;link rel=\u0026#34;alternate\u0026#34; type=\u0026#34;application/js on\u0026#34; href=\u0026#34;https://arlettebrook.github.io/search/index.json\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;shortcut icon\u0026#34; href=\u0026#34;/img/favicon.ico\u0026#34; /\u0026gt; stack主题提供了对OG协议的支持，只需要在网站根目录下的config/_default/params.en.yaml和config/_default/params.zh-cn.yaml配置文件中开启即可：\n1 2 3 4 5 6 7 opengraph: twitter: # Your Twitter username site: JinliCyou # Available values: summary, summary_large_image card: summary_large_image 这样，Hugo在生成和部署网站时就会在网页HTML文件中自动嵌入OG标签。\n参考：个人网站的建立过程（四）：网站的搜索引擎优化（SEO）\n#\r额外的一些知识\rgh-pages 是GitHub 所提供的一个服务，简单来讲就是可以让你不用花钱也可以部署一个静态网页作为展示用，因此对于前端工程师来讲就非常方便而且很实用，但是部署方式有很多。\ngh-pages是github-pages的缩写，可以用于个人博客和项目介绍的网站服务。\ngh-pages也是github特殊的分支，用来存放网站相关的一些资源，通常网站地址为username.github.io/仓库名\n项目名与username.github.io一样的话，可以省略仓库名，跟github个人资料页面一样，所以这个仓库是一个特殊的仓库，默认会自动开启gh-pages服务。别的需要手动。\n虽然gh-pages 是属于免费的服务，基本上只要你持有GitHub 帐号就可以使用，但是它基本上有几个重点可以稍微注意一下：\n只能放置纯静态网页，也就是说没有后端的网页，例如PHP、Node.js、Python 等等，只能是纯HTML、CSS、JavaScript 等等，因为它并没有运算能力。 gh-pages 是以储存库为单位，也就是说每个储存库都可以有一个gh-pages 分支，但是每个储存库只能有一个gh-pages 分支，因此如果你想要部署多个网页，那么你就需要建立多个储存库。 gh-pages 的容量是有限制的，每个储存库的容量是1GB，如果你的网页超过这个容量，那么就无法部署。 gh-pages 的流量为每月100GB gh-pages 每小时只能部署10 次，如果是使用自己写的GitHub Actions 就没有这个限制（毕竟要花钱）。 免费的ssh 凭证 预设的网域是https://\u0026lt;username\u0026gt;.github.io/\u0026lt;repository\u0026gt;，如果你想要使用自己的网域，那么你就需要花钱购买网域，并且设定DNS 最后要稍微注意一下gh-pages 虽然是免费提供的静态网页托管服务，但是它并不能拿来作为商业用途或是违法用途，否则你的帐号可能会被封锁\n简单说一下如何查看一个仓库是否启用gh-pages：进入项目settings-pages查看即可，有绿色钩就启动成功，没有需要指定分支和根目录，保存，稍等一会就行。\n#\r用gh-pages分支展示自己的项目\r我们只需要将网页资源上传至gh-pages分支即可\n搭建项目网站：将项目网站资源推送到gh-pages分支上,静态资源必须提交了才会成功\n1 git subtree push --prefix=dist origin gh-pages # dist为项目网站的目录 拉取指定分支\n1 2 3 4 5 6 7 8 git fetch origin # 获取origin仓库的信息 git checkout -b aaa origin/aaa # 创建并检出分支 # git clone之后也也可以检出分支 git checkout gh-page # 失败用上面办法 # 在git clone 的时候可以指定分支-b选项 git clone -b url 如果要项目中不含自己网站的源码，可以忽略public目录，将public目录创建为一个私有仓库的子目录，然后将子目录作为，项目的gh-pages分支。\n上面的方式是最简单的。\n","date":"2024-04-22T16:12:26+08:00","image":"https://arlettebrook.github.io/p/%E5%9F%BA%E4%BA%8Ehugo%E5%92%8Cgh-pages%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99/hugo_hu45a5e3ad5e058da6a00650ed8fd40bea_15530_120x120_fill_q75_box_smart1.jpg","permalink":"https://arlettebrook.github.io/p/%E5%9F%BA%E4%BA%8Ehugo%E5%92%8Cgh-pages%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99/","title":"基于Hugo和gh-pages快速搭建静态网站"}]